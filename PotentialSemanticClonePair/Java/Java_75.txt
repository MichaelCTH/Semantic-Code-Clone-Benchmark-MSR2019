$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32299089_43278861_189_199
32299089_43278861_204_213
Title: Calculator in Android Studio 
----------------------------------------

public void onClick (View v) {
    if (textViewresult.getText () == "") {
        textViewresult.setText ("");
    } else {
        val1 = Double.parseDouble (textViewresult.getText () + "");
        sub = true;
        textViewresult.setText (null);
    }
}
----------------------------------------

public void onClick (View v) {
    if (textViewresult.getText () == "") {
        textViewresult.setText ("");
    } else {
        val1 = Double.parseDouble (textViewresult.getText () + "");
        mul = true;
        textViewresult.setText (null);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32299089_43278861_189_199
32299089_43278861_217_226
Title: Calculator in Android Studio 
----------------------------------------

public void onClick (View v) {
    if (textViewresult.getText () == "") {
        textViewresult.setText ("");
    } else {
        val1 = Double.parseDouble (textViewresult.getText () + "");
        sub = true;
        textViewresult.setText (null);
    }
}
----------------------------------------

public void onClick (View v) {
    if (textViewresult.getText () == "") {
        textViewresult.setText ("");
    } else {
        val1 = Double.parseDouble (textViewresult.getText () + "");
        div = true;
        textViewresult.setText (null);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32299089_43278861_189_199
32299089_43278861_231_262
Title: Calculator in Android Studio 
----------------------------------------

public void onClick (View v) {
    if (textViewresult.getText () == "") {
        textViewresult.setText ("");
    } else {
        val1 = Double.parseDouble (textViewresult.getText () + "");
        sub = true;
        textViewresult.setText (null);
    }
}
----------------------------------------

public void onClick (View v) {
    if (textViewresult.getText () == "") {
        textViewresult.setText ("");
    } else {
        equalcheck = true;
        val2 = Double.parseDouble (textViewresult.getText () + "");
        if (add == true) {
            textViewresult.setText (val1 + val2 + "");
            add = false;
        }
        if (sub == true) {
            textViewresult.setText (val1 - val2 + "");
            sub = false;
        }
        if (mul == true) {
            textViewresult.setText (val1 * val2 + "");
            mul = false;
        }
        if (div == true) {
            textViewresult.setText (val1 / val2 + "");
            div = false;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32299089_43278861_204_213
32299089_43278861_217_226
Title: Calculator in Android Studio 
----------------------------------------

public void onClick (View v) {
    if (textViewresult.getText () == "") {
        textViewresult.setText ("");
    } else {
        val1 = Double.parseDouble (textViewresult.getText () + "");
        mul = true;
        textViewresult.setText (null);
    }
}
----------------------------------------

public void onClick (View v) {
    if (textViewresult.getText () == "") {
        textViewresult.setText ("");
    } else {
        val1 = Double.parseDouble (textViewresult.getText () + "");
        div = true;
        textViewresult.setText (null);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32299089_43278861_204_213
32299089_43278861_231_262
Title: Calculator in Android Studio 
----------------------------------------

public void onClick (View v) {
    if (textViewresult.getText () == "") {
        textViewresult.setText ("");
    } else {
        val1 = Double.parseDouble (textViewresult.getText () + "");
        mul = true;
        textViewresult.setText (null);
    }
}
----------------------------------------

public void onClick (View v) {
    if (textViewresult.getText () == "") {
        textViewresult.setText ("");
    } else {
        equalcheck = true;
        val2 = Double.parseDouble (textViewresult.getText () + "");
        if (add == true) {
            textViewresult.setText (val1 + val2 + "");
            add = false;
        }
        if (sub == true) {
            textViewresult.setText (val1 - val2 + "");
            sub = false;
        }
        if (mul == true) {
            textViewresult.setText (val1 * val2 + "");
            mul = false;
        }
        if (div == true) {
            textViewresult.setText (val1 / val2 + "");
            div = false;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32299089_43278861_217_226
32299089_43278861_231_262
Title: Calculator in Android Studio 
----------------------------------------

public void onClick (View v) {
    if (textViewresult.getText () == "") {
        textViewresult.setText ("");
    } else {
        val1 = Double.parseDouble (textViewresult.getText () + "");
        div = true;
        textViewresult.setText (null);
    }
}
----------------------------------------

public void onClick (View v) {
    if (textViewresult.getText () == "") {
        textViewresult.setText ("");
    } else {
        equalcheck = true;
        val2 = Double.parseDouble (textViewresult.getText () + "");
        if (add == true) {
            textViewresult.setText (val1 + val2 + "");
            add = false;
        }
        if (sub == true) {
            textViewresult.setText (val1 - val2 + "");
            sub = false;
        }
        if (mul == true) {
            textViewresult.setText (val1 * val2 + "");
            mul = false;
        }
        if (div == true) {
            textViewresult.setText (val1 / val2 + "");
            div = false;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32319463_32320190_1_25
32319463_32320304_1_36
Title: "Given a string as input return the char which occurs the maximum number of times in the string" 
----------------------------------------

public char mostFreq (String str) {
    Map < Character, Integer > occurences = new HashMap < Character, Integer > ();
    Character mostFreq = null;
    if (str != null && str.length () > 0) {
        char [] chars = str.toCharArray ();
        for (char c : chars) {
            if (occurences.containsKey (c)) {
                occurences.put (c, occurences.get (c) + 1);
            } else {
                occurences.put (c, 1);
            }
        }
        int count = 0;
        for (Map.Entry < Character, Integer > entry : occurences.entrySet ()) {
            if (entry.getValue () > count) {
                mostFreq = entry.getKey ();
                count = entry.getValue ();
            }
        }
    }
    return mostFreq;
}
----------------------------------------

public char mostFreq (String str) {
    int highestFreq = 0;
    char mostFreqChar = ' ';
    for (int i = 0;
    i < str.length (); i ++) {
        char x = str.charAt (i);
        int c = 0;
        for (int j = str.indexOf (x);
        j != - 1; j = str.indexOf (x, j + 1)) {
            c ++;
        }
        if (c > highestFreq) {
            highestFreq = c;
            mostFreqChar = x;
        }
    }
    return mostFreqChar;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32328881_32328963_21_33
32328881_32328963_44_56
Title: Java lock (synchronize) global variable 
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "1";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "2";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32328881_32328963_21_33
32328881_32329049_17_33
Title: Java lock (synchronize) global variable 
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "1";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "1";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32328881_32328963_21_33
32328881_32329049_40_56
Title: Java lock (synchronize) global variable 
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "1";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "2";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32328881_32328963_21_33
32328881_32329130_24_38
Title: Java lock (synchronize) global variable 
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "1";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    while (! lock);

    for (int i = 0;
    i < 10; i ++) {
        string = "1";
        System.out.println (string);
        try {
            sleep (100);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
    releaseResource ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32328881_32328963_21_33
32328881_32329130_43_55
Title: Java lock (synchronize) global variable 
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "1";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    while (lock);

    for (int i = 0;
    i < 10; i ++) {
        string = "2";
        System.out.println (string);
        try {
            sleep (100);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32328881_32328963_44_56
32328881_32329049_17_33
Title: Java lock (synchronize) global variable 
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "2";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "1";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32328881_32328963_44_56
32328881_32329049_40_56
Title: Java lock (synchronize) global variable 
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "2";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "2";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32328881_32328963_44_56
32328881_32329130_24_38
Title: Java lock (synchronize) global variable 
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "2";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    while (! lock);

    for (int i = 0;
    i < 10; i ++) {
        string = "1";
        System.out.println (string);
        try {
            sleep (100);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
    releaseResource ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32328881_32328963_44_56
32328881_32329130_43_55
Title: Java lock (synchronize) global variable 
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "2";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    while (lock);

    for (int i = 0;
    i < 10; i ++) {
        string = "2";
        System.out.println (string);
        try {
            sleep (100);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32328881_32329049_17_33
32328881_32329049_40_56
Title: Java lock (synchronize) global variable 
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "1";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "2";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32328881_32329049_17_33
32328881_32329130_24_38
Title: Java lock (synchronize) global variable 
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "1";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    while (! lock);

    for (int i = 0;
    i < 10; i ++) {
        string = "1";
        System.out.println (string);
        try {
            sleep (100);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
    releaseResource ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32328881_32329049_17_33
32328881_32329130_43_55
Title: Java lock (synchronize) global variable 
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "1";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    while (lock);

    for (int i = 0;
    i < 10; i ++) {
        string = "2";
        System.out.println (string);
        try {
            sleep (100);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32328881_32329049_40_56
32328881_32329130_24_38
Title: Java lock (synchronize) global variable 
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "2";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    while (! lock);

    for (int i = 0;
    i < 10; i ++) {
        string = "1";
        System.out.println (string);
        try {
            sleep (100);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
    releaseResource ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32328881_32329049_40_56
32328881_32329130_43_55
Title: Java lock (synchronize) global variable 
----------------------------------------

public void run () {
    synchronized (lock) {
        for (int i = 0;
        i < 10; i ++) {
            string = "2";
            System.out.println (string);
            try {
                sleep (100);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    while (lock);

    for (int i = 0;
    i < 10; i ++) {
        string = "2";
        System.out.println (string);
        try {
            sleep (100);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32332033_32332247_6_18
32332033_32333534_3_26
Title: Java Thread: Real Time Application Example 
----------------------------------------

public static void main (String [] args) {
    List < Integer > list = new ArrayList < > (Arrays.asList (1, 2, 3));
    for (int i : list) {
        Thread th = new Thread () {
            @Override
            public void run () {
                System.out.println (i);
            }}

        ;
        th.start ();
    }
}
----------------------------------------

public static void main (String [] args) {
    final List < Integer > myIntegerList = Arrays.asList (1, 2, 3);
    for (Integer item : myIntegerList) {
        System.out.print (item);
    }
    final Consumer < Integer > consumer = new Consumer < Integer > () {
        @Override
        public void accept (Integer item) {
            System.out.print (item);
        }}

    ;
    myIntegerList.forEach (consumer);
    myIntegerList.forEach ((item) -> System.out.print (item));
    myIntegerList.parallelStream ().forEach ((item) -> System.out.print (item));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32336952_32337094_21_40
32336952_32337094_9_17
Title: Calculating work time and cash 
----------------------------------------

public void onClick (View v) {
    Log.d (TAG, "onClick: stopping");
    Calendar c = Calendar.getInstance ();
    finmin = c.get (Calendar.MINUTE);
    finhour = c.get (Calendar.HOUR_OF_DAY);
    if (finhour >= beghour) workhour = finhour - beghour;
    else workhour = 12 - beghour + finhour;

    workmin = finmin - begmin;
    hourcashto = (float) (workhour * 20);
    mincashto = (float) (20 * (workmin / 60));
    cashto = hourcashto + mincashto;
    cash = prefs.getFloat ("key", 0);
    cash = cash + cashto;
    SharedPreferences.Editor edit = prefs.edit ();
    edit.putFloat ("key", cash);
    edit.commit ();
    textView.setText ("cash now: " + cashto + " cash total including today: " + cash + " \n" + "Time today: " + workhour + ":" + workmin);
}
----------------------------------------

public void onClick (View v) {
    Log.d (TAG, "onClick: starting");
    c = Calendar.getInstance ();
    begmin = c.get (Calendar.MINUTE);
    beghour = c.get (Calendar.HOUR_OF_DAY);
    SharedPreferences.Editor edit = prefs.edit ();
    edit.putInt ("key1", begmin);
    edit.putInt ("key2", beghour);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32345371_32345458_6_13
32345371_32346110_6_15
Title: How to write and read dat file 
----------------------------------------

private static void writeNumbers () throws IOException {
    DataOutputStream output = new DataOutputStream (new FileOutputStream ("C://Numbers.dat"));
    for (int i = 0;
    i < 10; i ++) {
        output.writeInt (i);
        System.out.println (i);
    }
    output.close ();
}
----------------------------------------

private static void writeNumbers () throws IOException {
    DataOutputStream output = new DataOutputStream (new FileOutputStream ("C://Numbers.dat"));
    Scanner scanner = new Scanner (System.in);
    int n = scanner.nextInt ();
    while (n != - 1) {
        output.writeInt (n);
        n = scanner.nextInt ();
    }
    output.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32346440_32346494_1_26
32346440_32346527_1_27
Title: breakout of recursion and return value in java 
----------------------------------------

public String walk (String folderpath) {
    String f1 = "";
    File root = new File (folderpath);
    File [] list = root.listFiles ();
    if (list == null) return f1;

    for (File f : list) {
        if (f.isDirectory ()) {
            walk (f.getAbsolutePath ());
            f1 = f.getAbsolutePath ();
            if (f1.contains ("foldername")) {
                return f1;
            }
        }
    }
    return f1;
}
----------------------------------------

public String walk (String folderpath) {
    String f1 = "";
    File root = new File (folderpath);
    File [] list = root.listFiles ();
    if (list == null) return f1;

    for (File f : list) {
        if (f.isDirectory ()) {
            walk (f.getAbsolutePath ());
            f1 = f.getAbsolutePath ();
            if (f1.contains ("foldername")) {
                System.out.println (+ f1);
                return f1;
            }
        }
    }
    return "noFolderName";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32346463_32347076_109_121
32346463_32347076_16_44
Title: Thread execution continues even after exception in java 
----------------------------------------

public void run () {
    System.out.println ("Running Thread 5");
    for (int i = 0;
    i < 10; i ++) {
        System.out.println ("iteration: " + i + " " + t5.getName ());
        try {
            Thread.sleep (5);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
    latchForAllOtherThreads.countDown ();
}
----------------------------------------

public void run () {
    try {
        System.out.println ("Waiting for Thread 2 to finish");
        waitForStartSignalFromThread1.countDown ();
        waitForThread2ToFinish.await ();
        if (flag == true) {
            System.out.println ("Successful.");
            t3.start ();
            t4.start ();
            t5.start ();
            System.out.println ("All the dependencies resolved.");
            System.out.println ("Waiting for the remaining threads to complete their work.");
            try {
                latchForAllOtherThreads.await ();
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
            System.out.println ("All the threads have finished doing their work. Exiting now...");
        } else {
            System.out.println ("Error.");
        }
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32346463_32347076_109_121
32346463_32347076_47_74
Title: Thread execution continues even after exception in java 
----------------------------------------

public void run () {
    System.out.println ("Running Thread 5");
    for (int i = 0;
    i < 10; i ++) {
        System.out.println ("iteration: " + i + " " + t5.getName ());
        try {
            Thread.sleep (5);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
    latchForAllOtherThreads.countDown ();
}
----------------------------------------

public void run () {
    System.out.println ("Before Starting for loop");
    try {
        System.out.println ("waiting for thread 1 to countdown latch2");
        waitForStartSignalFromThread1.await ();
        System.out.println ("Starting for loop");
        for (int i = 0;
        i < 5; i ++) {
            System.out.println ("iteration: " + i);
            try {
                Thread.sleep (5);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
        int x = 1 / 0;
        System.out.println ("countdown by thread2 for latch 1 done.");
        flag = true;
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        waitForThread2ToFinish.countDown ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32346463_32347076_16_44
32346463_32347076_47_74
Title: Thread execution continues even after exception in java 
----------------------------------------

public void run () {
    try {
        System.out.println ("Waiting for Thread 2 to finish");
        waitForStartSignalFromThread1.countDown ();
        waitForThread2ToFinish.await ();
        if (flag == true) {
            System.out.println ("Successful.");
            t3.start ();
            t4.start ();
            t5.start ();
            System.out.println ("All the dependencies resolved.");
            System.out.println ("Waiting for the remaining threads to complete their work.");
            try {
                latchForAllOtherThreads.await ();
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
            System.out.println ("All the threads have finished doing their work. Exiting now...");
        } else {
            System.out.println ("Error.");
        }
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public void run () {
    System.out.println ("Before Starting for loop");
    try {
        System.out.println ("waiting for thread 1 to countdown latch2");
        waitForStartSignalFromThread1.await ();
        System.out.println ("Starting for loop");
        for (int i = 0;
        i < 5; i ++) {
            System.out.println ("iteration: " + i);
            try {
                Thread.sleep (5);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
        int x = 1 / 0;
        System.out.println ("countdown by thread2 for latch 1 done.");
        flag = true;
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        waitForThread2ToFinish.countDown ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32346463_32347076_16_44
32346463_32347076_77_89
Title: Thread execution continues even after exception in java 
----------------------------------------

public void run () {
    try {
        System.out.println ("Waiting for Thread 2 to finish");
        waitForStartSignalFromThread1.countDown ();
        waitForThread2ToFinish.await ();
        if (flag == true) {
            System.out.println ("Successful.");
            t3.start ();
            t4.start ();
            t5.start ();
            System.out.println ("All the dependencies resolved.");
            System.out.println ("Waiting for the remaining threads to complete their work.");
            try {
                latchForAllOtherThreads.await ();
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
            System.out.println ("All the threads have finished doing their work. Exiting now...");
        } else {
            System.out.println ("Error.");
        }
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public void run () {
    System.out.println ("Running Thread 3");
    for (int i = 0;
    i < 10; i ++) {
        System.out.println ("iteration: " + i + " " + t3.getName ());
        try {
            Thread.sleep (5);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
    latchForAllOtherThreads.countDown ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32346463_32347076_16_44
32346463_32347076_93_105
Title: Thread execution continues even after exception in java 
----------------------------------------

public void run () {
    try {
        System.out.println ("Waiting for Thread 2 to finish");
        waitForStartSignalFromThread1.countDown ();
        waitForThread2ToFinish.await ();
        if (flag == true) {
            System.out.println ("Successful.");
            t3.start ();
            t4.start ();
            t5.start ();
            System.out.println ("All the dependencies resolved.");
            System.out.println ("Waiting for the remaining threads to complete their work.");
            try {
                latchForAllOtherThreads.await ();
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
            System.out.println ("All the threads have finished doing their work. Exiting now...");
        } else {
            System.out.println ("Error.");
        }
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public void run () {
    System.out.println ("Running Thread 4");
    for (int i = 0;
    i < 10; i ++) {
        System.out.println ("iteration: " + i + " " + t4.getName ());
        try {
            Thread.sleep (5);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
    latchForAllOtherThreads.countDown ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32346463_32347076_47_74
32346463_32347076_77_89
Title: Thread execution continues even after exception in java 
----------------------------------------

public void run () {
    System.out.println ("Before Starting for loop");
    try {
        System.out.println ("waiting for thread 1 to countdown latch2");
        waitForStartSignalFromThread1.await ();
        System.out.println ("Starting for loop");
        for (int i = 0;
        i < 5; i ++) {
            System.out.println ("iteration: " + i);
            try {
                Thread.sleep (5);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
        int x = 1 / 0;
        System.out.println ("countdown by thread2 for latch 1 done.");
        flag = true;
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        waitForThread2ToFinish.countDown ();
    }
}
----------------------------------------

public void run () {
    System.out.println ("Running Thread 3");
    for (int i = 0;
    i < 10; i ++) {
        System.out.println ("iteration: " + i + " " + t3.getName ());
        try {
            Thread.sleep (5);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
    latchForAllOtherThreads.countDown ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32346463_32347076_47_74
32346463_32347076_93_105
Title: Thread execution continues even after exception in java 
----------------------------------------

public void run () {
    System.out.println ("Before Starting for loop");
    try {
        System.out.println ("waiting for thread 1 to countdown latch2");
        waitForStartSignalFromThread1.await ();
        System.out.println ("Starting for loop");
        for (int i = 0;
        i < 5; i ++) {
            System.out.println ("iteration: " + i);
            try {
                Thread.sleep (5);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
        int x = 1 / 0;
        System.out.println ("countdown by thread2 for latch 1 done.");
        flag = true;
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        waitForThread2ToFinish.countDown ();
    }
}
----------------------------------------

public void run () {
    System.out.println ("Running Thread 4");
    for (int i = 0;
    i < 10; i ++) {
        System.out.println ("iteration: " + i + " " + t4.getName ());
        try {
            Thread.sleep (5);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
    latchForAllOtherThreads.countDown ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32358084_32358501_13_29
32358084_32363319_13_25
Title: Pool filler service with minimum and maximum threshold setting 
----------------------------------------

public static void main (String...args) throws InterruptedException {
    final LinkedBlockingDeque < Object > linkedBlockingDeque = new LinkedBlockingDeque < > ();
    final ExecutorService executorService = Executors.newFixedThreadPool (4);
    final Lock fillLock = new ReentrantLock ();
    final AtomicBoolean stop = new AtomicBoolean (false);
    for (int i = 0;
    i < 4; i ++) {
        executorService.execute (new Worker (linkedBlockingDeque, fillLock, stop));
    }
    Thread.sleep (TimeUnit.SECONDS.toMillis (30));
    stop.set (true);
    executorService.shutdown ();
    executorService.awaitTermination (30, TimeUnit.SECONDS);
}
----------------------------------------

public static void main (String [] args) {
    BlockingQueue < Object > pool = new LinkedBlockingQueue < > ();
    AtomicInteger currentPoolSize = new AtomicInteger (0);
    BlockingQueue < Object > commandsForProducer = new LinkedBlockingQueue < > ();
    Thread producer = new Thread (new Producer (pool, currentPoolSize, commandsForProducer));
    producer.start ();
    for (int i = 0;
    i < CONSUMERS_COUNT; i ++) {
        Thread consumer = new Thread (new Consumer (pool, currentPoolSize, commandsForProducer));
        consumer.start ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32358084_32358501_13_29
32358084_32365355_10_80
Title: Pool filler service with minimum and maximum threshold setting 
----------------------------------------

public static void main (String...args) throws InterruptedException {
    final LinkedBlockingDeque < Object > linkedBlockingDeque = new LinkedBlockingDeque < > ();
    final ExecutorService executorService = Executors.newFixedThreadPool (4);
    final Lock fillLock = new ReentrantLock ();
    final AtomicBoolean stop = new AtomicBoolean (false);
    for (int i = 0;
    i < 4; i ++) {
        executorService.execute (new Worker (linkedBlockingDeque, fillLock, stop));
    }
    Thread.sleep (TimeUnit.SECONDS.toMillis (30));
    stop.set (true);
    executorService.shutdown ();
    executorService.awaitTermination (30, TimeUnit.SECONDS);
}
----------------------------------------

public static void main (String [] args) {
    try {
        final FilledPool < Integer > pool = new FilledPool < Integer > (100, 1000);
        final CountDownLatch syncStart = new CountDownLatch (3);
        Thread consumer = new Thread () {
            @Override
            public void run () {
                int positiveInt = 0;
                int totalInts = 0;
                try {
                    syncStart.countDown ();
                    syncStart.await ();
                    for (;;) {
                        int i = pool.take ();
                        if (i > 0) {
                            positiveInt ++;
                        }
                        totalInts ++;
                        Thread.yield ();
                    }
                } catch (InterruptedException e) {
                    System.out.println ("Consumer stopped: " + positiveInt + " / " + (totalInts - positiveInt));
                } catch (Exception e) {
                    e.printStackTrace ();
                }
            }}

        ;
        consumer.start ();
        Thread producer = new Thread () {
            @Override
            public void run () {
                try {
                    Random r = new Random ();
                    syncStart.countDown ();
                    syncStart.await ();
                    for (;;) {
                        int fillTotal = 0;
                        while (! pool.isMinFilled ()) {
                            int fill = pool.getFillSize ();
                            for (int i = 0;
                            i < fill; i ++) {
                                pool.offer (r.nextInt ());
                            }
                            fillTotal += fill;
                        }
                        System.out.println ("Filled " + fillTotal);
                        pool.awaitNewFilling ();
                    }
                } catch (InterruptedException e) {
                    System.out.println ("Producer stopped.");
                } catch (Exception e) {
                    e.printStackTrace ();
                }
            }}

        ;
        producer.start ();
        syncStart.countDown ();
        syncStart.await ();
        Thread.sleep (100);
        producer.interrupt ();
        consumer.interrupt ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32358084_32358501_47_63
32358084_32363319_42_64
Title: Pool filler service with minimum and maximum threshold setting 
----------------------------------------

public void run () {
    try {
        while (! stop.get ()) {
            Object o = linkedBlockingDeque.poll (1, TimeUnit.SECONDS);
            if (o != null) {
                handle (o);
            }
            if (linkedBlockingDeque.size () < 10) {
                tryFill ();
            }
        }
    } catch (InterruptedException e) {
        Thread.currentThread ().interrupt ();
    }
}
----------------------------------------

public void run () {
    while (true) {
        if (currentPoolSize.get () < Main.UPPER_BOUND) {
            pool.add (new Object ());
            System.out.println (Thread.currentThread ().getName () + " producer, items in pool:" + currentPoolSize.incrementAndGet ());
            try {
                Thread.sleep (4);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        } else {
            try {
                System.out.println (Thread.currentThread ().getName () + " producer is trying to sleep");
                commandsForProducer.take ();
                System.out.println (Thread.currentThread ().getName () + " producer awakes");
                commandsForProducer.clear ();
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32358084_32358501_47_63
32358084_32363319_80_95
Title: Pool filler service with minimum and maximum threshold setting 
----------------------------------------

public void run () {
    try {
        while (! stop.get ()) {
            Object o = linkedBlockingDeque.poll (1, TimeUnit.SECONDS);
            if (o != null) {
                handle (o);
            }
            if (linkedBlockingDeque.size () < 10) {
                tryFill ();
            }
        }
    } catch (InterruptedException e) {
        Thread.currentThread ().interrupt ();
    }
}
----------------------------------------

public void run () {
    while (true) {
        if (currentPoolSize.get () <= Main.LOWER_BOUND) {
            System.out.println (Thread.currentThread ().getName () + " signaled to producer");
            commandsForProducer.add (new Object ());
        }
        try {
            pool.take ();
            System.out.println (Thread.currentThread ().getName () + " consumer, items in pool:" + currentPoolSize.decrementAndGet ());
            Thread.sleep (50);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32358084_32358501_47_63
32358084_32365355_18_38
Title: Pool filler service with minimum and maximum threshold setting 
----------------------------------------

public void run () {
    try {
        while (! stop.get ()) {
            Object o = linkedBlockingDeque.poll (1, TimeUnit.SECONDS);
            if (o != null) {
                handle (o);
            }
            if (linkedBlockingDeque.size () < 10) {
                tryFill ();
            }
        }
    } catch (InterruptedException e) {
        Thread.currentThread ().interrupt ();
    }
}
----------------------------------------

public void run () {
    int positiveInt = 0;
    int totalInts = 0;
    try {
        syncStart.countDown ();
        syncStart.await ();
        for (;;) {
            int i = pool.take ();
            if (i > 0) {
                positiveInt ++;
            }
            totalInts ++;
            Thread.yield ();
        }
    } catch (InterruptedException e) {
        System.out.println ("Consumer stopped: " + positiveInt + " / " + (totalInts - positiveInt));
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32358084_32358501_47_63
32358084_32365355_43_66
Title: Pool filler service with minimum and maximum threshold setting 
----------------------------------------

public void run () {
    try {
        while (! stop.get ()) {
            Object o = linkedBlockingDeque.poll (1, TimeUnit.SECONDS);
            if (o != null) {
                handle (o);
            }
            if (linkedBlockingDeque.size () < 10) {
                tryFill ();
            }
        }
    } catch (InterruptedException e) {
        Thread.currentThread ().interrupt ();
    }
}
----------------------------------------

public void run () {
    try {
        Random r = new Random ();
        syncStart.countDown ();
        syncStart.await ();
        for (;;) {
            int fillTotal = 0;
            while (! pool.isMinFilled ()) {
                int fill = pool.getFillSize ();
                for (int i = 0;
                i < fill; i ++) {
                    pool.offer (r.nextInt ());
                }
                fillTotal += fill;
            }
            System.out.println ("Filled " + fillTotal);
            pool.awaitNewFilling ();
        }
    } catch (InterruptedException e) {
        System.out.println ("Producer stopped.");
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32358084_32363319_13_25
32358084_32365355_10_80
Title: Pool filler service with minimum and maximum threshold setting 
----------------------------------------

public static void main (String [] args) {
    BlockingQueue < Object > pool = new LinkedBlockingQueue < > ();
    AtomicInteger currentPoolSize = new AtomicInteger (0);
    BlockingQueue < Object > commandsForProducer = new LinkedBlockingQueue < > ();
    Thread producer = new Thread (new Producer (pool, currentPoolSize, commandsForProducer));
    producer.start ();
    for (int i = 0;
    i < CONSUMERS_COUNT; i ++) {
        Thread consumer = new Thread (new Consumer (pool, currentPoolSize, commandsForProducer));
        consumer.start ();
    }
}
----------------------------------------

public static void main (String [] args) {
    try {
        final FilledPool < Integer > pool = new FilledPool < Integer > (100, 1000);
        final CountDownLatch syncStart = new CountDownLatch (3);
        Thread consumer = new Thread () {
            @Override
            public void run () {
                int positiveInt = 0;
                int totalInts = 0;
                try {
                    syncStart.countDown ();
                    syncStart.await ();
                    for (;;) {
                        int i = pool.take ();
                        if (i > 0) {
                            positiveInt ++;
                        }
                        totalInts ++;
                        Thread.yield ();
                    }
                } catch (InterruptedException e) {
                    System.out.println ("Consumer stopped: " + positiveInt + " / " + (totalInts - positiveInt));
                } catch (Exception e) {
                    e.printStackTrace ();
                }
            }}

        ;
        consumer.start ();
        Thread producer = new Thread () {
            @Override
            public void run () {
                try {
                    Random r = new Random ();
                    syncStart.countDown ();
                    syncStart.await ();
                    for (;;) {
                        int fillTotal = 0;
                        while (! pool.isMinFilled ()) {
                            int fill = pool.getFillSize ();
                            for (int i = 0;
                            i < fill; i ++) {
                                pool.offer (r.nextInt ());
                            }
                            fillTotal += fill;
                        }
                        System.out.println ("Filled " + fillTotal);
                        pool.awaitNewFilling ();
                    }
                } catch (InterruptedException e) {
                    System.out.println ("Producer stopped.");
                } catch (Exception e) {
                    e.printStackTrace ();
                }
            }}

        ;
        producer.start ();
        syncStart.countDown ();
        syncStart.await ();
        Thread.sleep (100);
        producer.interrupt ();
        consumer.interrupt ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32358084_32363319_42_64
32358084_32363319_80_95
Title: Pool filler service with minimum and maximum threshold setting 
----------------------------------------

public void run () {
    while (true) {
        if (currentPoolSize.get () < Main.UPPER_BOUND) {
            pool.add (new Object ());
            System.out.println (Thread.currentThread ().getName () + " producer, items in pool:" + currentPoolSize.incrementAndGet ());
            try {
                Thread.sleep (4);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        } else {
            try {
                System.out.println (Thread.currentThread ().getName () + " producer is trying to sleep");
                commandsForProducer.take ();
                System.out.println (Thread.currentThread ().getName () + " producer awakes");
                commandsForProducer.clear ();
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    while (true) {
        if (currentPoolSize.get () <= Main.LOWER_BOUND) {
            System.out.println (Thread.currentThread ().getName () + " signaled to producer");
            commandsForProducer.add (new Object ());
        }
        try {
            pool.take ();
            System.out.println (Thread.currentThread ().getName () + " consumer, items in pool:" + currentPoolSize.decrementAndGet ());
            Thread.sleep (50);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32358084_32363319_42_64
32358084_32365355_18_38
Title: Pool filler service with minimum and maximum threshold setting 
----------------------------------------

public void run () {
    while (true) {
        if (currentPoolSize.get () < Main.UPPER_BOUND) {
            pool.add (new Object ());
            System.out.println (Thread.currentThread ().getName () + " producer, items in pool:" + currentPoolSize.incrementAndGet ());
            try {
                Thread.sleep (4);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        } else {
            try {
                System.out.println (Thread.currentThread ().getName () + " producer is trying to sleep");
                commandsForProducer.take ();
                System.out.println (Thread.currentThread ().getName () + " producer awakes");
                commandsForProducer.clear ();
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    int positiveInt = 0;
    int totalInts = 0;
    try {
        syncStart.countDown ();
        syncStart.await ();
        for (;;) {
            int i = pool.take ();
            if (i > 0) {
                positiveInt ++;
            }
            totalInts ++;
            Thread.yield ();
        }
    } catch (InterruptedException e) {
        System.out.println ("Consumer stopped: " + positiveInt + " / " + (totalInts - positiveInt));
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32358084_32363319_42_64
32358084_32365355_43_66
Title: Pool filler service with minimum and maximum threshold setting 
----------------------------------------

public void run () {
    while (true) {
        if (currentPoolSize.get () < Main.UPPER_BOUND) {
            pool.add (new Object ());
            System.out.println (Thread.currentThread ().getName () + " producer, items in pool:" + currentPoolSize.incrementAndGet ());
            try {
                Thread.sleep (4);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        } else {
            try {
                System.out.println (Thread.currentThread ().getName () + " producer is trying to sleep");
                commandsForProducer.take ();
                System.out.println (Thread.currentThread ().getName () + " producer awakes");
                commandsForProducer.clear ();
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    try {
        Random r = new Random ();
        syncStart.countDown ();
        syncStart.await ();
        for (;;) {
            int fillTotal = 0;
            while (! pool.isMinFilled ()) {
                int fill = pool.getFillSize ();
                for (int i = 0;
                i < fill; i ++) {
                    pool.offer (r.nextInt ());
                }
                fillTotal += fill;
            }
            System.out.println ("Filled " + fillTotal);
            pool.awaitNewFilling ();
        }
    } catch (InterruptedException e) {
        System.out.println ("Producer stopped.");
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32358084_32363319_80_95
32358084_32365355_18_38
Title: Pool filler service with minimum and maximum threshold setting 
----------------------------------------

public void run () {
    while (true) {
        if (currentPoolSize.get () <= Main.LOWER_BOUND) {
            System.out.println (Thread.currentThread ().getName () + " signaled to producer");
            commandsForProducer.add (new Object ());
        }
        try {
            pool.take ();
            System.out.println (Thread.currentThread ().getName () + " consumer, items in pool:" + currentPoolSize.decrementAndGet ());
            Thread.sleep (50);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------

public void run () {
    int positiveInt = 0;
    int totalInts = 0;
    try {
        syncStart.countDown ();
        syncStart.await ();
        for (;;) {
            int i = pool.take ();
            if (i > 0) {
                positiveInt ++;
            }
            totalInts ++;
            Thread.yield ();
        }
    } catch (InterruptedException e) {
        System.out.println ("Consumer stopped: " + positiveInt + " / " + (totalInts - positiveInt));
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32358084_32363319_80_95
32358084_32365355_43_66
Title: Pool filler service with minimum and maximum threshold setting 
----------------------------------------

public void run () {
    while (true) {
        if (currentPoolSize.get () <= Main.LOWER_BOUND) {
            System.out.println (Thread.currentThread ().getName () + " signaled to producer");
            commandsForProducer.add (new Object ());
        }
        try {
            pool.take ();
            System.out.println (Thread.currentThread ().getName () + " consumer, items in pool:" + currentPoolSize.decrementAndGet ());
            Thread.sleep (50);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------

public void run () {
    try {
        Random r = new Random ();
        syncStart.countDown ();
        syncStart.await ();
        for (;;) {
            int fillTotal = 0;
            while (! pool.isMinFilled ()) {
                int fill = pool.getFillSize ();
                for (int i = 0;
                i < fill; i ++) {
                    pool.offer (r.nextInt ());
                }
                fillTotal += fill;
            }
            System.out.println ("Filled " + fillTotal);
            pool.awaitNewFilling ();
        }
    } catch (InterruptedException e) {
        System.out.println ("Producer stopped.");
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32358084_32365355_18_38
32358084_32365355_43_66
Title: Pool filler service with minimum and maximum threshold setting 
----------------------------------------

public void run () {
    int positiveInt = 0;
    int totalInts = 0;
    try {
        syncStart.countDown ();
        syncStart.await ();
        for (;;) {
            int i = pool.take ();
            if (i > 0) {
                positiveInt ++;
            }
            totalInts ++;
            Thread.yield ();
        }
    } catch (InterruptedException e) {
        System.out.println ("Consumer stopped: " + positiveInt + " / " + (totalInts - positiveInt));
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public void run () {
    try {
        Random r = new Random ();
        syncStart.countDown ();
        syncStart.await ();
        for (;;) {
            int fillTotal = 0;
            while (! pool.isMinFilled ()) {
                int fill = pool.getFillSize ();
                for (int i = 0;
                i < fill; i ++) {
                    pool.offer (r.nextInt ());
                }
                fillTotal += fill;
            }
            System.out.println ("Filled " + fillTotal);
            pool.awaitNewFilling ();
        }
    } catch (InterruptedException e) {
        System.out.println ("Producer stopped.");
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32363177_32363953_30_39
32363177_32374681_6_19
Title: Dynamically call correct correct setter method with Reflection 
----------------------------------------

public void setInterface (Interface ifc) {
    for (MyEnum e : MyEnum.values ()) {
        if (e.getImpl ().isAssignableFrom (ifc.getClass ())) {
            this.myEnum = e;
            this.ifc = ifc;
            return;
        }
    }
    throw new IllegalArgumentException ("Interface class is unknown: " + ifc.getClass ().getName ());
}
----------------------------------------

public void setInterface (Interface iface) throws Exception {
    if (iface == null) {
        throw new IllegalArgumentException ("iface must not be null");
    }
    Class < ? extends Interface > ifaceClass = iface.getClass ();
    if (! interfaceSetters.containsKey (ifaceClass)) {
        throw new IllegalArgumentException (String.format ("iface type %s is not supported", ifaceClass.getName ()));
    }
    Method ifaceSetter = interfaceSetters.get (ifaceClass);
    ifaceSetter.invoke (myClass, iface);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32363992_32364179_1_26
32363992_32364259_5_28
Title: Get array element from loop 
----------------------------------------

public static void main (String [] args) {
    Scanner scr = new Scanner (System.in);
    String [] days = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
    int i = 0;
    boolean validEntry;
    while (true) {
        validEntry = false;
        System.out.println ("On what day should the cleaning be scheduled ? ");
        String schedule = scr.nextLine ();
        for (i = 0; i < days.length; i ++) {
            if (days [i].equals (schedule)) {
                System.out.println ("Cleaning scheduled for " + schedule);
                validEntry = true;
            }
        }
        if (! validEntry) {
            System.out.println ("Invalid, You have to choose one of these days: \n" + Arrays.toString (days));
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner scr = new Scanner (System.in);
    String [] days = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
    int i = 0;
    while (true) {
        System.out.println ("On what day should the cleaning be scheduled ? ");
        String schedule = scr.nextLine ();
        for (i = 0; i < days.length; i ++) {
            if (days [i].equals (schedule)) {
                System.out.println ("Cleaning scheduled for " + schedule);
                break;
            }
        }
        if (i == days.length) {
            System.out.println ("Invalid, You have to choose one of these days: \n " + Arrays.asList (days));
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32372279_32372720_1_24
32372279_32374382_9_30
Title: Generating all days between 2 given dates in Java 
----------------------------------------

public static void main (String [] args) throws Exception {
    SimpleDateFormat myFormat = new SimpleDateFormat ("dd MM yyyy");
    String inputString1 = "23 01 1997";
    String inputString2 = "27 04 1997";
    ArrayList < Date > dates = new ArrayList < Date > ();
    try {
        Date date1 = myFormat.parse (inputString1);
        Calendar c1 = DateToCalendar (date1);
        Date date2 = myFormat.parse (inputString2);
        Calendar c2 = DateToCalendar (date2);
        while (! areEqualDate (c1, c2)) {
            dates.add (c1.getTime ());
            System.out.println (c1.getTime ());
            c1.add (Calendar.DAY_OF_YEAR, 1);
        }
    } catch (ParseException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) {
    SimpleDateFormat myFormat = new SimpleDateFormat ("yyyy-MM-dd");
    SimpleDateFormat formatter = new SimpleDateFormat ("yyyy-MM-dd");
    String date1 = "2014-01-01";
    String date2 = "2014-05-01";
    try {
        Date d1 = myFormat.parse (date1);
        Date d2 = myFormat.parse (date2);
        List < Date > allDates = new ArrayList < Date > ();
        List < String > allDatesString = new ArrayList < String > ();
        while (d1.before (d2)) {
            d1 = addDays (d1, 1);
            allDates.add (d1);
            allDatesString.add (formatter.format (d1));
        }
        System.out.println (allDates);
        System.out.println (allDatesString);
    } catch (ParseException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32384278_48759584_18_26
32384278_48759584_5_13
Title: How to combine @Rule and @ClassRule in JUnit 4.12 
----------------------------------------

public void evaluate () throws Throwable {
    beforeClass ();
    try {
        base.evaluate ();
        verifyClass ();
    } finally {
        afterClass ();
    }
}
----------------------------------------

public void evaluate () throws Throwable {
    before ();
    try {
        base.evaluate ();
        verify ();
    } finally {
        after ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32387316_32388953_16_24
32387316_32401890_1_19
Title: How to start back at beginning of arraylist in a while loop? 
----------------------------------------

public static void main (String [] args) {
    LinkedList < Integer > people = new LinkedList < > ();
    for (int i = 0;
    i <= 100; i ++) {
        people.add (i);
    }
    int survivor = kill (people);
    System.out.println ("Last survivor: " + survivor);
}
----------------------------------------

public static void main (String [] args) {
    Person startingPerson = new Person (1);
    Person currentPerson = startingPerson;
    for (int i = 2;
    i <= 100; i ++) {
        currentPerson.setNext (new Person (i));
        currentPerson = currentPerson.getNext ();
    }
    currentPerson.setNext (startingPerson);
    currentPerson = startingPerson;
    while (currentPerson != currentPerson.getNext ()) {
        currentPerson.killNext ();
        currentPerson = currentPerson.getNext ();
    }
    System.out.println ("Surviving person: " + currentPerson.getId ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32389337_32389497_1_33
32389337_32389544_12_51
Title: "In java how can I handle exceptions regarding Windows command line arguments?" 
----------------------------------------

public static void main (String [] args) {
    String arg;
    Scanner user_input = new Scanner (System.in);
    int numTries = 0, value = 0;
    try {
        numTries = Integer.parseInt (args [0]);
    } catch (ArrayIndexOutOfBoundsException e) {
        arg = "";
    } catch (NumberFormatException e2) {
        arg = "";
    }
    for (int i = numTries;
    i > 0; -- i) {
        System.out.print ("Please type in a positive whole number: ");
        arg = user_input.next ();
        try {
            value = Integer.parseInt (arg);
        } catch (NumberFormatException e2) {
            System.out.println ("That's a letter! ");
            continue;
        }
        if (value <= 0) {
            System.out.println ("That's a negative. ");
        }
        break;
    }
    System.out.println ("Input is " + value);
}
----------------------------------------

public static void main (String [] args) throws NegativeNumberException {
    try {
        if (Integer.parseInt (args [0]) < 0) {
            throw new NegativeNumberException ();
        } else {
            int num = Integer.parseInt (args [0]);
            System.out.println ("Your number is: " + num);
        }
    } catch (NumberFormatException ex) {
        System.out.println ("That's not even a number.");
    } catch (NegativeNumberException ex) {
        ex.getMessage ();
    }
    while (num == 0) {
        try {
            System.out.println ("Enter a positive number:");
            Scanner input = new Scanner (System.in);
            int num1 = input.nextInt ();
            if (num1 < 0) {
                throw new NegativeNumberException ();
            }
            num = num1;
            break;
        } catch (Exception ex) {
            System.out.println ("Positive number only, try again...");
        }
    }
    System.out.println ("Your number is:" + num);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32391618_32392656_120_128
32391618_32392656_98_106
Title: why does mediaRecorder fail to prepare when trying to record voice 
----------------------------------------

public void onClick (View v) {
    onPlay (mStartPlaying);
    if (mStartPlaying) {
        setText ("Stop playing");
    } else {
        setText ("Start playing");
    }
    mStartPlaying = ! mStartPlaying;
}
----------------------------------------

public void onClick (View v) {
    onRecord (mStartRecording);
    if (mStartRecording) {
        setText ("Stop recording");
    } else {
        setText ("Start recording");
    }
    mStartRecording = ! mStartRecording;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32398104_35349655_1_15
32398104_35349713_1_15
Title: How to set a custom font to the title in toolbar android 
----------------------------------------

public static void applyFontForToolbarTitle (Activity context) {
    Toolbar toolbar = (Toolbar) context.findViewById (R.id.app_bar);
    for (int i = 0;
    i < toolbar.getChildCount (); i ++) {
        View view = toolbar.getChildAt (i);
        if (view instanceof TextView) {
            TextView tv = (TextView) view;
            Typeface titleFont = Typeface.createFromAsset (context.getAssets (), "fonts/customFont");
            if (tv.getText ().equals (context.getTitle ())) {
                tv.setTypeface (titleFont);
                break;
            }
        }
    }
}
----------------------------------------

public static void applyFontForToolbarTitle (Activity context) {
    Toolbar toolbar = (Toolbar) context.findViewById (R.id.app_bar);
    for (int i = 0;
    i < toolbar.getChildCount (); i ++) {
        View view = toolbar.getChildAt (i);
        if (view instanceof TextView) {
            TextView tv = (TextView) view;
            Typeface titleFont = Typeface.createFromAsset (context.getAssets (), "fonts/customFont");
            if (tv.getText ().equals (toolbar.getTitle ())) {
                tv.setTypeface (titleFont);
                break;
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32398534_32398861_116_132
32398534_32398865_1_18
Title: 2D Array Operations 
----------------------------------------

public static int getHighestInRow (int [] [] x, int rowCount, int colCount) {
    int highestInRow = x [0] [0];
    for (int rowIndex = 0;
    rowIndex < rowCount; rowIndex ++) {
        for (int colIndex = 0;
        colIndex < colCount; colIndex ++) {
            if (x [rowIndex] [colIndex] > highestInRow) highestInRow = x [rowIndex] [colIndex];

        }
        System.out.println (highestInRow + " is the highest number in row " + (rowIndex + 1) + ".");
        highestInRow = 0;
    }
    return highestInRow;
}
----------------------------------------

public static int getHighestInRow (int [] [] x, int rowCount, int colCount) {
    int highestInRow = 0;
    for (int rowIndex = 0;
    rowIndex < rowCount; rowIndex ++) {
        highestInRow = x [rowIndex] [0];
        for (int colIndex = 0;
        colIndex < colCount; colIndex ++) {
            if (x [rowIndex] [colIndex] > highestInRow) highestInRow = x [rowIndex] [colIndex];

        }
        System.out.println (highestInRow + " is the highest number in row " + (rowIndex + 1) + ".");
        highestInRow = 0;
    }
    return highestInRow;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32398534_32398861_143_161
32398534_32398865_29_47
Title: 2D Array Operations 
----------------------------------------

public static int getLowestInRow (int [] [] x, int rowCount, int colCount) {
    int lowestInRow = x [0] [0];
    for (int rowIndex = 0;
    rowIndex < rowCount; rowIndex ++) {
        lowestInRow = x [rowIndex] [0];
        for (int colIndex = 0;
        colIndex < colCount; colIndex ++) {
            if (x [rowIndex] [colIndex] < lowestInRow) lowestInRow = x [rowIndex] [colIndex];

        }
        System.out.println (lowestInRow + " is the lowest number in row " + (rowIndex + 1) + ".");
    }
    return lowestInRow;
}
----------------------------------------

public static int getLowestInRow (int [] [] x, int rowCount, int colCount) {
    int lowestInRow = 0;
    for (int rowIndex = 0;
    rowIndex < rowCount; rowIndex ++) {
        lowestInRow = x [rowIndex] [0];
        for (int colIndex = 0;
        colIndex < colCount; colIndex ++) {
            if (x [rowIndex] [colIndex] < lowestInRow) lowestInRow = x [rowIndex] [colIndex];

        }
        System.out.println (lowestInRow + " is the lowest number in row " + (rowIndex + 1) + ".");
        lowestInRow = 0;
    }
    return lowestInRow;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32409839_32421895_10_42
32409839_32422024_11_40
Title: java code for showing xlsx file content in grid 
----------------------------------------

public static void main (String [] args) throws Exception {
    XSSFWorkbook workbook = new XSSFWorkbook ();
    XSSFSheet spreadsheet = workbook.createSheet ("ASCII Values from A to Z");
    int j = 0;
    int ascii = 65;
    for (int i = 0;
    i < 26; i ++) {
        XSSFRow row = spreadsheet.createRow (i);
        Cell cell = row.createCell (j);
        j ++;
        cell.setCellValue ("" + ascii);
        cell = row.createCell (j);
        cell.setCellValue ("" + (char) ascii);
        ascii ++;
        j = 0;
    }
    FileOutputStream out = new FileOutputStream (new File ("C:\\Users\\TANAY\\Desktop\\Writesheet.xlsx"));
    workbook.write (out);
    out.close ();
    System.out.println ("Writesheet.xlsx written successfully");
    workbook.close ();
}
----------------------------------------

public static void main (String [] args) throws Exception {
    FileInputStream fis = new FileInputStream (new File ("C:\\Users\\TANAY\\Desktop\\Writesheet.xlsx"));
    XSSFWorkbook workbook = new XSSFWorkbook (fis);
    XSSFSheet spreadsheet = workbook.getSheetAt (0);
    int rowcount = spreadsheet.getLastRowNum ();
    int j = 0;
    for (int i = 0;
    i <= rowcount; i ++) {
        row = spreadsheet.getRow (i);
        Cell cel = row.getCell (j);
        System.out.print (cel.getStringCellValue ());
        j ++;
        cel = row.getCell (j);
        System.out.print ("    " + cel.getStringCellValue ());
        j = 0;
        System.out.println ();
    }
    fis.close ();
    workbook.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32411794_32412117_1_24
32411794_32412162_1_13
Title: i want to send Listview Data to Another Activity in Android using json 
----------------------------------------

@Override
public void onItemClick (AdapterView < ? > arg0, View arg1, int position, long id) {
    Actors myActor = actorsList.get (position);
    JSONObject myActorJSON = new JSONObject ();
    myActorJSON.put ("name", myActor.getName ());
    myActorJSON.put ("description", myActor.getDescription ());
    myActorJSON.put ("dob", myActor.getDOB ());
    myActorJSON.put ("country", myActor.getCountry ());
    myActorJSON.put ("height", myActor.getHeight ());
    myActorJSON.put ("spouse", myActor.getSpouse ());
    myActorJSON.put ("children", myActor.getChildren ());
    myActorJSON.put ("image", myActor.getImage ());
    Intent i = new Intent (this, NewActivity.class);
    i.putExtra ("ACTOR_OBJECT", myActor);
    i.putExtra ("ACTOR_JSON_OBJECT", myActorJSON.toString ());
    startActivity (i);
}
----------------------------------------

public void onItemClick (AdapterView < ? > arg0, View arg1, int position, long id) {
    Toast.makeText (getApplicationContext (), actorsList.get (position).getName (), Toast.LENGTH_LONG).show ();
    Actor selectedActor = actorsList.get (position);
    JSONObject obj = new JsonObject ();
    obj.put ("name", selectedActor.getName ());
    Intent i = new Intent (MainActirity.this, otherActivity.class);
    i.putExtra ("Actor", obj.toString ());
    startActivity (i);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32416329_32416359_1_11
32416329_32416592_21_32
Title: Printing 2D Arraylist 
----------------------------------------

public String toString () {
    String result = "";
    for (int i = 0;
    i < myBoard.size (); i ++) {
        for (int j = 0;
        j < myBoard.get (i).size (); j ++) {
            result += myBoard.get (i).get (j);
        }
        result += "\n";
    }
    return result;
}
----------------------------------------

public String toString () {
    String result = "";
    for (int i = 0;
    i < myBoard.size (); i ++) {
        for (int j = 0;
        j < myBoard.get (i).size (); j ++) {
            result += myBoard.get (i).get (j);
        }
        result += "\n";
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32416329_32416364_1_10
32416329_32416592_21_32
Title: Printing 2D Arraylist 
----------------------------------------

public String toString () {
    String result = "";
    for (int i = 0;
    i < myBoard.size (); i ++) {
        for (int j = 0;
        j < myBoard.get (i).size (); j ++) {
            result += myBoard.get (i).get (j);
        }
        result += System.lineSeparator ();
    }
    return result;
}
----------------------------------------

public String toString () {
    String result = "";
    for (int i = 0;
    i < myBoard.size (); i ++) {
        for (int j = 0;
        j < myBoard.get (i).size (); j ++) {
            result += myBoard.get (i).get (j);
        }
        result += "\n";
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32416556_32416566_7_22
32416556_32447006_32_60
Title: How to resize a JFrame relative to maximized size 
----------------------------------------

public void run () {
    final JFrame frame = new JFrame ();
    frame.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
    frame.setExtendedState (JFrame.MAXIMIZED_BOTH);
    displaySizes (frame, "Before");
    frame.setVisible (true);
    SwingUtilities.invokeLater (new Runnable () {
        public void run () {
            displaySizes (frame, "After");
        }}

    );
}
----------------------------------------

public void run () {
    final DrawingPanel panel = new DrawingPanel ();
    frame = new JFrame ("Frame Resizing Testing");
    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    frame.addWindowStateListener (new WindowStateListener () {
        @Override
        public void windowStateChanged (WindowEvent event) {
            Dimension d = frame.getSize ();
            d.width = d.width - frameSize.width + panelSize.width;
            d.height = d.height - frameSize.height + panelSize.height;
            panel.setPreferredSize (d);
            panel.invalidate ();
            displaySize (panel);
        }}

    );
    frame.add (panel);
    frame.pack ();
    panelSize = panel.getSize ();
    frameSize = frame.getSize ();
    frame.setVisible (true);
    new Thread (new ResizingRunnable ()).start ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32416556_32416566_7_22
32416556_32447006_89_98
Title: How to resize a JFrame relative to maximized size 
----------------------------------------

public void run () {
    final JFrame frame = new JFrame ();
    frame.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
    frame.setExtendedState (JFrame.MAXIMIZED_BOTH);
    displaySizes (frame, "Before");
    frame.setVisible (true);
    SwingUtilities.invokeLater (new Runnable () {
        public void run () {
            displaySizes (frame, "After");
        }}

    );
}
----------------------------------------

public void run () {
    set_size (false);
    set_size (true);
    set_size (false);
    set_size (true);
    set_size (false);
    set_size (true);
    set_size (true);
    System.exit (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32416556_32447006_32_60
32416556_32447006_89_98
Title: How to resize a JFrame relative to maximized size 
----------------------------------------

public void run () {
    final DrawingPanel panel = new DrawingPanel ();
    frame = new JFrame ("Frame Resizing Testing");
    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    frame.addWindowStateListener (new WindowStateListener () {
        @Override
        public void windowStateChanged (WindowEvent event) {
            Dimension d = frame.getSize ();
            d.width = d.width - frameSize.width + panelSize.width;
            d.height = d.height - frameSize.height + panelSize.height;
            panel.setPreferredSize (d);
            panel.invalidate ();
            displaySize (panel);
        }}

    );
    frame.add (panel);
    frame.pack ();
    panelSize = panel.getSize ();
    frameSize = frame.getSize ();
    frame.setVisible (true);
    new Thread (new ResizingRunnable ()).start ();
}
----------------------------------------

public void run () {
    set_size (false);
    set_size (true);
    set_size (false);
    set_size (true);
    set_size (false);
    set_size (true);
    set_size (true);
    System.exit (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32420860_32420924_5_34
32420860_32421155_4_36
Title: How can i get the output on how many times the program has looped? 
----------------------------------------

public static void main (String args []) throws IOException {
    int loopCounter = 0;
    BufferedReader cin = new BufferedReader (new InputStreamReader (System.in));
    String temp, name;
    int number, largest, smallest;
    System.out.print ("Enter Your Name: ");
    name = cin.readLine ();
    int num [] = new int [4];
    System.out.println (name + ", Please enter 4 numbers");
    for (int i = 0;
    i < 4; i ++) {
        System.out.print ("Number " + (i + 1) + ":");
        temp = cin.readLine ();
        num [i] = Integer.parseInt (temp);
        loopCounter ++;
    }
    largest = num [0];
    smallest = num [0];
    for (int i = 0;
    i < 4; i ++) {
        if (num [i] > largest) {
            largest = num [i];
        } else if (num [i] < smallest) {
            smallest = num [i];
        }

        loopCounter ++;
    }
    System.out.println ("Smallest = " + smallest);
    System.out.println ("Largest = " + largest);
    System.out.println ("Looped " + loopCounter + " times.");
}
----------------------------------------

public static void main (String args []) throws IOException {
    BufferedReader cin = new BufferedReader (new InputStreamReader (System.in));
    String temp, name;
    int number, largest, smallest;
    System.out.print ("Enter Your Name: ");
    name = cin.readLine ();
    int num [] = new int [4];
    System.out.println (name + ", Please enter 4 numbers");
    for (int i = 0;
    i < 4; i ++) {
        System.out.print ("Number " + (i + 1) + ":");
        temp = cin.readLine ();
        num [i] = Integer.parseInt (temp);
    }
    largest = num [0];
    smallest = num [0];
    int i;
    for (i = 0; i < 4; i ++) {
        if (num [i] > largest) {
            largest = num [i];
        } else if (num [i] < smallest) {
            smallest = num [i];
        }

    }
    System.out.println ("Smallest = " + smallest);
    System.out.println ("Largest = " + largest);
    System.out.println ("The loop has executed " + i + " times");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32420860_32420924_5_34
32420860_32423496_4_39
Title: How can i get the output on how many times the program has looped? 
----------------------------------------

public static void main (String args []) throws IOException {
    int loopCounter = 0;
    BufferedReader cin = new BufferedReader (new InputStreamReader (System.in));
    String temp, name;
    int number, largest, smallest;
    System.out.print ("Enter Your Name: ");
    name = cin.readLine ();
    int num [] = new int [4];
    System.out.println (name + ", Please enter 4 numbers");
    for (int i = 0;
    i < 4; i ++) {
        System.out.print ("Number " + (i + 1) + ":");
        temp = cin.readLine ();
        num [i] = Integer.parseInt (temp);
        loopCounter ++;
    }
    largest = num [0];
    smallest = num [0];
    for (int i = 0;
    i < 4; i ++) {
        if (num [i] > largest) {
            largest = num [i];
        } else if (num [i] < smallest) {
            smallest = num [i];
        }

        loopCounter ++;
    }
    System.out.println ("Smallest = " + smallest);
    System.out.println ("Largest = " + largest);
    System.out.println ("Looped " + loopCounter + " times.");
}
----------------------------------------

public static void main (String args []) throws IOException {
    BufferedReader cin = new BufferedReader (new InputStreamReader (System.in));
    String temp, name;
    int largest, smallest, time = 0, i;
    do {
        System.out.print ("Enter Your Name: ");
        name = cin.readLine ();
        int num [] = new int [4];
        System.out.println (name + ", Please enter 4 numbers\n");
        for (i = 0; i < 4; i ++) {
            System.out.print ("Number " + (i + 1) + ":");
            temp = cin.readLine ();
            num [i] = Integer.parseInt (temp);
        }
        largest = num [0];
        smallest = num [0];
        for (i = 0; i < 4; i ++) {
            if (num [i] > largest) {
                largest = num [i];
            } else if (num [i] < smallest) {
                smallest = num [i];
            }

        }
        System.out.println ("Smallest = " + smallest);
        System.out.println ("Largest = " + largest + "\n");
        time ++;
    } while (smallest <= 5);
    System.out.println ("The program has been repeated for " + (time) + " times");
    System.out.print ("Thanks You!!");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32420860_32420929_7_41
32420860_32421155_4_36
Title: How can i get the output on how many times the program has looped? 
----------------------------------------

public static void main (String args []) throws IOException {
    BufferedReader cin = new BufferedReader (new InputStreamReader (System.in));
    String temp, name;
    int largest, smallest;
    System.out.print ("Enter Your Name: ");
    name = cin.readLine ();
    int num [] = new int [4];
    System.out.println (name + ", Please enter 4 numbers");
    int loopCount = 0;
    for (int i = 0;
    i < 4; i ++) {
        System.out.print ("Number " + (i + 1) + ":");
        temp = cin.readLine ();
        num [i] = Integer.parseInt (temp);
        loopCount ++;
    }
    System.out.println ("Loop Counted :: " + loopCount);
    largest = num [0];
    smallest = num [0];
    for (int i = 0;
    i < 4; i ++) {
        if (num [i] > largest) {
            largest = num [i];
        } else if (num [i] < smallest) {
            smallest = num [i];
        }

    }
    System.out.println ("Smallest = " + smallest);
    System.out.println ("Largest = " + largest);
}
----------------------------------------

public static void main (String args []) throws IOException {
    BufferedReader cin = new BufferedReader (new InputStreamReader (System.in));
    String temp, name;
    int number, largest, smallest;
    System.out.print ("Enter Your Name: ");
    name = cin.readLine ();
    int num [] = new int [4];
    System.out.println (name + ", Please enter 4 numbers");
    for (int i = 0;
    i < 4; i ++) {
        System.out.print ("Number " + (i + 1) + ":");
        temp = cin.readLine ();
        num [i] = Integer.parseInt (temp);
    }
    largest = num [0];
    smallest = num [0];
    int i;
    for (i = 0; i < 4; i ++) {
        if (num [i] > largest) {
            largest = num [i];
        } else if (num [i] < smallest) {
            smallest = num [i];
        }

    }
    System.out.println ("Smallest = " + smallest);
    System.out.println ("Largest = " + largest);
    System.out.println ("The loop has executed " + i + " times");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32420860_32420929_7_41
32420860_32423496_4_39
Title: How can i get the output on how many times the program has looped? 
----------------------------------------

public static void main (String args []) throws IOException {
    BufferedReader cin = new BufferedReader (new InputStreamReader (System.in));
    String temp, name;
    int largest, smallest;
    System.out.print ("Enter Your Name: ");
    name = cin.readLine ();
    int num [] = new int [4];
    System.out.println (name + ", Please enter 4 numbers");
    int loopCount = 0;
    for (int i = 0;
    i < 4; i ++) {
        System.out.print ("Number " + (i + 1) + ":");
        temp = cin.readLine ();
        num [i] = Integer.parseInt (temp);
        loopCount ++;
    }
    System.out.println ("Loop Counted :: " + loopCount);
    largest = num [0];
    smallest = num [0];
    for (int i = 0;
    i < 4; i ++) {
        if (num [i] > largest) {
            largest = num [i];
        } else if (num [i] < smallest) {
            smallest = num [i];
        }

    }
    System.out.println ("Smallest = " + smallest);
    System.out.println ("Largest = " + largest);
}
----------------------------------------

public static void main (String args []) throws IOException {
    BufferedReader cin = new BufferedReader (new InputStreamReader (System.in));
    String temp, name;
    int largest, smallest, time = 0, i;
    do {
        System.out.print ("Enter Your Name: ");
        name = cin.readLine ();
        int num [] = new int [4];
        System.out.println (name + ", Please enter 4 numbers\n");
        for (i = 0; i < 4; i ++) {
            System.out.print ("Number " + (i + 1) + ":");
            temp = cin.readLine ();
            num [i] = Integer.parseInt (temp);
        }
        largest = num [0];
        smallest = num [0];
        for (i = 0; i < 4; i ++) {
            if (num [i] > largest) {
                largest = num [i];
            } else if (num [i] < smallest) {
                smallest = num [i];
            }

        }
        System.out.println ("Smallest = " + smallest);
        System.out.println ("Largest = " + largest + "\n");
        time ++;
    } while (smallest <= 5);
    System.out.println ("The program has been repeated for " + (time) + " times");
    System.out.print ("Thanks You!!");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32420860_32421155_4_36
32420860_32423496_4_39
Title: How can i get the output on how many times the program has looped? 
----------------------------------------

public static void main (String args []) throws IOException {
    BufferedReader cin = new BufferedReader (new InputStreamReader (System.in));
    String temp, name;
    int number, largest, smallest;
    System.out.print ("Enter Your Name: ");
    name = cin.readLine ();
    int num [] = new int [4];
    System.out.println (name + ", Please enter 4 numbers");
    for (int i = 0;
    i < 4; i ++) {
        System.out.print ("Number " + (i + 1) + ":");
        temp = cin.readLine ();
        num [i] = Integer.parseInt (temp);
    }
    largest = num [0];
    smallest = num [0];
    int i;
    for (i = 0; i < 4; i ++) {
        if (num [i] > largest) {
            largest = num [i];
        } else if (num [i] < smallest) {
            smallest = num [i];
        }

    }
    System.out.println ("Smallest = " + smallest);
    System.out.println ("Largest = " + largest);
    System.out.println ("The loop has executed " + i + " times");
}
----------------------------------------

public static void main (String args []) throws IOException {
    BufferedReader cin = new BufferedReader (new InputStreamReader (System.in));
    String temp, name;
    int largest, smallest, time = 0, i;
    do {
        System.out.print ("Enter Your Name: ");
        name = cin.readLine ();
        int num [] = new int [4];
        System.out.println (name + ", Please enter 4 numbers\n");
        for (i = 0; i < 4; i ++) {
            System.out.print ("Number " + (i + 1) + ":");
            temp = cin.readLine ();
            num [i] = Integer.parseInt (temp);
        }
        largest = num [0];
        smallest = num [0];
        for (i = 0; i < 4; i ++) {
            if (num [i] > largest) {
                largest = num [i];
            } else if (num [i] < smallest) {
                smallest = num [i];
            }

        }
        System.out.println ("Smallest = " + smallest);
        System.out.println ("Largest = " + largest + "\n");
        time ++;
    } while (smallest <= 5);
    System.out.println ("The program has been repeated for " + (time) + " times");
    System.out.print ("Thanks You!!");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32431446_32431595_1_16
32431446_32431640_3_23
Title: Reverse all three digit elements of an int array 
----------------------------------------

public static void main (String [] args) {
    int [] codedMessage = {123, 456, 789};
    int temp = 0;
    for (int i = 0;
    i < codedMessage.length; i ++) {
        temp = 0;
        if (codedMessage [i] / 100 >= 1) {
            while (codedMessage [i] > 0) {
                temp = temp * 10 + codedMessage [i] % 10;
                codedMessage [i] = codedMessage [i] / 10;
            }
            codedMessage [i] = temp;
            System.out.println (codedMessage [i]);
        }
    }
}
----------------------------------------

public static void main (String args []) {
    int codedMessage [] = {334, 384, 105, 222, 61, 2, 175, 228, 114, 235, 241, 213, 206, 3, 321, 152, 214, 137, 224};
    String num;
    int message [] = new int [codedMessage.length];
    for (int i = 0;
    i < codedMessage.length; i ++) {
        num = codedMessage [i] + "";
        if (num.length () >= 3) {
            message [i] = reverse (num);
            System.out.println ("Reverse=" + message [i]);
        } else {
            message [i] = codedMessage [i];
            System.out.println (message [i]);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32437202_34565182_16_28
32437202_38111048_21_33
Title: ImprovedNamingStrategy no longer working in Hibernate 5 
----------------------------------------

protected static String addUnderscores (String name) {
    final StringBuilder buf = new StringBuilder (name.replace ('.', '_'));
    for (int i = 1;
    i < buf.length () - 1; i ++) {
        if (Character.isLowerCase (buf.charAt (i - 1)) && Character.isUpperCase (buf.charAt (i)) && Character.isLowerCase (buf.charAt (i + 1))) {
            buf.insert (i ++, '_');
        }
    }
    return buf.toString ().toLowerCase (Locale.ROOT);
}
----------------------------------------

protected static String addUnderscores (String name) {
    final StringBuilder buf = new StringBuilder (name.replace ('.', '_'));
    for (int i = 1;
    i < buf.length () - 1; i ++) {
        if (Character.isLowerCase (buf.charAt (i - 1)) && Character.isUpperCase (buf.charAt (i)) && Character.isLowerCase (buf.charAt (i + 1))) {
            buf.insert (i ++, '_');
        }
    }
    return buf.toString ().toLowerCase (Locale.ROOT);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32437202_34565182_16_28
32437202_52126648_8_18
Title: ImprovedNamingStrategy no longer working in Hibernate 5 
----------------------------------------

protected static String addUnderscores (String name) {
    final StringBuilder buf = new StringBuilder (name.replace ('.', '_'));
    for (int i = 1;
    i < buf.length () - 1; i ++) {
        if (Character.isLowerCase (buf.charAt (i - 1)) && Character.isUpperCase (buf.charAt (i)) && Character.isLowerCase (buf.charAt (i + 1))) {
            buf.insert (i ++, '_');
        }
    }
    return buf.toString ().toLowerCase (Locale.ROOT);
}
----------------------------------------

protected static String addUnderscores (String name) {
    final StringBuilder buf = new StringBuilder (name.replace ('.', '_'));
    for (int i = 1;
    i < buf.length () - 1; i ++) {
        if (Character.isLowerCase (buf.charAt (i - 1)) && Character.isUpperCase (buf.charAt (i)) && Character.isLowerCase (buf.charAt (i + 1))) {
            buf.insert (i ++, '_');
        }
    }
    return buf.toString ().toLowerCase (Locale.ROOT);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32438219_32498758_16_25
32438219_32498758_27_44
Title: finding path from tof left to bottom right in 2d array of 1's and 0's 
----------------------------------------

public static int [] [] findPath (int [] [] maze) {
    int [] [] solution = new int [maze.length] [];
    for (int i = 0;
    i < maze.length; i ++) {
        solution [i] = new int [maze [i].length];
    }
    if (! findPath (maze, solution, 0, 0)) {
        System.out.println ("Didn't find a solution.");
    }
    return solution;
}
----------------------------------------

private static boolean findPath (int [] [] maze, int [] [] solution, int x, int y) {
    if (0 <= y && y < maze.length && 0 <= x && x < maze [y].length) {
        if (y == maze.length - 1 && x == maze [y].length - 1) {
            solution [y] [x] = 1;
            return true;
        } else if (solution [y] [x] != 1 && maze [y] [x] == 1) {
            solution [y] [x] = 1;
            if (findPath (maze, solution, x, y + 1) || findPath (maze, solution, x + 1, y) || findPath (maze, solution, x - 1, y) || findPath (maze, solution, x, y - 1)) {
                return true;
            }
            solution [y] [x] = 0;
        }

    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32439633_32439897_1_14
32439633_32440138_1_14
Title: Android: I just want to have a validation for avoiding duplication of email address 
----------------------------------------

private boolean checkEmailExists (String email) {
    String query = "Select * from " + TABLE_NAME + " where email like '" + email + "'";
    Cursor cursor = db.rawQuery (query, null);
    if (cursor.getCount () > 0) {
        cursor.close ();
        return true;
    } else {
        cursor.close ();
        return false;
    }
}
----------------------------------------

private boolean checkEmailExists (String email) {
    String query = new StringBuilder ().append ("Select ").append (email).append (" from ").append (TABLE_NAME).toString ();
    Cursor cursor = db.rawQuery (query, new String [] {email});
    if (cursor.getCount () > 0) {
        cursor.close ();
        return true;
    } else {
        cursor.close ();
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32443627_32443669_1_28
32443627_32443912_1_24
Title: need to output error if anything EXCEPT 1 or 2 is input by user 
----------------------------------------

public static void main (String [] args) {
    System.out.println ("Please enter 1 to add or 2 to multiply. ");
    Scanner in = new Scanner (System.in);
    try {
        int value = in.nextInt ();
        if (value == 1) {
            System.out.println ("add");
        } else if (value == 2) {
            System.out.println ("mult");
        } else {
            System.out.println ("Operation failed. You need to enter 1 or 2.");
        }

    } catch (Exception e) {
        System.out.println ("Read operation failed. This should not happen!");
    }
}
----------------------------------------

public static void main (String [] args) {
    System.out.println ("Please enter 1 to add or 2 to multiply. ");
    Scanner in = new Scanner (System.in);
    boolean inputNotValid = true;
    while (inputNotValid) {
        int input = in.nextInt ();
        if (input == 1) {
            inputNotValid = false;
            System.out.println ("adding");
        } else if (input == 2) {
            inputNotValid = false;
            System.out.println ("multiplying");
        } else {
            System.out.println ("Operation failed. You need to enter 1 or 2. Try again");
        }

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32444193_32444320_13_28
32444193_32445147_10_20
Title: Count different values in array in Java 
----------------------------------------

public static int differentValuesUnsorted (int [] array) {
    Set < Integer > alreadyPresent = new HashSet < Integer > ();
    for (int nextElem : array) {
        alreadyPresent.add (nextElem);
    }
    if (alreadyPresent.size () == 1) {
        return 0;
    }
    return alreadyPresent.size ();
}
----------------------------------------

public static int differentValuesUnsorted (int [] a) {
    ArrayList < Integer > ArrUnique = new ArrayList < Integer > ();
    int values = 0;
    for (int num : a) {
        if (! ArrUnique.contains (num)) ArrUnique.add (num);

    }
    values = ArrUnique.size ();
    if (values == 1) values = 0;

    return values;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32444193_32444480_1_10
32444193_32445147_10_20
Title: Count different values in array in Java 
----------------------------------------

public static int differentValuesUnsorted (int [] a) {
    Set < Integer > unique = new HashSet < Integer > ();
    for (int val : a) {
        unique.add (val);
    }
    if (unique.size () < 2) {
        return 0;
    }
    return unique.size ();
}
----------------------------------------

public static int differentValuesUnsorted (int [] a) {
    ArrayList < Integer > ArrUnique = new ArrayList < Integer > ();
    int values = 0;
    for (int num : a) {
        if (! ArrUnique.contains (num)) ArrUnique.add (num);

    }
    values = ArrUnique.size ();
    if (values == 1) values = 0;

    return values;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_190_209
32447043_32450479_19_37
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

public MainPanel (List < Double > scores) {
    setLayout (new BorderLayout ());
    JLabel title = new JLabel ("Variation of Distance with time");
    title.setFont (new Font ("Arial", Font.BOLD, 25));
    title.setHorizontalAlignment (JLabel.CENTER);
    JPanel graphPanel = new GraphPanel (scores);
    VerticalPanel vertPanel = new VerticalPanel ();
    HorizontalPanel horiPanel = new HorizontalPanel ();
    add (title, BorderLayout.NORTH);
    add (horiPanel, BorderLayout.SOUTH);
    add (vertPanel, BorderLayout.WEST);
    add (graphPanel, BorderLayout.CENTER);
}
----------------------------------------

public MainPanel (List < Double > scores) {
    setLayout (new BorderLayout ());
    JLabel title = new JLabel ("Variation of Distance with time");
    title.setFont (new Font ("Arial", Font.BOLD, 25));
    title.setHorizontalAlignment (JLabel.CENTER);
    JPanel graphPanel = new GraphPanel (scores);
    MainPanel.VerticalPanel vertPanel = new MainPanel.VerticalPanel ();
    MainPanel.HorizontalPanel horiPanel = new MainPanel.HorizontalPanel ();
    add (title, BorderLayout.NORTH);
    add (horiPanel, BorderLayout.SOUTH);
    add (vertPanel, BorderLayout.WEST);
    add (graphPanel, BorderLayout.CENTER);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_218_236
32447043_32448101_41_127
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Time (s)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);
}
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2 = (Graphics2D) g;
    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);
    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());
    List < Point > graphPoints = new ArrayList < > ();
    for (int i = 0;
    i < scores.size (); i ++) {
        int x1 = (int) (i * xScale + padding + labelPadding);
        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);
        graphPoints.add (new Point (x1, y1));
    }
    g2.setColor (Color.WHITE);
    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);
    g2.setColor (Color.BLACK);
    for (int i = 0;
    i < numberYDivisions + 1; i ++) {
        int x0 = padding + labelPadding;
        int x1 = pointWidth + padding + labelPadding;
        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);
        int y1 = y0;
        if (scores.size () > 0) {
            g2.setColor (gridColor);
            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);
            g2.setColor (Color.BLACK);
            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + "";
            FontMetrics metrics = g2.getFontMetrics ();
            int labelWidth = metrics.stringWidth (yLabel);
            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);
        }
        g2.drawLine (x0, y0, x1, y1);
    }
    for (int i = 0;
    i < scores.size (); i ++) {
        if (scores.size () > 1) {
            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;
            int x1 = x0;
            int y0 = getHeight () - padding - labelPadding;
            int y1 = y0 - pointWidth;
            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {
                g2.setColor (gridColor);
                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);
                g2.setColor (Color.BLACK);
                String xLabel = i + "";
                FontMetrics metrics = g2.getFontMetrics ();
                int labelWidth = metrics.stringWidth (xLabel);
                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);
            }
            g2.drawLine (x0, y0, x1, y1);
        }
    }
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);
    Stroke oldStroke = g2.getStroke ();
    g2.setColor (lineColor);
    g2.setStroke (GRAPH_STROKE);
    for (int i = 0;
    i < graphPoints.size () - 1; i ++) {
        int x1 = graphPoints.get (i).x;
        int y1 = graphPoints.get (i).y;
        int x2 = graphPoints.get (i + 1).x;
        int y2 = graphPoints.get (i + 1).y;
        g2.drawLine (x1, y1, x2, y2);
    }
    g2.setStroke (oldStroke);
    g2.setColor (pointColor);
    for (int i = 0;
    i < graphPoints.size (); i ++) {
        int x = graphPoints.get (i).x - pointWidth / 2;
        int y = graphPoints.get (i).y - pointWidth / 2;
        int ovalW = pointWidth;
        int ovalH = pointWidth;
        g2.fillOval (x, y, ovalW, ovalH);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_218_236
32447043_32450479_125_207
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Time (s)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);
}
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2 = (Graphics2D) g;
    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);
    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());
    List < Point > graphPoints = new ArrayList < > ();
    for (int i = 0;
    i < scores.size (); i ++) {
        int x1 = (int) (i * xScale + padding + labelPadding);
        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);
        graphPoints.add (new Point (x1, y1));
    }
    g2.setColor (Color.WHITE);
    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);
    g2.setColor (Color.BLACK);
    for (int i = 0;
    i < numberYDivisions + 1; i ++) {
        int x0 = padding + labelPadding;
        int x1 = pointWidth + padding + labelPadding;
        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);
        int y1 = y0;
        if (scores.size () > 0) {
            g2.setColor (gridColor);
            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);
            g2.setColor (Color.BLACK);
            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + "";
            FontMetrics metrics = g2.getFontMetrics ();
            int labelWidth = metrics.stringWidth (yLabel);
            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);
        }
        g2.drawLine (x0, y0, x1, y1);
    }
    for (int i = 0;
    i < scores.size (); i ++) {
        if (scores.size () > 1) {
            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;
            int x1 = x0;
            int y0 = getHeight () - padding - labelPadding;
            int y1 = y0 - pointWidth;
            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {
                g2.setColor (gridColor);
                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);
                g2.setColor (Color.BLACK);
                String xLabel = i + "";
                FontMetrics metrics = g2.getFontMetrics ();
                int labelWidth = metrics.stringWidth (xLabel);
                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);
            }
            g2.drawLine (x0, y0, x1, y1);
        }
    }
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);
    Stroke oldStroke = g2.getStroke ();
    g2.setColor (lineColor);
    g2.setStroke (GRAPH_STROKE);
    for (int i = 0;
    i < graphPoints.size () - 1; i ++) {
        int x1 = graphPoints.get (i).x;
        int y1 = graphPoints.get (i).y;
        int x2 = graphPoints.get (i + 1).x;
        int y2 = graphPoints.get (i + 1).y;
        g2.drawLine (x1, y1, x2, y2);
    }
    g2.setStroke (oldStroke);
    g2.setColor (pointColor);
    for (int i = 0;
    i < graphPoints.size (); i ++) {
        int x = graphPoints.get (i).x - pointWidth / 2;
        int y = graphPoints.get (i).y - pointWidth / 2;
        int ovalW = pointWidth;
        int ovalH = pointWidth;
        g2.fillOval (x, y, ovalW, ovalH);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_218_236
32447043_32450479_251_269
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Time (s)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Time (s)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_218_236
32447043_32450479_288_306
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Time (s)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Distance (m)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    gg.drawString (string, (getWidth () - width) / 2, 11);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_218_236
32447043_32450479_46_64
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Time (s)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Time (s)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_218_236
32447043_32450479_83_101
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Time (s)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Distance (m)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    gg.drawString (string, (getWidth () - width) / 2, 11);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_255_273
32447043_32448101_41_127
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Distance (m)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    gg.drawString (string, (getWidth () - width) / 2, 11);
}
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2 = (Graphics2D) g;
    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);
    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());
    List < Point > graphPoints = new ArrayList < > ();
    for (int i = 0;
    i < scores.size (); i ++) {
        int x1 = (int) (i * xScale + padding + labelPadding);
        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);
        graphPoints.add (new Point (x1, y1));
    }
    g2.setColor (Color.WHITE);
    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);
    g2.setColor (Color.BLACK);
    for (int i = 0;
    i < numberYDivisions + 1; i ++) {
        int x0 = padding + labelPadding;
        int x1 = pointWidth + padding + labelPadding;
        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);
        int y1 = y0;
        if (scores.size () > 0) {
            g2.setColor (gridColor);
            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);
            g2.setColor (Color.BLACK);
            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + "";
            FontMetrics metrics = g2.getFontMetrics ();
            int labelWidth = metrics.stringWidth (yLabel);
            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);
        }
        g2.drawLine (x0, y0, x1, y1);
    }
    for (int i = 0;
    i < scores.size (); i ++) {
        if (scores.size () > 1) {
            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;
            int x1 = x0;
            int y0 = getHeight () - padding - labelPadding;
            int y1 = y0 - pointWidth;
            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {
                g2.setColor (gridColor);
                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);
                g2.setColor (Color.BLACK);
                String xLabel = i + "";
                FontMetrics metrics = g2.getFontMetrics ();
                int labelWidth = metrics.stringWidth (xLabel);
                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);
            }
            g2.drawLine (x0, y0, x1, y1);
        }
    }
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);
    Stroke oldStroke = g2.getStroke ();
    g2.setColor (lineColor);
    g2.setStroke (GRAPH_STROKE);
    for (int i = 0;
    i < graphPoints.size () - 1; i ++) {
        int x1 = graphPoints.get (i).x;
        int y1 = graphPoints.get (i).y;
        int x2 = graphPoints.get (i + 1).x;
        int y2 = graphPoints.get (i + 1).y;
        g2.drawLine (x1, y1, x2, y2);
    }
    g2.setStroke (oldStroke);
    g2.setColor (pointColor);
    for (int i = 0;
    i < graphPoints.size (); i ++) {
        int x = graphPoints.get (i).x - pointWidth / 2;
        int y = graphPoints.get (i).y - pointWidth / 2;
        int ovalW = pointWidth;
        int ovalH = pointWidth;
        g2.fillOval (x, y, ovalW, ovalH);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_255_273
32447043_32450479_125_207
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Distance (m)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    gg.drawString (string, (getWidth () - width) / 2, 11);
}
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2 = (Graphics2D) g;
    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);
    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());
    List < Point > graphPoints = new ArrayList < > ();
    for (int i = 0;
    i < scores.size (); i ++) {
        int x1 = (int) (i * xScale + padding + labelPadding);
        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);
        graphPoints.add (new Point (x1, y1));
    }
    g2.setColor (Color.WHITE);
    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);
    g2.setColor (Color.BLACK);
    for (int i = 0;
    i < numberYDivisions + 1; i ++) {
        int x0 = padding + labelPadding;
        int x1 = pointWidth + padding + labelPadding;
        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);
        int y1 = y0;
        if (scores.size () > 0) {
            g2.setColor (gridColor);
            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);
            g2.setColor (Color.BLACK);
            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + "";
            FontMetrics metrics = g2.getFontMetrics ();
            int labelWidth = metrics.stringWidth (yLabel);
            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);
        }
        g2.drawLine (x0, y0, x1, y1);
    }
    for (int i = 0;
    i < scores.size (); i ++) {
        if (scores.size () > 1) {
            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;
            int x1 = x0;
            int y0 = getHeight () - padding - labelPadding;
            int y1 = y0 - pointWidth;
            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {
                g2.setColor (gridColor);
                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);
                g2.setColor (Color.BLACK);
                String xLabel = i + "";
                FontMetrics metrics = g2.getFontMetrics ();
                int labelWidth = metrics.stringWidth (xLabel);
                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);
            }
            g2.drawLine (x0, y0, x1, y1);
        }
    }
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);
    Stroke oldStroke = g2.getStroke ();
    g2.setColor (lineColor);
    g2.setStroke (GRAPH_STROKE);
    for (int i = 0;
    i < graphPoints.size () - 1; i ++) {
        int x1 = graphPoints.get (i).x;
        int y1 = graphPoints.get (i).y;
        int x2 = graphPoints.get (i + 1).x;
        int y2 = graphPoints.get (i + 1).y;
        g2.drawLine (x1, y1, x2, y2);
    }
    g2.setStroke (oldStroke);
    g2.setColor (pointColor);
    for (int i = 0;
    i < graphPoints.size (); i ++) {
        int x = graphPoints.get (i).x - pointWidth / 2;
        int y = graphPoints.get (i).y - pointWidth / 2;
        int ovalW = pointWidth;
        int ovalH = pointWidth;
        g2.fillOval (x, y, ovalW, ovalH);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_255_273
32447043_32450479_251_269
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Distance (m)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    gg.drawString (string, (getWidth () - width) / 2, 11);
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Time (s)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_255_273
32447043_32450479_288_306
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Distance (m)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    gg.drawString (string, (getWidth () - width) / 2, 11);
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Distance (m)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    gg.drawString (string, (getWidth () - width) / 2, 11);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_255_273
32447043_32450479_46_64
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Distance (m)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    gg.drawString (string, (getWidth () - width) / 2, 11);
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Time (s)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_255_273
32447043_32450479_83_101
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Distance (m)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    gg.drawString (string, (getWidth () - width) / 2, 11);
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Distance (m)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    gg.drawString (string, (getWidth () - width) / 2, 11);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_41_127
32447043_32450479_125_207
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2 = (Graphics2D) g;
    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);
    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());
    List < Point > graphPoints = new ArrayList < > ();
    for (int i = 0;
    i < scores.size (); i ++) {
        int x1 = (int) (i * xScale + padding + labelPadding);
        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);
        graphPoints.add (new Point (x1, y1));
    }
    g2.setColor (Color.WHITE);
    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);
    g2.setColor (Color.BLACK);
    for (int i = 0;
    i < numberYDivisions + 1; i ++) {
        int x0 = padding + labelPadding;
        int x1 = pointWidth + padding + labelPadding;
        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);
        int y1 = y0;
        if (scores.size () > 0) {
            g2.setColor (gridColor);
            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);
            g2.setColor (Color.BLACK);
            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + "";
            FontMetrics metrics = g2.getFontMetrics ();
            int labelWidth = metrics.stringWidth (yLabel);
            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);
        }
        g2.drawLine (x0, y0, x1, y1);
    }
    for (int i = 0;
    i < scores.size (); i ++) {
        if (scores.size () > 1) {
            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;
            int x1 = x0;
            int y0 = getHeight () - padding - labelPadding;
            int y1 = y0 - pointWidth;
            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {
                g2.setColor (gridColor);
                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);
                g2.setColor (Color.BLACK);
                String xLabel = i + "";
                FontMetrics metrics = g2.getFontMetrics ();
                int labelWidth = metrics.stringWidth (xLabel);
                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);
            }
            g2.drawLine (x0, y0, x1, y1);
        }
    }
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);
    Stroke oldStroke = g2.getStroke ();
    g2.setColor (lineColor);
    g2.setStroke (GRAPH_STROKE);
    for (int i = 0;
    i < graphPoints.size () - 1; i ++) {
        int x1 = graphPoints.get (i).x;
        int y1 = graphPoints.get (i).y;
        int x2 = graphPoints.get (i + 1).x;
        int y2 = graphPoints.get (i + 1).y;
        g2.drawLine (x1, y1, x2, y2);
    }
    g2.setStroke (oldStroke);
    g2.setColor (pointColor);
    for (int i = 0;
    i < graphPoints.size (); i ++) {
        int x = graphPoints.get (i).x - pointWidth / 2;
        int y = graphPoints.get (i).y - pointWidth / 2;
        int ovalW = pointWidth;
        int ovalH = pointWidth;
        g2.fillOval (x, y, ovalW, ovalH);
    }
}
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2 = (Graphics2D) g;
    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);
    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());
    List < Point > graphPoints = new ArrayList < > ();
    for (int i = 0;
    i < scores.size (); i ++) {
        int x1 = (int) (i * xScale + padding + labelPadding);
        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);
        graphPoints.add (new Point (x1, y1));
    }
    g2.setColor (Color.WHITE);
    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);
    g2.setColor (Color.BLACK);
    for (int i = 0;
    i < numberYDivisions + 1; i ++) {
        int x0 = padding + labelPadding;
        int x1 = pointWidth + padding + labelPadding;
        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);
        int y1 = y0;
        if (scores.size () > 0) {
            g2.setColor (gridColor);
            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);
            g2.setColor (Color.BLACK);
            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + "";
            FontMetrics metrics = g2.getFontMetrics ();
            int labelWidth = metrics.stringWidth (yLabel);
            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);
        }
        g2.drawLine (x0, y0, x1, y1);
    }
    for (int i = 0;
    i < scores.size (); i ++) {
        if (scores.size () > 1) {
            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;
            int x1 = x0;
            int y0 = getHeight () - padding - labelPadding;
            int y1 = y0 - pointWidth;
            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {
                g2.setColor (gridColor);
                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);
                g2.setColor (Color.BLACK);
                String xLabel = i + "";
                FontMetrics metrics = g2.getFontMetrics ();
                int labelWidth = metrics.stringWidth (xLabel);
                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);
            }
            g2.drawLine (x0, y0, x1, y1);
        }
    }
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);
    Stroke oldStroke = g2.getStroke ();
    g2.setColor (lineColor);
    g2.setStroke (GRAPH_STROKE);
    for (int i = 0;
    i < graphPoints.size () - 1; i ++) {
        int x1 = graphPoints.get (i).x;
        int y1 = graphPoints.get (i).y;
        int x2 = graphPoints.get (i + 1).x;
        int y2 = graphPoints.get (i + 1).y;
        g2.drawLine (x1, y1, x2, y2);
    }
    g2.setStroke (oldStroke);
    g2.setColor (pointColor);
    for (int i = 0;
    i < graphPoints.size (); i ++) {
        int x = graphPoints.get (i).x - pointWidth / 2;
        int y = graphPoints.get (i).y - pointWidth / 2;
        int ovalW = pointWidth;
        int ovalH = pointWidth;
        g2.fillOval (x, y, ovalW, ovalH);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_41_127
32447043_32450479_251_269
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2 = (Graphics2D) g;
    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);
    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());
    List < Point > graphPoints = new ArrayList < > ();
    for (int i = 0;
    i < scores.size (); i ++) {
        int x1 = (int) (i * xScale + padding + labelPadding);
        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);
        graphPoints.add (new Point (x1, y1));
    }
    g2.setColor (Color.WHITE);
    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);
    g2.setColor (Color.BLACK);
    for (int i = 0;
    i < numberYDivisions + 1; i ++) {
        int x0 = padding + labelPadding;
        int x1 = pointWidth + padding + labelPadding;
        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);
        int y1 = y0;
        if (scores.size () > 0) {
            g2.setColor (gridColor);
            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);
            g2.setColor (Color.BLACK);
            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + "";
            FontMetrics metrics = g2.getFontMetrics ();
            int labelWidth = metrics.stringWidth (yLabel);
            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);
        }
        g2.drawLine (x0, y0, x1, y1);
    }
    for (int i = 0;
    i < scores.size (); i ++) {
        if (scores.size () > 1) {
            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;
            int x1 = x0;
            int y0 = getHeight () - padding - labelPadding;
            int y1 = y0 - pointWidth;
            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {
                g2.setColor (gridColor);
                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);
                g2.setColor (Color.BLACK);
                String xLabel = i + "";
                FontMetrics metrics = g2.getFontMetrics ();
                int labelWidth = metrics.stringWidth (xLabel);
                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);
            }
            g2.drawLine (x0, y0, x1, y1);
        }
    }
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);
    Stroke oldStroke = g2.getStroke ();
    g2.setColor (lineColor);
    g2.setStroke (GRAPH_STROKE);
    for (int i = 0;
    i < graphPoints.size () - 1; i ++) {
        int x1 = graphPoints.get (i).x;
        int y1 = graphPoints.get (i).y;
        int x2 = graphPoints.get (i + 1).x;
        int y2 = graphPoints.get (i + 1).y;
        g2.drawLine (x1, y1, x2, y2);
    }
    g2.setStroke (oldStroke);
    g2.setColor (pointColor);
    for (int i = 0;
    i < graphPoints.size (); i ++) {
        int x = graphPoints.get (i).x - pointWidth / 2;
        int y = graphPoints.get (i).y - pointWidth / 2;
        int ovalW = pointWidth;
        int ovalH = pointWidth;
        g2.fillOval (x, y, ovalW, ovalH);
    }
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Time (s)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_41_127
32447043_32450479_288_306
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2 = (Graphics2D) g;
    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);
    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());
    List < Point > graphPoints = new ArrayList < > ();
    for (int i = 0;
    i < scores.size (); i ++) {
        int x1 = (int) (i * xScale + padding + labelPadding);
        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);
        graphPoints.add (new Point (x1, y1));
    }
    g2.setColor (Color.WHITE);
    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);
    g2.setColor (Color.BLACK);
    for (int i = 0;
    i < numberYDivisions + 1; i ++) {
        int x0 = padding + labelPadding;
        int x1 = pointWidth + padding + labelPadding;
        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);
        int y1 = y0;
        if (scores.size () > 0) {
            g2.setColor (gridColor);
            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);
            g2.setColor (Color.BLACK);
            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + "";
            FontMetrics metrics = g2.getFontMetrics ();
            int labelWidth = metrics.stringWidth (yLabel);
            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);
        }
        g2.drawLine (x0, y0, x1, y1);
    }
    for (int i = 0;
    i < scores.size (); i ++) {
        if (scores.size () > 1) {
            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;
            int x1 = x0;
            int y0 = getHeight () - padding - labelPadding;
            int y1 = y0 - pointWidth;
            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {
                g2.setColor (gridColor);
                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);
                g2.setColor (Color.BLACK);
                String xLabel = i + "";
                FontMetrics metrics = g2.getFontMetrics ();
                int labelWidth = metrics.stringWidth (xLabel);
                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);
            }
            g2.drawLine (x0, y0, x1, y1);
        }
    }
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);
    Stroke oldStroke = g2.getStroke ();
    g2.setColor (lineColor);
    g2.setStroke (GRAPH_STROKE);
    for (int i = 0;
    i < graphPoints.size () - 1; i ++) {
        int x1 = graphPoints.get (i).x;
        int y1 = graphPoints.get (i).y;
        int x2 = graphPoints.get (i + 1).x;
        int y2 = graphPoints.get (i + 1).y;
        g2.drawLine (x1, y1, x2, y2);
    }
    g2.setStroke (oldStroke);
    g2.setColor (pointColor);
    for (int i = 0;
    i < graphPoints.size (); i ++) {
        int x = graphPoints.get (i).x - pointWidth / 2;
        int y = graphPoints.get (i).y - pointWidth / 2;
        int ovalW = pointWidth;
        int ovalH = pointWidth;
        g2.fillOval (x, y, ovalW, ovalH);
    }
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Distance (m)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    gg.drawString (string, (getWidth () - width) / 2, 11);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_41_127
32447043_32450479_46_64
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2 = (Graphics2D) g;
    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);
    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());
    List < Point > graphPoints = new ArrayList < > ();
    for (int i = 0;
    i < scores.size (); i ++) {
        int x1 = (int) (i * xScale + padding + labelPadding);
        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);
        graphPoints.add (new Point (x1, y1));
    }
    g2.setColor (Color.WHITE);
    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);
    g2.setColor (Color.BLACK);
    for (int i = 0;
    i < numberYDivisions + 1; i ++) {
        int x0 = padding + labelPadding;
        int x1 = pointWidth + padding + labelPadding;
        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);
        int y1 = y0;
        if (scores.size () > 0) {
            g2.setColor (gridColor);
            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);
            g2.setColor (Color.BLACK);
            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + "";
            FontMetrics metrics = g2.getFontMetrics ();
            int labelWidth = metrics.stringWidth (yLabel);
            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);
        }
        g2.drawLine (x0, y0, x1, y1);
    }
    for (int i = 0;
    i < scores.size (); i ++) {
        if (scores.size () > 1) {
            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;
            int x1 = x0;
            int y0 = getHeight () - padding - labelPadding;
            int y1 = y0 - pointWidth;
            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {
                g2.setColor (gridColor);
                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);
                g2.setColor (Color.BLACK);
                String xLabel = i + "";
                FontMetrics metrics = g2.getFontMetrics ();
                int labelWidth = metrics.stringWidth (xLabel);
                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);
            }
            g2.drawLine (x0, y0, x1, y1);
        }
    }
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);
    Stroke oldStroke = g2.getStroke ();
    g2.setColor (lineColor);
    g2.setStroke (GRAPH_STROKE);
    for (int i = 0;
    i < graphPoints.size () - 1; i ++) {
        int x1 = graphPoints.get (i).x;
        int y1 = graphPoints.get (i).y;
        int x2 = graphPoints.get (i + 1).x;
        int y2 = graphPoints.get (i + 1).y;
        g2.drawLine (x1, y1, x2, y2);
    }
    g2.setStroke (oldStroke);
    g2.setColor (pointColor);
    for (int i = 0;
    i < graphPoints.size (); i ++) {
        int x = graphPoints.get (i).x - pointWidth / 2;
        int y = graphPoints.get (i).y - pointWidth / 2;
        int ovalW = pointWidth;
        int ovalH = pointWidth;
        g2.fillOval (x, y, ovalW, ovalH);
    }
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Time (s)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32448101_41_127
32447043_32450479_83_101
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2 = (Graphics2D) g;
    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);
    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());
    List < Point > graphPoints = new ArrayList < > ();
    for (int i = 0;
    i < scores.size (); i ++) {
        int x1 = (int) (i * xScale + padding + labelPadding);
        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);
        graphPoints.add (new Point (x1, y1));
    }
    g2.setColor (Color.WHITE);
    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);
    g2.setColor (Color.BLACK);
    for (int i = 0;
    i < numberYDivisions + 1; i ++) {
        int x0 = padding + labelPadding;
        int x1 = pointWidth + padding + labelPadding;
        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);
        int y1 = y0;
        if (scores.size () > 0) {
            g2.setColor (gridColor);
            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);
            g2.setColor (Color.BLACK);
            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + "";
            FontMetrics metrics = g2.getFontMetrics ();
            int labelWidth = metrics.stringWidth (yLabel);
            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);
        }
        g2.drawLine (x0, y0, x1, y1);
    }
    for (int i = 0;
    i < scores.size (); i ++) {
        if (scores.size () > 1) {
            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;
            int x1 = x0;
            int y0 = getHeight () - padding - labelPadding;
            int y1 = y0 - pointWidth;
            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {
                g2.setColor (gridColor);
                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);
                g2.setColor (Color.BLACK);
                String xLabel = i + "";
                FontMetrics metrics = g2.getFontMetrics ();
                int labelWidth = metrics.stringWidth (xLabel);
                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);
            }
            g2.drawLine (x0, y0, x1, y1);
        }
    }
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);
    Stroke oldStroke = g2.getStroke ();
    g2.setColor (lineColor);
    g2.setStroke (GRAPH_STROKE);
    for (int i = 0;
    i < graphPoints.size () - 1; i ++) {
        int x1 = graphPoints.get (i).x;
        int y1 = graphPoints.get (i).y;
        int x2 = graphPoints.get (i + 1).x;
        int y2 = graphPoints.get (i + 1).y;
        g2.drawLine (x1, y1, x2, y2);
    }
    g2.setStroke (oldStroke);
    g2.setColor (pointColor);
    for (int i = 0;
    i < graphPoints.size (); i ++) {
        int x = graphPoints.get (i).x - pointWidth / 2;
        int y = graphPoints.get (i).y - pointWidth / 2;
        int ovalW = pointWidth;
        int ovalH = pointWidth;
        g2.fillOval (x, y, ovalW, ovalH);
    }
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Distance (m)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    gg.drawString (string, (getWidth () - width) / 2, 11);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32450479_125_207
32447043_32450479_251_269
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2 = (Graphics2D) g;
    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);
    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());
    List < Point > graphPoints = new ArrayList < > ();
    for (int i = 0;
    i < scores.size (); i ++) {
        int x1 = (int) (i * xScale + padding + labelPadding);
        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);
        graphPoints.add (new Point (x1, y1));
    }
    g2.setColor (Color.WHITE);
    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);
    g2.setColor (Color.BLACK);
    for (int i = 0;
    i < numberYDivisions + 1; i ++) {
        int x0 = padding + labelPadding;
        int x1 = pointWidth + padding + labelPadding;
        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);
        int y1 = y0;
        if (scores.size () > 0) {
            g2.setColor (gridColor);
            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);
            g2.setColor (Color.BLACK);
            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + "";
            FontMetrics metrics = g2.getFontMetrics ();
            int labelWidth = metrics.stringWidth (yLabel);
            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);
        }
        g2.drawLine (x0, y0, x1, y1);
    }
    for (int i = 0;
    i < scores.size (); i ++) {
        if (scores.size () > 1) {
            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;
            int x1 = x0;
            int y0 = getHeight () - padding - labelPadding;
            int y1 = y0 - pointWidth;
            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {
                g2.setColor (gridColor);
                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);
                g2.setColor (Color.BLACK);
                String xLabel = i + "";
                FontMetrics metrics = g2.getFontMetrics ();
                int labelWidth = metrics.stringWidth (xLabel);
                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);
            }
            g2.drawLine (x0, y0, x1, y1);
        }
    }
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);
    Stroke oldStroke = g2.getStroke ();
    g2.setColor (lineColor);
    g2.setStroke (GRAPH_STROKE);
    for (int i = 0;
    i < graphPoints.size () - 1; i ++) {
        int x1 = graphPoints.get (i).x;
        int y1 = graphPoints.get (i).y;
        int x2 = graphPoints.get (i + 1).x;
        int y2 = graphPoints.get (i + 1).y;
        g2.drawLine (x1, y1, x2, y2);
    }
    g2.setStroke (oldStroke);
    g2.setColor (pointColor);
    for (int i = 0;
    i < graphPoints.size (); i ++) {
        int x = graphPoints.get (i).x - pointWidth / 2;
        int y = graphPoints.get (i).y - pointWidth / 2;
        int ovalW = pointWidth;
        int ovalH = pointWidth;
        g2.fillOval (x, y, ovalW, ovalH);
    }
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Time (s)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32450479_125_207
32447043_32450479_288_306
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2 = (Graphics2D) g;
    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);
    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());
    List < Point > graphPoints = new ArrayList < > ();
    for (int i = 0;
    i < scores.size (); i ++) {
        int x1 = (int) (i * xScale + padding + labelPadding);
        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);
        graphPoints.add (new Point (x1, y1));
    }
    g2.setColor (Color.WHITE);
    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);
    g2.setColor (Color.BLACK);
    for (int i = 0;
    i < numberYDivisions + 1; i ++) {
        int x0 = padding + labelPadding;
        int x1 = pointWidth + padding + labelPadding;
        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);
        int y1 = y0;
        if (scores.size () > 0) {
            g2.setColor (gridColor);
            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);
            g2.setColor (Color.BLACK);
            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + "";
            FontMetrics metrics = g2.getFontMetrics ();
            int labelWidth = metrics.stringWidth (yLabel);
            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);
        }
        g2.drawLine (x0, y0, x1, y1);
    }
    for (int i = 0;
    i < scores.size (); i ++) {
        if (scores.size () > 1) {
            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;
            int x1 = x0;
            int y0 = getHeight () - padding - labelPadding;
            int y1 = y0 - pointWidth;
            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {
                g2.setColor (gridColor);
                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);
                g2.setColor (Color.BLACK);
                String xLabel = i + "";
                FontMetrics metrics = g2.getFontMetrics ();
                int labelWidth = metrics.stringWidth (xLabel);
                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);
            }
            g2.drawLine (x0, y0, x1, y1);
        }
    }
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);
    Stroke oldStroke = g2.getStroke ();
    g2.setColor (lineColor);
    g2.setStroke (GRAPH_STROKE);
    for (int i = 0;
    i < graphPoints.size () - 1; i ++) {
        int x1 = graphPoints.get (i).x;
        int y1 = graphPoints.get (i).y;
        int x2 = graphPoints.get (i + 1).x;
        int y2 = graphPoints.get (i + 1).y;
        g2.drawLine (x1, y1, x2, y2);
    }
    g2.setStroke (oldStroke);
    g2.setColor (pointColor);
    for (int i = 0;
    i < graphPoints.size (); i ++) {
        int x = graphPoints.get (i).x - pointWidth / 2;
        int y = graphPoints.get (i).y - pointWidth / 2;
        int ovalW = pointWidth;
        int ovalH = pointWidth;
        g2.fillOval (x, y, ovalW, ovalH);
    }
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Distance (m)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    gg.drawString (string, (getWidth () - width) / 2, 11);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32450479_125_207
32447043_32450479_46_64
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2 = (Graphics2D) g;
    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);
    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());
    List < Point > graphPoints = new ArrayList < > ();
    for (int i = 0;
    i < scores.size (); i ++) {
        int x1 = (int) (i * xScale + padding + labelPadding);
        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);
        graphPoints.add (new Point (x1, y1));
    }
    g2.setColor (Color.WHITE);
    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);
    g2.setColor (Color.BLACK);
    for (int i = 0;
    i < numberYDivisions + 1; i ++) {
        int x0 = padding + labelPadding;
        int x1 = pointWidth + padding + labelPadding;
        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);
        int y1 = y0;
        if (scores.size () > 0) {
            g2.setColor (gridColor);
            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);
            g2.setColor (Color.BLACK);
            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + "";
            FontMetrics metrics = g2.getFontMetrics ();
            int labelWidth = metrics.stringWidth (yLabel);
            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);
        }
        g2.drawLine (x0, y0, x1, y1);
    }
    for (int i = 0;
    i < scores.size (); i ++) {
        if (scores.size () > 1) {
            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;
            int x1 = x0;
            int y0 = getHeight () - padding - labelPadding;
            int y1 = y0 - pointWidth;
            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {
                g2.setColor (gridColor);
                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);
                g2.setColor (Color.BLACK);
                String xLabel = i + "";
                FontMetrics metrics = g2.getFontMetrics ();
                int labelWidth = metrics.stringWidth (xLabel);
                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);
            }
            g2.drawLine (x0, y0, x1, y1);
        }
    }
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);
    Stroke oldStroke = g2.getStroke ();
    g2.setColor (lineColor);
    g2.setStroke (GRAPH_STROKE);
    for (int i = 0;
    i < graphPoints.size () - 1; i ++) {
        int x1 = graphPoints.get (i).x;
        int y1 = graphPoints.get (i).y;
        int x2 = graphPoints.get (i + 1).x;
        int y2 = graphPoints.get (i + 1).y;
        g2.drawLine (x1, y1, x2, y2);
    }
    g2.setStroke (oldStroke);
    g2.setColor (pointColor);
    for (int i = 0;
    i < graphPoints.size (); i ++) {
        int x = graphPoints.get (i).x - pointWidth / 2;
        int y = graphPoints.get (i).y - pointWidth / 2;
        int ovalW = pointWidth;
        int ovalH = pointWidth;
        g2.fillOval (x, y, ovalW, ovalH);
    }
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Time (s)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32450479_125_207
32447043_32450479_83_101
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2 = (Graphics2D) g;
    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);
    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());
    List < Point > graphPoints = new ArrayList < > ();
    for (int i = 0;
    i < scores.size (); i ++) {
        int x1 = (int) (i * xScale + padding + labelPadding);
        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);
        graphPoints.add (new Point (x1, y1));
    }
    g2.setColor (Color.WHITE);
    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);
    g2.setColor (Color.BLACK);
    for (int i = 0;
    i < numberYDivisions + 1; i ++) {
        int x0 = padding + labelPadding;
        int x1 = pointWidth + padding + labelPadding;
        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);
        int y1 = y0;
        if (scores.size () > 0) {
            g2.setColor (gridColor);
            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);
            g2.setColor (Color.BLACK);
            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + "";
            FontMetrics metrics = g2.getFontMetrics ();
            int labelWidth = metrics.stringWidth (yLabel);
            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);
        }
        g2.drawLine (x0, y0, x1, y1);
    }
    for (int i = 0;
    i < scores.size (); i ++) {
        if (scores.size () > 1) {
            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;
            int x1 = x0;
            int y0 = getHeight () - padding - labelPadding;
            int y1 = y0 - pointWidth;
            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {
                g2.setColor (gridColor);
                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);
                g2.setColor (Color.BLACK);
                String xLabel = i + "";
                FontMetrics metrics = g2.getFontMetrics ();
                int labelWidth = metrics.stringWidth (xLabel);
                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);
            }
            g2.drawLine (x0, y0, x1, y1);
        }
    }
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);
    Stroke oldStroke = g2.getStroke ();
    g2.setColor (lineColor);
    g2.setStroke (GRAPH_STROKE);
    for (int i = 0;
    i < graphPoints.size () - 1; i ++) {
        int x1 = graphPoints.get (i).x;
        int y1 = graphPoints.get (i).y;
        int x2 = graphPoints.get (i + 1).x;
        int y2 = graphPoints.get (i + 1).y;
        g2.drawLine (x1, y1, x2, y2);
    }
    g2.setStroke (oldStroke);
    g2.setColor (pointColor);
    for (int i = 0;
    i < graphPoints.size (); i ++) {
        int x = graphPoints.get (i).x - pointWidth / 2;
        int y = graphPoints.get (i).y - pointWidth / 2;
        int ovalW = pointWidth;
        int ovalH = pointWidth;
        g2.fillOval (x, y, ovalW, ovalH);
    }
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Distance (m)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    gg.drawString (string, (getWidth () - width) / 2, 11);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32450479_251_269
32447043_32450479_288_306
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Time (s)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Distance (m)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    gg.drawString (string, (getWidth () - width) / 2, 11);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32447043_32450479_251_269
32447043_32450479_46_64
Title: Adding axis labels and titles to a simple line graph/chart 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Time (s)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g;
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    Font font = new Font ("Arial", Font.PLAIN, 15);
    String string = "Time (s)";
    FontMetrics metrics = g.getFontMetrics (font);
    int width = metrics.stringWidth (string);
    int height = metrics.getHeight ();
    gg.setFont (font);
    drawRotate (gg, getWidth (), (getHeight () + width) / 2, 270, string);
}
----------------------------------------
