$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31720186_31720583_6_20
31720186_31721062_1_11
Title: Why is my code telling me to initialize a variable that is already initialized? 
----------------------------------------

public static String palindrome (String palindromeValue) {
    String str = palindromeValue, reverse = "";
    int length = str.length ();
    for (int i = length - 1;
    i >= 0; i --) {
        reverse = reverse + str.charAt (i);
    }
    if (str.equals (reverse)) {
        System.out.println ("Entered string is a palindrome.");
    } else {
        System.out.println ("Entered string is not a palindrome.");
    }
    return "";
}
----------------------------------------

public void palindrome (String str) {
    String reverse = "";
    int length = str.length ();
    for (int i = length - 1;
    i >= 0; i --) reverse = reverse + str.charAt (i);

    if (str.equals (reverse)) System.out.println ("Entered string is a palindrome.");
    else System.out.println ("Entered string is not a palindrome.");

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31736690_31737970_165_192
31736690_31741029_71_99
Title: java GUI to assign array value 
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    if (data != null) {
        Graphics2D g2d = (Graphics2D) g.create ();
        g2d.setColor (new Color (64, 64, 64, 32));
        for (int index = 0;
        index < data.length; index ++) {
            int xPos = (index * COLUMN_WIDTH) + COLUMN_WIDTH;
            g2d.drawLine (xPos, VERTICAL_INSETS, xPos, getHeight () - VERTICAL_INSETS);
        }
        g2d.setColor (Color.BLACK);
        g2d.draw (graph);
        for (Shape button : buttons) {
            g2d.fill (button);
        }
        if (mousePoint != null) {
            g2d.setColor (new Color (255, 192, 203));
            Ellipse2D dot = new Ellipse2D.Double ((mousePoint.x - COLUMN_WIDTH / 2) - 2, (mousePoint.y - COLUMN_WIDTH / 2) - 2, COLUMN_WIDTH + 4, COLUMN_WIDTH + 4);
            g2d.draw (dot);
            g2d.setColor (new Color (255, 192, 203, 128));
            g2d.fill (dot);
        }
        g2d.dispose ();
    }
}
----------------------------------------

protected void paintComponent (Graphics gr) {
    super.paintComponent (gr);
    Graphics2D g = (Graphics2D) gr.create ();
    Polygon p = new Polygon ();
    g.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    for (XYpoints poinList1 : poinList) {
        px = poinList1.getpX ();
        py = poinList1.getpY ();
        p.addPoint (px, py);
    }
    g.setColor (graphColor);
    g.fillPolygon (p);
    for (XYpoints poinList1 : poinList) {
        px = poinList1.getpX ();
        py = poinList1.getpY ();
        g.setColor (Color.red);
        if (poinList1.isIntersect ()) {
            g.setColor (Color.blue);
        }
        g.fillOval (px - 5, py - 5, 10, 10);
    }
    g.dispose ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31738259_31738318_2_11
31738259_31738453_3_16
Title: How can I delay my program so there's a pause in between text? 
----------------------------------------

public static void main (String [] args) {
    System.out.println ("Why hello there!");
    System.out.println ("Welcome to 'Ancient Battles and Adventures!");
    try {
        Thread.sleep (x);
    } catch (Exception e) {
        e.printStackTrace ();
    }
    System.out.println ("Now, what is your name?");
}
----------------------------------------

public static void main (String args []) {
    System.out.println ("Why hello there!");
    System.out.println ("Welcome to 'Ancient Battles and Adventures!");
    try {
        Thread.sleep (1000);
    } catch (Exception e) {
        e.printStackTrace ();
    }
    System.out.println ("Now, what is your name?");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31742061_31743873_27_52
31742061_31743873_38_48
Title: Java: Can't get JFrame to work 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    legs = mainWindow.getLegs ();
    speed = mainWindow.getSpeed ();
    mainWindow.dispose ();
    airportNames = new String [legs];
    latitudes = new double [legs];
    longtitudes = new double [legs];
    currentLeg = 0;
    class PortItinerary implements ActionListener {
        @Override
        public void actionPerformed (ActionEvent e) {
            airportNames [currentLeg] = legClass.getAirportName ();
            latitudes [currentLeg] = legClass.getLatitude ();
            longtitudes [currentLeg] = legClass.getLongtitude ();
            legClass.dispose ();
            if (++ currentLeg < legs) {
                legClass = new LegClass (new PortItinerary ());
            } else {
                doWhateverYouWantToDoNext ();
            }
        }}

    legClass = new LegClass (new PortItinerary ());
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    airportNames [currentLeg] = legClass.getAirportName ();
    latitudes [currentLeg] = legClass.getLatitude ();
    longtitudes [currentLeg] = legClass.getLongtitude ();
    legClass.dispose ();
    if (++ currentLeg < legs) {
        legClass = new LegClass (new PortItinerary ());
    } else {
        doWhateverYouWantToDoNext ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3174221_12667756_5_26
3174221_3174748_110_156
Title: java thread pool keep running 
----------------------------------------

public static void main (String...arguments) {
    try {
        thread1 = new Test ();
        thread2 = new Test ();
        thread3 = new Test ();
        thread1.setName ("A");
        thread2.sleep (2000);
        thread3.setPriority (Thread.MAX_PRIORITY);
        while (true) {
            thread1.start ();
            thread2.start ();
            thread3.start ();
        }
    } catch (Throwable t) {
        System.err.println (t.getMessage ());
    }
}
----------------------------------------

public static void main (String [] args) {
    ServerThread processor = new ServerThread ();
    Thread aThread = new Thread (processor);
    aThread.start ();
    try {
        Thread.sleep (500L);
    } catch (InterruptedException e1) {
        e1.printStackTrace ();
    }
    for (int i = 0;
    i < 100; i ++) {
        String text = "" + i;
        Request aRequest = new Request (text);
        processor.accept (aRequest);
    }
    try {
        Thread.sleep (500L);
    } catch (InterruptedException e1) {
        e1.printStackTrace ();
    }
    processor.stopProcessing ();
    try {
        aThread.join ();
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31761240_31761408_1_18
31761240_31761680_5_19
Title: "Correcting issues with the ""While"" loop" 
----------------------------------------

public static void main (String [] args) {
    int start = Integer.parseInt (JOptionPane.showInputDialog ("Enter a starting number (integer)"));
    int end = Integer.parseInt (JOptionPane.showInputDialog ("Enter an ending number (integer)"));
    for (int i = start;
    i < end; i ++) {
        if (i % 4 == 0) {
            System.out.print (i + " ");
        }
    }
    System.out.println ("");
    int i = start + (4 - (start % 4));
    while (i < end) {
        System.out.print (i + " ");
        i += 4;
    }
}
----------------------------------------

public static void main (String [] args) {
    int start = Integer.parseInt (JOptionPane.showInputDialog ("Enter a     starting number (integer)"));
    int end = Integer.parseInt (JOptionPane.showInputDialog ("Enter an ending   number (integer)"));
    if (start == 0 || start % 4 > 0) {
        start = start + (4 - start % 4);
    }
    while (start <= end) {
        System.out.print (start + "  ");
        start = start + 4;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31772072_31772257_6_25
31772072_31772285_1_36
Title: How to deal with multiplicity when checking if an arraylist is a subset 
----------------------------------------

public static void dostuff (String word1, String word2) {
    List < String > list1 = new ArrayList < String > ();
    for (String character : word1.split ("")) {
        list1.add (character);
    }
    boolean sub = true;
    for (String character : word2.split ("")) {
        if (list1.remove (character)) {
            if (list1.isEmpty ()) {
                break;
            }
        } else {
            sub = false;
            break;
        }
    }
    System.out.println (sub);
}
----------------------------------------

public static boolean dostuff (String word1, String word2) {
    List < String > list1 = new ArrayList < > ();
    List < String > list2 = new ArrayList < > ();
    List < String > list3;
    for (String character : word1.split ("")) {
        list1.add (character);
    }
    for (String character : word2.split ("")) {
        list2.add (character);
    }
    list3 = new ArrayList < > (list2);
    boolean isSubset = true;
    for (final String elem : list1) {
        if (! list2.remove (elem)) {
            isSubset = false;
            break;
        }
    }
    if (isSubset) {
        return true;
    }
    for (final String elem : list3) {
        if (! list1.remove (elem)) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31772072_31772257_6_25
31772072_31773677_1_36
Title: How to deal with multiplicity when checking if an arraylist is a subset 
----------------------------------------

public static void dostuff (String word1, String word2) {
    List < String > list1 = new ArrayList < String > ();
    for (String character : word1.split ("")) {
        list1.add (character);
    }
    boolean sub = true;
    for (String character : word2.split ("")) {
        if (list1.remove (character)) {
            if (list1.isEmpty ()) {
                break;
            }
        } else {
            sub = false;
            break;
        }
    }
    System.out.println (sub);
}
----------------------------------------

public static void dostuff (String word1, String word2) {
    boolean sub = false;
    ArrayList < String > list1 = new ArrayList < String > ();
    ArrayList < String > list2 = new ArrayList < String > ();
    ArrayList < String > list3 = new ArrayList < String > ();
    for (int i = 0;
    i < word1.length (); i ++) {
        list1.add (word1.split ("") [i]);
    }
    for (int i = 0;
    i < word2.length (); i ++) {
        list2.add (word2.split ("") [i]);
    }
    if (list1.size () >= list2.size ()) {
        for (String i : list2) {
            if (list1.contains (i)) {
                list1.remove (i);
                list3.add (i);
            }
        }
        if (list2.containsAll (list3) && list2.size () == list3.size ()) {
            sub = true;
        }
    } else if (list2.size () > list1.size ()) {
        for (String i : list1) {
            if (list2.contains (i)) {
                list2.remove (i);
                list3.add (i);
            }
            if (list1.containsAll (list3) && list1.size () == list3.size ()) {
                sub = true;
            }
        }
    }

    System.out.println (sub);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31772072_31772285_1_36
31772072_31773677_1_36
Title: How to deal with multiplicity when checking if an arraylist is a subset 
----------------------------------------

public static boolean dostuff (String word1, String word2) {
    List < String > list1 = new ArrayList < > ();
    List < String > list2 = new ArrayList < > ();
    List < String > list3;
    for (String character : word1.split ("")) {
        list1.add (character);
    }
    for (String character : word2.split ("")) {
        list2.add (character);
    }
    list3 = new ArrayList < > (list2);
    boolean isSubset = true;
    for (final String elem : list1) {
        if (! list2.remove (elem)) {
            isSubset = false;
            break;
        }
    }
    if (isSubset) {
        return true;
    }
    for (final String elem : list3) {
        if (! list1.remove (elem)) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static void dostuff (String word1, String word2) {
    boolean sub = false;
    ArrayList < String > list1 = new ArrayList < String > ();
    ArrayList < String > list2 = new ArrayList < String > ();
    ArrayList < String > list3 = new ArrayList < String > ();
    for (int i = 0;
    i < word1.length (); i ++) {
        list1.add (word1.split ("") [i]);
    }
    for (int i = 0;
    i < word2.length (); i ++) {
        list2.add (word2.split ("") [i]);
    }
    if (list1.size () >= list2.size ()) {
        for (String i : list2) {
            if (list1.contains (i)) {
                list1.remove (i);
                list3.add (i);
            }
        }
        if (list2.containsAll (list3) && list2.size () == list3.size ()) {
            sub = true;
        }
    } else if (list2.size () > list1.size ()) {
        for (String i : list1) {
            if (list2.contains (i)) {
                list2.remove (i);
                list3.add (i);
            }
            if (list1.containsAll (list3) && list1.size () == list3.size ()) {
                sub = true;
            }
        }
    }

    System.out.println (sub);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31774985_31775435_1_31
31774985_31775648_2_34
Title: Decrypt a Java string 
----------------------------------------

public static void main (String [] args) throws Exception {
    Scanner scanner = new Scanner (System.in);
    String input = scanner.nextLine ();
    StringBuilder sb = new StringBuilder ();
    sb.append (input.charAt (0));
    for (int i = 0;
    i < input.length () - 2;) {
        int jump = input.charAt (i) - 'A' + 1;
        if (i + jump < input.length () - 1) {
            sb.append (input.charAt (i + jump));
            i += jump;
        } else {
            break;
        }
    }
    sb.append (input.charAt (input.length () - 1));
    System.out.println (sb);
}
----------------------------------------

public static void main (String [] args) {
    if (args.length != 1) {
        System.out.println ("Error! Exiting...");
        System.out.println ("Usage: java decrypt ENCRYPTED_WORD");
        System.out.println ("       ENCRYPTED_WORD not found !!");
    } else {
        StringBuilder sb = new StringBuilder (args [0]);
        for (int i = 0;
        i < sb.length (); i ++) {
            char c = sb.charAt (i);
            if (Character.isLowerCase (c)) {
                sb.setCharAt (i, Character.toUpperCase (c));
            }
        }
        boolean mError = false;
        int mCounter = 0;
        StringBuilder Rezult = new StringBuilder ("");
        Rezult.append (sb.charAt (mCounter));
        while (mCounter < sb.length () - 1) {
            try {
                mCounter += sb.charAt (mCounter) - 'A' + 1;
                Rezult.append (sb.charAt (mCounter));
            } catch (Exception e) {
                mError = true;
            }
        }
        if (mError) {
            System.out.println ("Your input is incorrect!! Cannot Decrypt");
        } else {
            System.out.println ("Decrypted Code is: " + Rezult);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31786654_31788257_4_26
31786654_31789014_1_41
Title: A function that display the same text with two letters reversed 
----------------------------------------

public static void main (String [] args) {
    String input = "Hello World";
    String [] word = input.split (" ");
    String encryWord = "";
    for (int i = 0;
    i < word.length; i ++) {
        if (word [i].length () > 0) {
            String tmp0 = String.valueOf (word [i].charAt (1));
            String tmp1 = String.valueOf (word [i].charAt (0));
            encryWord += tmp0.toLowerCase () + tmp1.toLowerCase () + word [i].substring (2) + " ";
        } else {
            encryWord += word [i];
        }
    }
    System.out.println (encryWord);
}
----------------------------------------

public static void main (String [] args) throws Exception {
    String data = "Hello;World! My name is John. I write code.";
    String [] words = data.split ("\\W+");
    String [] delimiters = data.split ("\\w+");
    int delimiterIndex = 0;
    StringBuilder sb = new StringBuilder ();
    for (String word : words) {
        if (word.length () < 2) {
            sb.append (word);
        } else {
            char firstLetter = word.charAt (0);
            char secondLetter = word.charAt (1);
            if (Character.isUpperCase (firstLetter)) {
                sb.append (Character.toUpperCase (secondLetter)).append (Character.toLowerCase (firstLetter));
            } else {
                sb.append (secondLetter).append (firstLetter);
            }
            sb.append (word.substring (2));
        }
        if (delimiterIndex < delimiters.length) {
            while (delimiters [delimiterIndex].isEmpty ()) {
                delimiterIndex ++;
            }
            sb.append (delimiters [delimiterIndex ++]);
        }
    }
    data = sb.toString ();
    System.out.println (data);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31793561_31794055_4_14
31793561_31795141_3_19
Title: Recursive string comparison 
----------------------------------------

public static int indexOf (String main, String check) {
    if (main.startsWith (check)) {
        return 0;
    } else if (main.length () < check.length ()) {
        return - 1;
    } else {
        int indexOf = indexOf (main.substring (1), check);
        return indexOf < 0 ? - 1 : 1 + indexOf;
    }

}
----------------------------------------

public static int indexOf (String main, String check) {
    int i = main.length ();
    for (int j = 0;
    j < i; j ++) {
        if (main.charAt (j) == check.charAt (0)) {
            if (check.length () > 1) {
                if (indexOf (main, check.substring (1)) == j + 1) {
                    return j;
                }
            } else {
                return j;
            }
        }
    }
    return - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31795496_41802482_139_146
31795496_41802482_3_54
Title: What is the proper way to handle subscriptions in RxJava/RxAndroid for an Activity Lifecycle? 
----------------------------------------

private static < R, T > Observable.Transformer < R, R > subscribeUtilEvent (final Observable < T > source, final T event, final Action0 doOnComplete) {
    return new Observable.Transformer < R, R > () {
        @Override
        public Observable < R > call (Observable < R > rObservable) {
            return rObservable.takeUntil (takeUntilEvent (source, event)).doOnCompleted (doOnComplete);
        }}

    ;
}
----------------------------------------

public static < R > Observable.Transformer < R, R > subscribeUtilEvent (final Activity target, LifecycleEvent event) {
    final Application app = target.getApplication ();
    final PublishSubject < LifecycleEvent > publishSubject = PublishSubject.create ();
    final Application.ActivityLifecycleCallbacks callbacks = new Application.ActivityLifecycleCallbacks () {
        @Override
        public void onActivityCreated (Activity activity, Bundle savedInstanceState) {
        }@Override
        public void onActivityStarted (Activity activity) {
        }@Override
        public void onActivityResumed (Activity activity) {
        }@Override
        public void onActivityPaused (Activity activity) {
            if (activity == target) publishSubject.onNext (LifecycleEvent.ON_PAUSED);

        }@Override
        public void onActivityStopped (Activity activity) {
            if (activity == target) publishSubject.onNext (LifecycleEvent.ON_STOPPED);

        }@Override
        public void onActivitySaveInstanceState (Activity activity, Bundle outState) {
            if (activity == target) publishSubject.onNext (LifecycleEvent.ON_SAVE_INSTANCE_STATE);

        }@Override
        public void onActivityDestroyed (Activity activity) {
            if (activity == target) publishSubject.onNext (LifecycleEvent.ON_DESTROYED);

        }}

    ;
    app.registerActivityLifecycleCallbacks (callbacks);
    return subscribeUtilEvent (publishSubject, event, new Action0 () {
        @Override
        public void call () {
            app.unregisterActivityLifecycleCallbacks (callbacks);
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31795496_41802482_139_146
31795496_41802482_56_137
Title: What is the proper way to handle subscriptions in RxJava/RxAndroid for an Activity Lifecycle? 
----------------------------------------

private static < R, T > Observable.Transformer < R, R > subscribeUtilEvent (final Observable < T > source, final T event, final Action0 doOnComplete) {
    return new Observable.Transformer < R, R > () {
        @Override
        public Observable < R > call (Observable < R > rObservable) {
            return rObservable.takeUntil (takeUntilEvent (source, event)).doOnCompleted (doOnComplete);
        }}

    ;
}
----------------------------------------

public static < R > Observable.Transformer < R, R > subscribeUtilEvent (final Fragment target, LifecycleEvent event) {
    final FragmentManager manager = target.getFragmentManager ();
    if (manager == null) {
        throw new NullPointerException ("fragment manager is null!");
    }
    final PublishSubject < LifecycleEvent > publishSubject = PublishSubject.create ();
    final FragmentManager.FragmentLifecycleCallbacks callbacks = manager.new FragmentLifecycleCallbacks () {
        @Override
        public void onFragmentPreAttached (FragmentManager fm, Fragment f, Context context) {
        }@Override
        public void onFragmentAttached (FragmentManager fm, Fragment f, Context context) {
        }@Override
        public void onFragmentCreated (FragmentManager fm, Fragment f, Bundle savedInstanceState) {
        }@Override
        public void onFragmentActivityCreated (FragmentManager fm, Fragment f, Bundle savedInstanceState) {
        }@Override
        public void onFragmentViewCreated (FragmentManager fm, Fragment f, View v, Bundle savedInstanceState) {
        }@Override
        public void onFragmentStarted (FragmentManager fm, Fragment f) {
        }@Override
        public void onFragmentResumed (FragmentManager fm, Fragment f) {
        }@Override
        public void onFragmentPaused (FragmentManager fm, Fragment f) {
            if (f == target) publishSubject.onNext (LifecycleEvent.ON_PAUSED);

        }@Override
        public void onFragmentStopped (FragmentManager fm, Fragment f) {
            if (f == target) publishSubject.onNext (LifecycleEvent.ON_STOPPED);

        }@Override
        public void onFragmentSaveInstanceState (FragmentManager fm, Fragment f, Bundle outState) {
            if (f == target) publishSubject.onNext (LifecycleEvent.ON_SAVE_INSTANCE_STATE);

        }@Override
        public void onFragmentViewDestroyed (FragmentManager fm, Fragment f) {
            if (f == target) publishSubject.onNext (LifecycleEvent.ON_VIEW_DESTORYED);

        }@Override
        public void onFragmentDestroyed (FragmentManager fm, Fragment f) {
            if (f == target) publishSubject.onNext (LifecycleEvent.ON_DESTROYED);

        }@Override
        public void onFragmentDetached (FragmentManager fm, Fragment f) {
            if (f == target) publishSubject.onNext (LifecycleEvent.ON_DESTROYED);

        }}

    ;
    manager.registerFragmentLifecycleCallbacks (callbacks, true);
    return subscribeUtilEvent (publishSubject, event, new Action0 () {
        @Override
        public void call () {
            manager.unregisterFragmentLifecycleCallbacks (callbacks);
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31795496_41802482_3_54
31795496_41802482_56_137
Title: What is the proper way to handle subscriptions in RxJava/RxAndroid for an Activity Lifecycle? 
----------------------------------------

public static < R > Observable.Transformer < R, R > subscribeUtilEvent (final Activity target, LifecycleEvent event) {
    final Application app = target.getApplication ();
    final PublishSubject < LifecycleEvent > publishSubject = PublishSubject.create ();
    final Application.ActivityLifecycleCallbacks callbacks = new Application.ActivityLifecycleCallbacks () {
        @Override
        public void onActivityCreated (Activity activity, Bundle savedInstanceState) {
        }@Override
        public void onActivityStarted (Activity activity) {
        }@Override
        public void onActivityResumed (Activity activity) {
        }@Override
        public void onActivityPaused (Activity activity) {
            if (activity == target) publishSubject.onNext (LifecycleEvent.ON_PAUSED);

        }@Override
        public void onActivityStopped (Activity activity) {
            if (activity == target) publishSubject.onNext (LifecycleEvent.ON_STOPPED);

        }@Override
        public void onActivitySaveInstanceState (Activity activity, Bundle outState) {
            if (activity == target) publishSubject.onNext (LifecycleEvent.ON_SAVE_INSTANCE_STATE);

        }@Override
        public void onActivityDestroyed (Activity activity) {
            if (activity == target) publishSubject.onNext (LifecycleEvent.ON_DESTROYED);

        }}

    ;
    app.registerActivityLifecycleCallbacks (callbacks);
    return subscribeUtilEvent (publishSubject, event, new Action0 () {
        @Override
        public void call () {
            app.unregisterActivityLifecycleCallbacks (callbacks);
        }}

    );
}
----------------------------------------

public static < R > Observable.Transformer < R, R > subscribeUtilEvent (final Fragment target, LifecycleEvent event) {
    final FragmentManager manager = target.getFragmentManager ();
    if (manager == null) {
        throw new NullPointerException ("fragment manager is null!");
    }
    final PublishSubject < LifecycleEvent > publishSubject = PublishSubject.create ();
    final FragmentManager.FragmentLifecycleCallbacks callbacks = manager.new FragmentLifecycleCallbacks () {
        @Override
        public void onFragmentPreAttached (FragmentManager fm, Fragment f, Context context) {
        }@Override
        public void onFragmentAttached (FragmentManager fm, Fragment f, Context context) {
        }@Override
        public void onFragmentCreated (FragmentManager fm, Fragment f, Bundle savedInstanceState) {
        }@Override
        public void onFragmentActivityCreated (FragmentManager fm, Fragment f, Bundle savedInstanceState) {
        }@Override
        public void onFragmentViewCreated (FragmentManager fm, Fragment f, View v, Bundle savedInstanceState) {
        }@Override
        public void onFragmentStarted (FragmentManager fm, Fragment f) {
        }@Override
        public void onFragmentResumed (FragmentManager fm, Fragment f) {
        }@Override
        public void onFragmentPaused (FragmentManager fm, Fragment f) {
            if (f == target) publishSubject.onNext (LifecycleEvent.ON_PAUSED);

        }@Override
        public void onFragmentStopped (FragmentManager fm, Fragment f) {
            if (f == target) publishSubject.onNext (LifecycleEvent.ON_STOPPED);

        }@Override
        public void onFragmentSaveInstanceState (FragmentManager fm, Fragment f, Bundle outState) {
            if (f == target) publishSubject.onNext (LifecycleEvent.ON_SAVE_INSTANCE_STATE);

        }@Override
        public void onFragmentViewDestroyed (FragmentManager fm, Fragment f) {
            if (f == target) publishSubject.onNext (LifecycleEvent.ON_VIEW_DESTORYED);

        }@Override
        public void onFragmentDestroyed (FragmentManager fm, Fragment f) {
            if (f == target) publishSubject.onNext (LifecycleEvent.ON_DESTROYED);

        }@Override
        public void onFragmentDetached (FragmentManager fm, Fragment f) {
            if (f == target) publishSubject.onNext (LifecycleEvent.ON_DESTROYED);

        }}

    ;
    manager.registerFragmentLifecycleCallbacks (callbacks, true);
    return subscribeUtilEvent (publishSubject, event, new Action0 () {
        @Override
        public void call () {
            manager.unregisterFragmentLifecycleCallbacks (callbacks);
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31795709_31796178_1_25
31795709_31800847_1_25
Title: How to fix int initialization issues in a method that returns an int 
----------------------------------------

public static int getRow (char r) {
    int row;
    if (r == '0') row = 0;

    if (r == '1') row = 1;

    if (r == '2') row = 2;

    if (r == '3') row = 3;

    if (r == '4') row = 4;

    if (r == '5') row = 5;

    if (r == '6') row = 6;

    if (r == '7') row = 7;

    if (r == '8') row = 8;

    if (r == '9') row = 9;

    return row;
}
----------------------------------------

public static int getRow (char r) {
    int row = - 1;
    if (r == 0) row = 0;

    if (r == 1) row = 1;

    if (r == 2) row = 2;

    if (r == 3) row = 3;

    if (r == 4) row = 4;

    if (r == 5) row = 5;

    if (r == 6) row = 6;

    if (r == 7) row = 7;

    if (r == 8) row = 8;

    if (r == 9) row = 9;

    return row;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3179733_3179982_5_19
3179733_4730500_83_93
Title: ThreadFactory usage in Java 
----------------------------------------

public Thread newThread (Runnable r) {
    Thread t = new Thread (r);
    t.setUncaughtExceptionHandler (new Thread.UncaughtExceptionHandler () {
        @Override
        public void uncaughtException (Thread t, Throwable e) {
            LoggerFactory.getLogger (t.getName ()).error (e.getMessage (), e);
        }}

    );
    return t;
}
----------------------------------------

public Thread newThread (Runnable r) {
    configured = true;
    final Thread t = new Thread (group, wrapRunnable (r), composeName (r), stackSize);
    t.setPriority (priority);
    t.setDaemon (daemon);
    t.setUncaughtExceptionHandler (exceptionHandler);
    applyCCL (t);
    return t;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31797398_31797487_20_28
31797398_31797496_31_41
Title: Checking if number already exists 
----------------------------------------

public void genNumber (int high, int low) {
    x = random.nextInt (high - low) + low;
    if (! arl.contains (x)) {
        System.out.println (x);
        arl.add (x);
    } else {
        System.out.println ("This is already in ArrayList");
    }
}
----------------------------------------

public void genNumber (int high, int low) {
    x = random.nextInt (high - low) + low;
    if (! arl.contains (x)) {
        System.out.println (x);
        arl.add (x);
    } else if (arl.contains (x)) {
        System.out.println ("This is already in ArrayList");
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31804193_31804269_1_36
31804193_31804312_19_52
Title: Multi listView android 
----------------------------------------

@Override
public View getView (int position, View convertView, ViewGroup parent) {
    ViewHolder holder;
    if (convertView == null) {
        holder = new ViewHolder ();
        Log.d ("object.get(position) = ", object.get (position));
        if (object.get (position).equals ("0")) {
            convertView = vi.inflate (R.layout.p_activity_detected, null);
            holder.textActivity = (TextView) convertView.findViewById (R.id.detected_text);
        } else if (object.get (position).equals ("1")) {
            convertView = vi.inflate (R.layout.p_activity_people, null);
            holder.textPeople = (TextView) convertView.findViewById (R.id.people_text);
        } else {
        }

        convertView.setTag (holder);
    } else {
        holder = (ViewHolder) convertView.getTag ();
    }
    if (object.get (position).getType ().equals ("0")) {
        holder.textActivity.setText (object.get (position).getTitle ());
    }
    if (object.get (position).getType ().equals ("1")) {
        holder.textPeople.setText (object.get (position).getTitle ());
    }
    return convertView;
}
----------------------------------------

public View getView (int position, View convertView, ViewGroup parent) {
    holder = new ViewHolder ();
    if (convertView == null) {
        if (object.get (position).equals ("0")) {
            convertView = vi.inflate (R.layout.p_activity_detected, null);
            holder.textActivity = (TextView) convertView.findViewById (R.id.detected_text);
        }
        if (object.get (position).equals ("1")) {
            convertView = vi.inflate (R.layout.p_activity_people, null);
            holder.textPeople = (TextView) convertView.findViewById (R.id.people_text);
        }
        convertView.setTag (holder);
    } else {
        holder = (ViewHolder) convertView.getTag ();
    }
    if (object.get (position).getType ().equals ("0")) {
        holder.textActivity.setText (object.get (position).getTitle ());
    }
    if (object.get (position).getType ().equals ("1")) {
        holder.textPeople.setText (object.get (position).getTitle ());
    }
    return convertView;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31821478_31821591_61_70
31821478_31821648_1_20
Title: How to create function that converts both List<List<Integer>> and List<List<Double>> (possibly more) to string? 
----------------------------------------

public static String prt (List < ? extends List < ? extends Number > > something) {
    NumberFormat nf = NumberFormat.getNumberInstance ();
    StringBuilder sb = new StringBuilder ();
    sb.append (nf.format (something.size ())).append (": {");
    for (int i = 0;
    i < something.size () - 1; i ++) {
        sb.append (prtx (something.get (i))).append (", ");
    }
    sb.append (prtx (something.get (something.size () - 1))).append ("}");
    return sb.toString ();
}
----------------------------------------

public static String prt (List < ? extends List < ? > > something) {
    StringBuilder sb = new StringBuilder ();
    sb.append (something.size () + ": {");
    for (int i = 0;
    i < something.size (); i ++) {
        List < ? > subList = (List < ? >) something.get (i);
        sb.append (subList.size () + ": {");
        for (int j = 0;
        j < subList.size () - 1; j ++) {
            sb.append (subList.get (j) + ", ");
        }
        sb.append (subList.get (subList.size () - 1) + "}");
        if (i != something.size () - 1) {
            sb.append (", ");
        } else {
            sb.append (" }");
        }
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31822595_31823375_10_25
31822595_31834106_4_24
Title: How to create a partial border(with a hole)? 
----------------------------------------

public void start (Stage primaryStage) {
    AnchorPane pane = new AnchorPane ();
    Label label = new Label ("Border with gap");
    AnchorPane.setTopAnchor (label, 50.0);
    AnchorPane.setLeftAnchor (label, 50.0);
    pane.getChildren ().add (label);
    pane.setStyle ("-fx-background-color: blue, -fx-background, -fx-background;" + "-fx-background-insets: 0, 0 50 2 100, 2;");
    Scene scene = new Scene (pane, 600, 600);
    primaryStage.setScene (scene);
    primaryStage.show ();
}
----------------------------------------

public void start (Stage primaryStage) throws Exception {
    Pane g = new Pane ();
    g.setBackground (new Background (new BackgroundFill (Color.YELLOW, null, null)));
    g.relocate (20, 20);
    BorderStroke bs = new BorderStroke (Color.RED, Color.RED, Color.RED, Color.RED, BorderStrokeStyle.SOLID, BorderStrokeStyle.SOLID, BorderStrokeStyle.SOLID, BorderStrokeStyle.SOLID, null, BorderStroke.THIN, null);
    g.setBorder (new Border (bs));
    Path p = new Path ();
    p.getElements ().addAll (new MoveTo (1, 0), new HLineTo (0), new VLineTo (4), new HLineTo (4), new VLineTo (0), new HLineTo (3));
    g.setShape (p);
    g.setPrefSize (300, 300);
    primaryStage.setScene (new Scene (new Group (g), 500, 500));
    primaryStage.show ();
    g.setPrefSize (400, 400);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31823142_31823359_45_72
31823142_31824999_6_18
Title: "Java: Is there any way to implement shift on a boolean array? If so how would I go about doing this?" 
----------------------------------------

public static void main (String [] args) {
    int c = 1;
    System.out.println (Integer.toBinaryString (c));
    c <<= 1;
    System.out.println (Integer.toBinaryString (c));
    c = 1;
    System.out.println (Integer.toBinaryString (c));
    c>>= 1;
    System.out.println (Integer.toBinaryString (c));
    System.out.println ("==========");
    Boolean [] cArr = {true};
    BooleanArray arr = new BooleanArray (cArr);
    System.out.println (arr.toString ());
    arr.shiftLeft (1);
    System.out.println (arr.toString ());
    arr = new BooleanArray (cArr);
    System.out.println (arr.toString ());
    arr.shiftRight (1);
    System.out.println (arr.toString ());
}
----------------------------------------

public static void main (String [] args) {
    boolean [] x = new boolean [] {true, true, true, true, true};
    for (int i = 0;
    i <= x.length; i ++) {
        boolean [] result = shiftRight (x, i);
        System.out.print (i + " ");
        printBooleanArray (result);
    }
    for (int i = 0;
    i <= x.length; i ++) {
        boolean [] result = shiftLeft (x, i);
        System.out.print (i + " ");
        printBooleanArray (result);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31834786_31835070_1_18
31834786_31850075_1_31
Title: Move elements N steps to the left (challenge) 
----------------------------------------

public static void moveNulls (Object [] arr, int howMany) {
    int offset = arr.length;
    int nullCount = 0;
    while (nullCount < howMany) {
        if (arr [-- offset] == null) nullCount ++;

        if (offset == 0 && nullCount < howMany) throw new IllegalStateException ("Not enough nulls");

    }
    int target = offset;
    while (offset < arr.length) {
        if (arr [offset] != null) arr [target ++] = arr [offset ++];
        else offset ++;

    }
    Arrays.fill (arr, target, offset, null);
}
----------------------------------------

void moveNulls (Object [] data, int howMany) {
    if (howMany == 0) return;

    Object [] buffer = new Object [howMany * 2];
    int b_getIndex = 0;
    int b_setIndex = howMany;
    int nullCount = 0;
    for (int i = data.length - 1;
    i >= howMany; i --) {
        if (data [i] == null) {
            nullCount ++;
        } else {
            buffer [b_setIndex] = data [i];
            b_setIndex ++;
        }
        data [i] = buffer [b_getIndex];
        b_getIndex ++;
        if (b_setIndex == buffer.length) b_setIndex = 0;

        if (b_getIndex == buffer.length) b_getIndex = 0;

        if (nullCount == howMany) break;

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31838896_33876734_1_22
31838896_41155293_1_40
Title: "Return the string that is between the first and last appearance of ""bread"" in the given string" 
----------------------------------------

public String getSandwich (String str) {
    int l = str.length ();
    int [] b;
    int count = 0;
    b = new int [2];
    if (l < 10) return "";

    for (int i = 0;
    i < l - 4; i ++) {
        if (str.substring (i, i + 5).equals ("bread")) {
            if (count == 2) count = 1;

            b [count] = i;
            count ++;
        }
    }
    if (count == 2) {
        return str.substring (b [0] + 5, b [1]);
    }
    return "";
}
----------------------------------------

public String getSandwich (String str) {
    if (str.length () >= 11) {
        String toTest = "bread";
        String ret = "";
        int counter = 0;
        int wordStart = 0;
        int wordEnd = 0;
        for (int i = 5;
        i < str.length (); i ++) {
            if (str.substring (i - 5, i).equals (toTest)) {
                wordStart = i;
                for (int j = 5;
                j < str.length (); j ++) {
                    if (str.substring (str.length () - j, str.length () - j + 5).equals (toTest)) {
                        wordEnd = str.length () - j;
                        break;
                    }
                }
                break;
            }
        }
        ret = str.substring (wordStart, wordEnd);
        return ret;
    } else {
        return "";
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31838896_33876734_1_22
31838896_41939244_1_19
Title: "Return the string that is between the first and last appearance of ""bread"" in the given string" 
----------------------------------------

public String getSandwich (String str) {
    int l = str.length ();
    int [] b;
    int count = 0;
    b = new int [2];
    if (l < 10) return "";

    for (int i = 0;
    i < l - 4; i ++) {
        if (str.substring (i, i + 5).equals ("bread")) {
            if (count == 2) count = 1;

            b [count] = i;
            count ++;
        }
    }
    if (count == 2) {
        return str.substring (b [0] + 5, b [1]);
    }
    return "";
}
----------------------------------------

public String getSandwich (String str) {
    int beforestf = 0;
    int endstf = 0;
    String stf;
    for (int i = 0;
    i <= str.length () - 5; i ++) {
        if (str.substring (i, i + 5).equals ("bread")) {
            endstf = i;
        }
    }
    for (int j = str.length ();
    j >= 5; j --) {
        if (str.substring (j - 5, j).equals ("bread")) {
            beforestf = j;
        }
    }
    if ((endstf >= 5)) stf = str.substring (beforestf, endstf);
    else stf = "";

    return stf;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31838896_33876734_1_22
31838896_48638243_1_12
Title: "Return the string that is between the first and last appearance of ""bread"" in the given string" 
----------------------------------------

public String getSandwich (String str) {
    int l = str.length ();
    int [] b;
    int count = 0;
    b = new int [2];
    if (l < 10) return "";

    for (int i = 0;
    i < l - 4; i ++) {
        if (str.substring (i, i + 5).equals ("bread")) {
            if (count == 2) count = 1;

            b [count] = i;
            count ++;
        }
    }
    if (count == 2) {
        return str.substring (b [0] + 5, b [1]);
    }
    return "";
}
----------------------------------------

public String getSandwich (String str) {
    int bread1 = str.indexOf ("bread");
    int bread2 = 0;
    for (int i = str.length () - 1;
    i >= 0; i --) {
        if (str.charAt (i) == 'd' && str.charAt (i - 1) == 'a' && str.charAt (i - 2) == 'e' && str.charAt (i - 3) == 'r' && str.charAt (i - 4) == 'b') {
            bread2 = i - 4;
            if (bread1 != bread2) return str.substring (bread1 + 5, bread2);

        }
    }
    return "";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31838896_33876734_1_22
31838896_48937339_1_11
Title: "Return the string that is between the first and last appearance of ""bread"" in the given string" 
----------------------------------------

public String getSandwich (String str) {
    int l = str.length ();
    int [] b;
    int count = 0;
    b = new int [2];
    if (l < 10) return "";

    for (int i = 0;
    i < l - 4; i ++) {
        if (str.substring (i, i + 5).equals ("bread")) {
            if (count == 2) count = 1;

            b [count] = i;
            count ++;
        }
    }
    if (count == 2) {
        return str.substring (b [0] + 5, b [1]);
    }
    return "";
}
----------------------------------------

public String getSandwich (String str) {
    String bread = "bread";
    int lIndex = str.indexOf (bread);
    int rIndex = str.lastIndexOf (bread);
    if (lIndex != - 1 && rIndex != lIndex) {
        return str.substring (lIndex + bread.length (), rIndex);
    }
    return "";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31838896_33876734_1_22
31838896_52682535_1_14
Title: "Return the string that is between the first and last appearance of ""bread"" in the given string" 
----------------------------------------

public String getSandwich (String str) {
    int l = str.length ();
    int [] b;
    int count = 0;
    b = new int [2];
    if (l < 10) return "";

    for (int i = 0;
    i < l - 4; i ++) {
        if (str.substring (i, i + 5).equals ("bread")) {
            if (count == 2) count = 1;

            b [count] = i;
            count ++;
        }
    }
    if (count == 2) {
        return str.substring (b [0] + 5, b [1]);
    }
    return "";
}
----------------------------------------

public String getSandwich (String str) {
    final String BREAD = "bread";
    if (str.length () < BREAD.length () * 2) {
        return "";
    }
    if (str.substring (0, BREAD.length ()).equals (BREAD) && str.substring (str.length () - BREAD.length ()).equals (BREAD)) {
        return str.substring (BREAD.length (), str.length () - BREAD.length ());
    }
    if (! str.substring (0, BREAD.length ()).equals (BREAD)) {
        return getSandwich (str.substring (1));
    }
    return getSandwich (str.substring (0, str.length () - 1));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31838896_41155293_1_40
31838896_41939244_1_19
Title: "Return the string that is between the first and last appearance of ""bread"" in the given string" 
----------------------------------------

public String getSandwich (String str) {
    if (str.length () >= 11) {
        String toTest = "bread";
        String ret = "";
        int counter = 0;
        int wordStart = 0;
        int wordEnd = 0;
        for (int i = 5;
        i < str.length (); i ++) {
            if (str.substring (i - 5, i).equals (toTest)) {
                wordStart = i;
                for (int j = 5;
                j < str.length (); j ++) {
                    if (str.substring (str.length () - j, str.length () - j + 5).equals (toTest)) {
                        wordEnd = str.length () - j;
                        break;
                    }
                }
                break;
            }
        }
        ret = str.substring (wordStart, wordEnd);
        return ret;
    } else {
        return "";
    }
}
----------------------------------------

public String getSandwich (String str) {
    int beforestf = 0;
    int endstf = 0;
    String stf;
    for (int i = 0;
    i <= str.length () - 5; i ++) {
        if (str.substring (i, i + 5).equals ("bread")) {
            endstf = i;
        }
    }
    for (int j = str.length ();
    j >= 5; j --) {
        if (str.substring (j - 5, j).equals ("bread")) {
            beforestf = j;
        }
    }
    if ((endstf >= 5)) stf = str.substring (beforestf, endstf);
    else stf = "";

    return stf;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31838896_41155293_1_40
31838896_48638243_1_12
Title: "Return the string that is between the first and last appearance of ""bread"" in the given string" 
----------------------------------------

public String getSandwich (String str) {
    if (str.length () >= 11) {
        String toTest = "bread";
        String ret = "";
        int counter = 0;
        int wordStart = 0;
        int wordEnd = 0;
        for (int i = 5;
        i < str.length (); i ++) {
            if (str.substring (i - 5, i).equals (toTest)) {
                wordStart = i;
                for (int j = 5;
                j < str.length (); j ++) {
                    if (str.substring (str.length () - j, str.length () - j + 5).equals (toTest)) {
                        wordEnd = str.length () - j;
                        break;
                    }
                }
                break;
            }
        }
        ret = str.substring (wordStart, wordEnd);
        return ret;
    } else {
        return "";
    }
}
----------------------------------------

public String getSandwich (String str) {
    int bread1 = str.indexOf ("bread");
    int bread2 = 0;
    for (int i = str.length () - 1;
    i >= 0; i --) {
        if (str.charAt (i) == 'd' && str.charAt (i - 1) == 'a' && str.charAt (i - 2) == 'e' && str.charAt (i - 3) == 'r' && str.charAt (i - 4) == 'b') {
            bread2 = i - 4;
            if (bread1 != bread2) return str.substring (bread1 + 5, bread2);

        }
    }
    return "";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31838896_41155293_1_40
31838896_48937339_1_11
Title: "Return the string that is between the first and last appearance of ""bread"" in the given string" 
----------------------------------------

public String getSandwich (String str) {
    if (str.length () >= 11) {
        String toTest = "bread";
        String ret = "";
        int counter = 0;
        int wordStart = 0;
        int wordEnd = 0;
        for (int i = 5;
        i < str.length (); i ++) {
            if (str.substring (i - 5, i).equals (toTest)) {
                wordStart = i;
                for (int j = 5;
                j < str.length (); j ++) {
                    if (str.substring (str.length () - j, str.length () - j + 5).equals (toTest)) {
                        wordEnd = str.length () - j;
                        break;
                    }
                }
                break;
            }
        }
        ret = str.substring (wordStart, wordEnd);
        return ret;
    } else {
        return "";
    }
}
----------------------------------------

public String getSandwich (String str) {
    String bread = "bread";
    int lIndex = str.indexOf (bread);
    int rIndex = str.lastIndexOf (bread);
    if (lIndex != - 1 && rIndex != lIndex) {
        return str.substring (lIndex + bread.length (), rIndex);
    }
    return "";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31838896_41155293_1_40
31838896_52682535_1_14
Title: "Return the string that is between the first and last appearance of ""bread"" in the given string" 
----------------------------------------

public String getSandwich (String str) {
    if (str.length () >= 11) {
        String toTest = "bread";
        String ret = "";
        int counter = 0;
        int wordStart = 0;
        int wordEnd = 0;
        for (int i = 5;
        i < str.length (); i ++) {
            if (str.substring (i - 5, i).equals (toTest)) {
                wordStart = i;
                for (int j = 5;
                j < str.length (); j ++) {
                    if (str.substring (str.length () - j, str.length () - j + 5).equals (toTest)) {
                        wordEnd = str.length () - j;
                        break;
                    }
                }
                break;
            }
        }
        ret = str.substring (wordStart, wordEnd);
        return ret;
    } else {
        return "";
    }
}
----------------------------------------

public String getSandwich (String str) {
    final String BREAD = "bread";
    if (str.length () < BREAD.length () * 2) {
        return "";
    }
    if (str.substring (0, BREAD.length ()).equals (BREAD) && str.substring (str.length () - BREAD.length ()).equals (BREAD)) {
        return str.substring (BREAD.length (), str.length () - BREAD.length ());
    }
    if (! str.substring (0, BREAD.length ()).equals (BREAD)) {
        return getSandwich (str.substring (1));
    }
    return getSandwich (str.substring (0, str.length () - 1));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31838896_41939244_1_19
31838896_48638243_1_12
Title: "Return the string that is between the first and last appearance of ""bread"" in the given string" 
----------------------------------------

public String getSandwich (String str) {
    int beforestf = 0;
    int endstf = 0;
    String stf;
    for (int i = 0;
    i <= str.length () - 5; i ++) {
        if (str.substring (i, i + 5).equals ("bread")) {
            endstf = i;
        }
    }
    for (int j = str.length ();
    j >= 5; j --) {
        if (str.substring (j - 5, j).equals ("bread")) {
            beforestf = j;
        }
    }
    if ((endstf >= 5)) stf = str.substring (beforestf, endstf);
    else stf = "";

    return stf;
}
----------------------------------------

public String getSandwich (String str) {
    int bread1 = str.indexOf ("bread");
    int bread2 = 0;
    for (int i = str.length () - 1;
    i >= 0; i --) {
        if (str.charAt (i) == 'd' && str.charAt (i - 1) == 'a' && str.charAt (i - 2) == 'e' && str.charAt (i - 3) == 'r' && str.charAt (i - 4) == 'b') {
            bread2 = i - 4;
            if (bread1 != bread2) return str.substring (bread1 + 5, bread2);

        }
    }
    return "";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31838896_41939244_1_19
31838896_48937339_1_11
Title: "Return the string that is between the first and last appearance of ""bread"" in the given string" 
----------------------------------------

public String getSandwich (String str) {
    int beforestf = 0;
    int endstf = 0;
    String stf;
    for (int i = 0;
    i <= str.length () - 5; i ++) {
        if (str.substring (i, i + 5).equals ("bread")) {
            endstf = i;
        }
    }
    for (int j = str.length ();
    j >= 5; j --) {
        if (str.substring (j - 5, j).equals ("bread")) {
            beforestf = j;
        }
    }
    if ((endstf >= 5)) stf = str.substring (beforestf, endstf);
    else stf = "";

    return stf;
}
----------------------------------------

public String getSandwich (String str) {
    String bread = "bread";
    int lIndex = str.indexOf (bread);
    int rIndex = str.lastIndexOf (bread);
    if (lIndex != - 1 && rIndex != lIndex) {
        return str.substring (lIndex + bread.length (), rIndex);
    }
    return "";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31838896_41939244_1_19
31838896_52682535_1_14
Title: "Return the string that is between the first and last appearance of ""bread"" in the given string" 
----------------------------------------

public String getSandwich (String str) {
    int beforestf = 0;
    int endstf = 0;
    String stf;
    for (int i = 0;
    i <= str.length () - 5; i ++) {
        if (str.substring (i, i + 5).equals ("bread")) {
            endstf = i;
        }
    }
    for (int j = str.length ();
    j >= 5; j --) {
        if (str.substring (j - 5, j).equals ("bread")) {
            beforestf = j;
        }
    }
    if ((endstf >= 5)) stf = str.substring (beforestf, endstf);
    else stf = "";

    return stf;
}
----------------------------------------

public String getSandwich (String str) {
    final String BREAD = "bread";
    if (str.length () < BREAD.length () * 2) {
        return "";
    }
    if (str.substring (0, BREAD.length ()).equals (BREAD) && str.substring (str.length () - BREAD.length ()).equals (BREAD)) {
        return str.substring (BREAD.length (), str.length () - BREAD.length ());
    }
    if (! str.substring (0, BREAD.length ()).equals (BREAD)) {
        return getSandwich (str.substring (1));
    }
    return getSandwich (str.substring (0, str.length () - 1));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31838896_48638243_1_12
31838896_48937339_1_11
Title: "Return the string that is between the first and last appearance of ""bread"" in the given string" 
----------------------------------------

public String getSandwich (String str) {
    int bread1 = str.indexOf ("bread");
    int bread2 = 0;
    for (int i = str.length () - 1;
    i >= 0; i --) {
        if (str.charAt (i) == 'd' && str.charAt (i - 1) == 'a' && str.charAt (i - 2) == 'e' && str.charAt (i - 3) == 'r' && str.charAt (i - 4) == 'b') {
            bread2 = i - 4;
            if (bread1 != bread2) return str.substring (bread1 + 5, bread2);

        }
    }
    return "";
}
----------------------------------------

public String getSandwich (String str) {
    String bread = "bread";
    int lIndex = str.indexOf (bread);
    int rIndex = str.lastIndexOf (bread);
    if (lIndex != - 1 && rIndex != lIndex) {
        return str.substring (lIndex + bread.length (), rIndex);
    }
    return "";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31838896_48638243_1_12
31838896_52682535_1_14
Title: "Return the string that is between the first and last appearance of ""bread"" in the given string" 
----------------------------------------

public String getSandwich (String str) {
    int bread1 = str.indexOf ("bread");
    int bread2 = 0;
    for (int i = str.length () - 1;
    i >= 0; i --) {
        if (str.charAt (i) == 'd' && str.charAt (i - 1) == 'a' && str.charAt (i - 2) == 'e' && str.charAt (i - 3) == 'r' && str.charAt (i - 4) == 'b') {
            bread2 = i - 4;
            if (bread1 != bread2) return str.substring (bread1 + 5, bread2);

        }
    }
    return "";
}
----------------------------------------

public String getSandwich (String str) {
    final String BREAD = "bread";
    if (str.length () < BREAD.length () * 2) {
        return "";
    }
    if (str.substring (0, BREAD.length ()).equals (BREAD) && str.substring (str.length () - BREAD.length ()).equals (BREAD)) {
        return str.substring (BREAD.length (), str.length () - BREAD.length ());
    }
    if (! str.substring (0, BREAD.length ()).equals (BREAD)) {
        return getSandwich (str.substring (1));
    }
    return getSandwich (str.substring (0, str.length () - 1));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31838896_48937339_1_11
31838896_52682535_1_14
Title: "Return the string that is between the first and last appearance of ""bread"" in the given string" 
----------------------------------------

public String getSandwich (String str) {
    String bread = "bread";
    int lIndex = str.indexOf (bread);
    int rIndex = str.lastIndexOf (bread);
    if (lIndex != - 1 && rIndex != lIndex) {
        return str.substring (lIndex + bread.length (), rIndex);
    }
    return "";
}
----------------------------------------

public String getSandwich (String str) {
    final String BREAD = "bread";
    if (str.length () < BREAD.length () * 2) {
        return "";
    }
    if (str.substring (0, BREAD.length ()).equals (BREAD) && str.substring (str.length () - BREAD.length ()).equals (BREAD)) {
        return str.substring (BREAD.length (), str.length () - BREAD.length ());
    }
    if (! str.substring (0, BREAD.length ()).equals (BREAD)) {
        return getSandwich (str.substring (1));
    }
    return getSandwich (str.substring (0, str.length () - 1));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31840211_31840919_3_12
31840211_31841111_2_18
Title: How do I split/parse this String properly using Regex 
----------------------------------------

public static void main (String [] args) {
    String s = "cats|1|short hair and long hair\ncats|2|black, blue\ndogs|1|cats are better than dogs";
    String [] sa1 = s.split ("\n");
    for (int i = 0;
    i < sa1.length; i ++) {
        String [] sa2 = sa1 [i].split ("\\|");
        System.out.printf ("key=%s, value=%s\n", sa2 [0], sa2 [2]);
    }
}
----------------------------------------

public static void main (String [] args) {
    String data = "cats|1|short hair and long hair\n" + "cats|2|black, blue\n" + "dogs|1|cats are better than dogs";
    List < String > result1 = new ArrayList < > ();
    List < String > result2 = new ArrayList < > ();
    Pattern pattern = Pattern.compile ("(.+)\\|\\d+\\|(.+)");
    Matcher m = pattern.matcher (data);
    while (m.find ()) {
        String key = m.group (1);
        String value = m.group (2);
        result1.add (key);
        result2.add (value);
        System.out.printf ("key=%s, value=%s\n", key, value);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31840211_31840919_3_12
31840211_31841728_6_38
Title: How do I split/parse this String properly using Regex 
----------------------------------------

public static void main (String [] args) {
    String s = "cats|1|short hair and long hair\ncats|2|black, blue\ndogs|1|cats are better than dogs";
    String [] sa1 = s.split ("\n");
    for (int i = 0;
    i < sa1.length; i ++) {
        String [] sa2 = sa1 [i].split ("\\|");
        System.out.printf ("key=%s, value=%s\n", sa2 [0], sa2 [2]);
    }
}
----------------------------------------

public static void main (String [] args) {
    String [] text = {"cats|1|short hair and long hair", "cats|2|black, blue", "dogs|1|cats are better than dogs"};
    ArrayList < String > arrayOne = new ArrayList < String > ();
    ArrayList < String > arrayTwo = new ArrayList < String > ();
    for (String s : text) {
        String [] tokens = s.split ("\\|");
        int tokenType = 0;
        for (String token : tokens) {
            switch (tokenType) {
                case SENTENCE1_TOKEN_INDEX :
                    arrayOne.add (token);
                    break;
                case SENTENCE2_TOKEN_INDEX :
                    arrayTwo.add (token);
                    break;
            }
            ++ tokenType;
        }
    }
    System.out.println ("Sentences for first token: " + arrayOne);
    System.out.println ("Sentences for third token: " + arrayTwo);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31840211_31841111_2_18
31840211_31841728_6_38
Title: How do I split/parse this String properly using Regex 
----------------------------------------

public static void main (String [] args) {
    String data = "cats|1|short hair and long hair\n" + "cats|2|black, blue\n" + "dogs|1|cats are better than dogs";
    List < String > result1 = new ArrayList < > ();
    List < String > result2 = new ArrayList < > ();
    Pattern pattern = Pattern.compile ("(.+)\\|\\d+\\|(.+)");
    Matcher m = pattern.matcher (data);
    while (m.find ()) {
        String key = m.group (1);
        String value = m.group (2);
        result1.add (key);
        result2.add (value);
        System.out.printf ("key=%s, value=%s\n", key, value);
    }
}
----------------------------------------

public static void main (String [] args) {
    String [] text = {"cats|1|short hair and long hair", "cats|2|black, blue", "dogs|1|cats are better than dogs"};
    ArrayList < String > arrayOne = new ArrayList < String > ();
    ArrayList < String > arrayTwo = new ArrayList < String > ();
    for (String s : text) {
        String [] tokens = s.split ("\\|");
        int tokenType = 0;
        for (String token : tokens) {
            switch (tokenType) {
                case SENTENCE1_TOKEN_INDEX :
                    arrayOne.add (token);
                    break;
                case SENTENCE2_TOKEN_INDEX :
                    arrayTwo.add (token);
                    break;
            }
            ++ tokenType;
        }
    }
    System.out.println ("Sentences for first token: " + arrayOne);
    System.out.println ("Sentences for third token: " + arrayTwo);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31840381_31840782_1_24
31840381_31841640_1_23
Title: Find the longest sequence of same characters in a string 
----------------------------------------

public static int runLongestIndex (String setofletters) {
    int ctr = 1;
    int ctrstor = 0;
    int ii = 0;
    int output = 0;
    for (int i = 0;
    i < setofletters.length () - 1; i ++) {
        if (i < setofletters.length () - 1 && setofletters.charAt (i) == setofletters.charAt (i + 1)) {
            ctr ++;
            ii = i + 1;
            while (setofletters.charAt (i) == setofletters.charAt (ii)) {
                ii ++;
                ctr ++;
            }
            if (ctr > ctrstor) {
                output = i;
            }
            ctrstor = ctr;
        }
        ctr = 1;
    }
    return output;
}
----------------------------------------

public static int runLongestIndex (String setofletters) {
    int maxCount = 0;
    int maxIndex = 0;
    for (int i = 0;
    i < setofletters.length () - 1;) {
        char currChar = setofletters.charAt (i);
        int count = 1;
        int index = i;
        while ((index < setofletters.length () - 1) && (currChar == setofletters.charAt (++ index))) {
            count ++;
        }
        if (count > maxCount) {
            maxIndex = i;
            maxCount = count;
        }
        i = index;
    }
    return maxIndex;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31840381_31840782_1_24
31840381_33795573_1_34
Title: Find the longest sequence of same characters in a string 
----------------------------------------

public static int runLongestIndex (String setofletters) {
    int ctr = 1;
    int ctrstor = 0;
    int ii = 0;
    int output = 0;
    for (int i = 0;
    i < setofletters.length () - 1; i ++) {
        if (i < setofletters.length () - 1 && setofletters.charAt (i) == setofletters.charAt (i + 1)) {
            ctr ++;
            ii = i + 1;
            while (setofletters.charAt (i) == setofletters.charAt (ii)) {
                ii ++;
                ctr ++;
            }
            if (ctr > ctrstor) {
                output = i;
            }
            ctrstor = ctr;
        }
        ctr = 1;
    }
    return output;
}
----------------------------------------

public static int runLongestIndex (String setofletters) {
    if (setofletters == null || setofletters.isEmpty ()) {
        return - 1;
    }
    int cnt = 1;
    char prevC = setofletters.charAt (0);
    int maxCnt = 1;
    int maxRunIdx = 0;
    int curRunIdx = 0;
    for (int i = 1;
    i < setofletters.length (); i ++) {
        final char c = setofletters.charAt (i);
        if (prevC == c) {
            cnt ++;
        } else {
            if (cnt > maxCnt) {
                maxCnt = cnt;
                maxRunIdx = curRunIdx;
            }
            cnt = 1;
            curRunIdx = i;
        }
        prevC = c;
    }
    if (setofletters.charAt (setofletters.length () - 1) == prevC) {
        if (cnt > maxCnt) {
            maxCnt = cnt;
            maxRunIdx = curRunIdx;
        }
    }
    return maxRunIdx;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31840381_31841640_1_23
31840381_33795573_1_34
Title: Find the longest sequence of same characters in a string 
----------------------------------------

public static int runLongestIndex (String setofletters) {
    int maxCount = 0;
    int maxIndex = 0;
    for (int i = 0;
    i < setofletters.length () - 1;) {
        char currChar = setofletters.charAt (i);
        int count = 1;
        int index = i;
        while ((index < setofletters.length () - 1) && (currChar == setofletters.charAt (++ index))) {
            count ++;
        }
        if (count > maxCount) {
            maxIndex = i;
            maxCount = count;
        }
        i = index;
    }
    return maxIndex;
}
----------------------------------------

public static int runLongestIndex (String setofletters) {
    if (setofletters == null || setofletters.isEmpty ()) {
        return - 1;
    }
    int cnt = 1;
    char prevC = setofletters.charAt (0);
    int maxCnt = 1;
    int maxRunIdx = 0;
    int curRunIdx = 0;
    for (int i = 1;
    i < setofletters.length (); i ++) {
        final char c = setofletters.charAt (i);
        if (prevC == c) {
            cnt ++;
        } else {
            if (cnt > maxCnt) {
                maxCnt = cnt;
                maxRunIdx = curRunIdx;
            }
            cnt = 1;
            curRunIdx = i;
        }
        prevC = c;
    }
    if (setofletters.charAt (setofletters.length () - 1) == prevC) {
        if (cnt > maxCnt) {
            maxCnt = cnt;
            maxRunIdx = curRunIdx;
        }
    }
    return maxRunIdx;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3185226_15405850_4_14
3185226_3185252_4_12
Title: Huge performance difference between Vector and HashSet 
----------------------------------------

public static void main (String [] args) {
    long start = System.currentTimeMillis ();
    Vector < String > vector = new Vector < String > ();
    for (int i = 0;
    i < 300000; i ++) {
        if (vector.contains (i)) {
            vector.add ("dummy value");
        }
    }
    long end = System.currentTimeMillis ();
    System.out.println ("Time taken: " + (end - start) + "ms");
}
----------------------------------------

public static void main (String [] args) {
    long start = System.currentTimeMillis ();
    Vector < String > vector = new Vector < String > ();
    for (int i = 0;
    i < 300000; i ++) {
        vector.add ("dummy value");
    }
    long end = System.currentTimeMillis ();
    System.out.println ("Time taken: " + (end - start) + "ms");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31854473_31854825_1_21
31854473_31855098_1_16
Title: Java - Return a list with recursion 
----------------------------------------

public List < Object > getChildrenTree (Object currentObject) {
    List < Object > returnList = new ArrayList < Object > ();
    List < Object > objectChildren = currentObject.getChildren ();
    for (Object childObj : objectChildren) {
        if (childObj != null) {
            returnList.add (childObj);
            if (! childObj.getChildren ().isEmpty ()) {
                returnList.addAll (getChildrenTree (childObj));
            }
        }
    }
    return returnList;
}
----------------------------------------

public List < Object > getChildrenTree (Object currentObject, List < Object > returnList) {
    returnList.add (currentObject);
    List < Object > objectChildren = currentObject.getChildren ();
    for (Obj childObj : objectChildren) {
        if (childObj != null) {
            if (childObj.getChildren ().size () > 0) {
                return getChildrenTree (childObj, returnList);
            }
        }
    }
    return returnList;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31854672_31854757_1_12
31854672_31854850_1_14
Title: Trouble with Scanner and looping in java 
----------------------------------------

public static void main (String [] args) {
    int i = 0;
    Scanner input = new Scanner (System.in);
    while (input.hasNext () && i < 1) {
        String nextLine = input.nextLine ();
        System.out.println (nextLine);
        if (nextLine.equals ("exit")) {
            i ++;
        }
    }
    input.close ();
}
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    String s;
    while (input.hasNext ()) {
        s = input.nextLine ();
        System.out.println (s);
        if (s.equals ("exit")) {
            break;
        }
    }
    input.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31855106_31855872_5_13
31855106_31855907_1_11
Title: Creating recursion in Java 
----------------------------------------

public static void recurse (String str, int n) {
    if (n >= str.length ()) {
        System.out.println (str);
    } else {
        recurse (str, n + 1);
        str = str.substring (0, n) + "." + str.substring (n);
        recurse (str, n + 2);
    }
}
----------------------------------------

public static void recurse (String pre, String str) {
    if (str.length () == 1) {
        System.out.println (pre + str);
        System.out.println (pre + " ." + str);
        return;
    }
    recurse (pre + str.substring (0, 1), str.substring (1));
    if (pre.length () > 0) recurse (pre + "." + str.substring (0, 1), str.substring (1));

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31868174_31911695_27_37
31868174_31911695_43_53
Title: Keeping and checking Process alive in Java 1.7 
----------------------------------------

public void run () {
    InputStream is = process.getInputStream ();
    int c;
    try {
        while ((c = is.read ()) >= 0) {
            s.write (c);
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public void run () {
    InputStream is = process.getErrorStream ();
    int c;
    try {
        while ((c = is.read ()) >= 0) {
            s.write (c);
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31869288_31869377_1_28
31869288_31869504_1_30
Title: Array size issue for converting String to Unicode 
----------------------------------------

public String toUnicode () {
    char unicodeTextArray [] = new char [text.length ()];
    if (text == null) {
        return "";
    }
    String unicodeTextArrayString [] = new String [text.length ()];
    StringBuilder unicode = new StringBuilder ();
    for (int i = 0;
    i < text.length (); i ++) {
        unicodeTextArray [i] = text.charAt (i);
        if (unicodeTextArray [i] < 0x10) {
            unicodeTextArrayString [i] = "\\u000" + Integer.toHexString (unicodeTextArray [i]);
        } else if (unicodeTextArray [i] < 0x100) {
            unicodeTextArrayString [i] = "\\u00" + Integer.toHexString (unicodeTextArray [i]);
        } else if (unicodeTextArray [i] < 0x1000) {
            unicodeTextArrayString [i] = "\\u0" + Integer.toHexString (unicodeTextArray [i]);
        } else unicodeTextArrayString [i] = "\\u" + Integer.toHexString (unicodeTextArray [i]);

        unicode = unicode.append (unicodeTextArrayString [i]);
    }
    return unicode.toString ();
}
----------------------------------------

public static String toUnicode (String text) {
    if (text == null || text.isEmpty ()) {
        return "";
    }
    StringBuilder unicodeTextArrayString = new StringBuilder ();
    for (int i = 0;
    i < text.length (); i ++) {
        char ch = text.charAt (i);
        if (ch < 0x10) {
            unicodeTextArrayString.append ("\\u000" + Integer.toHexString (ch));
        } else if (ch < 0x100) {
            unicodeTextArrayString.append ("\\u00" + Integer.toHexString (ch));
        } else if (ch < 0x1000) {
            unicodeTextArrayString.append ("\\u0" + Integer.toHexString (ch));
        } else {
            unicodeTextArrayString.append ("\\u" + Integer.toHexString (ch));
        }

    }
    return unicodeTextArrayString.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31871901_31871986_7_33
31871901_31872169_1_14
Title: How to iterate over array of integers to find a sequence based on an O(N) solution? 
----------------------------------------

public static boolean isValid (int [] array, int sum) {
    int start = 0;
    int stop = 0;
    int tsum = 0;
    while (true) {
        if (tsum < sum) {
            if (stop >= array.length) break;

            tsum += array [stop];
            stop ++;
        } else if (tsum > sum) {
            tsum -= array [start];
            start ++;
        } else if (tsum == sum) return true;

    }
    return false;
}
----------------------------------------

public static boolean isValid (int [] array, int sum) {
    int init = 0, temp = 0;
    for (int i = 0;
    i < array.length; i ++) {
        temp += array [i];
        while (temp > sum) {
            temp -= array [init];
            init ++;
        }
        if (temp == sum) return true;

    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31880253_31889008_27_54
31880253_31889008_56_94
Title: java add text inside circle image 
----------------------------------------

public void addText (Graphics2D g2, String string1, String string2) {
    int radius = 40;
    Point center = new Point (120, 120);
    double startDegAngle = 0, offsetAngle;
    double degIncrement = 15, strImageWidth, charWidth;
    boolean isInverted;
    Font font = new Font ("Serif", Font.PLAIN, 18);
    FontRenderContext frc = g2.getFontRenderContext ();
    charWidth = font.createGlyphVector (frc, "A").getGlyphOutline (0).getBounds2D ().getWidth ();
    offsetAngle = ((string1.length () * degIncrement) - (degIncrement)) / 2.0;
    startDegAngle = 0 - offsetAngle;
    isInverted = false;
    addText (g2, string1, font, radius, center, isInverted, startDegAngle, degIncrement);
    offsetAngle = ((string2.length () * degIncrement) - degIncrement) / 2.0;
    startDegAngle = 180 + offsetAngle;
    isInverted = true;
    addText (g2, string2, font, radius, center, isInverted, startDegAngle, degIncrement);
}
----------------------------------------

public void addText (Graphics2D g2, String text, Font font, int radius, Point center, boolean isInverted, double startDeg, double degIncrement) {
    AffineTransform at;
    double deg;
    deg = startDeg;
    FontRenderContext frc = g2.getFontRenderContext ();
    if (! isInverted) {
        radius -= font.createGlyphVector (frc, "A").getGlyphOutline (0).getBounds2D ().getHeight ();
    } else {
        degIncrement = 0 - degIncrement;
    }
    for (int i = 0;
    i < text.length (); i ++) {
        String s = "" + text.charAt (i);
        GlyphVector gv = font.createGlyphVector (frc, s);
        Shape glyph = gv.getGlyphOutline (0);
        double charImageCenterX = glyph.getBounds2D ().getCenterX ();
        double theta = Math.toRadians (deg);
        int xp = (int) Math.round (Math.sin (theta) * radius);
        int yp = (int) Math.round (Math.cos (theta) * radius);
        yp = 0 - yp;
        if (isInverted) at = new AffineTransform (- 1.0, 0.0, 0.0, - 1.0, center.x + xp, center.y + yp);
        else at = new AffineTransform (1.0, 0.0, 0.0, 1.0, center.x + xp, center.x + yp);

        at.rotate (theta);
        at.translate (0 - charImageCenterX, 0);
        Shape transformedGlyph = at.createTransformedShape (glyph);
        g2.fill (transformedGlyph);
        deg += degIncrement;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31890943_31890956_1_10
31890943_31891031_3_12
Title: getPackageManager() gives error when used in static class 
----------------------------------------

public String VersionInfo (final Context context) {
    String version = "";
    try {
        version = context.getPackageManager ().getPackageInfo (context.getPackageName (), 0).versionName;
    } catch (PackageManager.NameNotFoundException e) {
        Log.e ("tag", e.getMessage ());
    }
    return version;
}
----------------------------------------

public static String VersionInfo (Context ctx) {
    String version = "";
    try {
        version = ctx.getPackageManager ().getPackageInfo (ctx.getPackageName (), 0).versionName;
    } catch (PackageManager.NameNotFoundException e) {
        Log.e ("tag", e.getMessage ());
    }
    return version;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31891146_31892578_15_35
31891146_31892691_1_21
Title: count number of binary search tree of height h for all possible roots over n elements 
----------------------------------------

public static int countTrees (int N, int curH, int H) {
    if (curH > H) return 0;

    if (N <= 1) {
        return (1);
    } else {
        int sum = 0;
        int left, right, root;
        for (root = 1; root <= N; root ++) {
            left = countTrees (root - 1, curH + 1, H);
            right = countTrees (N - root, curH + 1, H);
            sum += left * right;
        }
        return (sum);
    }
}
----------------------------------------

int countTrees (int N, int h, int l) {
    if (N <= 1) {
        return (1);
    } else {
        int sum = 0;
        int left, right, root;
        for (root = 1; root <= N; root ++) {
            left = 0;
            right = 0;
            if (l + 1 <= h) {
                left = countTrees (root - 1, h, l + 1);
                right = countTrees (N - root, h, l + 1);
                if (l == 0) arr [root - 1] += left * right;

                sum += left * right;
            }
        }
        return sum;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31892579_31893193_1_46
31892579_32346017_1_14
Title: i need to separate the string and integer and also to display it in separate columns 
----------------------------------------

public static void main (String [] args) {
    String s = "java 100";
    int number;
    String snum = "";
    String text = "";
    for (int i = 0;
    i < s.length (); i ++) {
        switch (s.charAt (i)) {
            case '0' :
                snum += "0";
                break;
            case '1' :
                snum += "1";
                break;
            case '2' :
                snum += "2";
                break;
            case '3' :
                snum += "3";
                break;
            case '4' :
                snum += "4";
                break;
            case '5' :
                snum += "5";
                break;
            case '6' :
                snum += "6";
                break;
            case '7' :
                snum += "7";
                break;
            case '8' :
                snum += "8";
                break;
            case '9' :
                snum += "9";
                break;
            default :
                text += s.charAt (i);
                break;
        }
    }
    number = Integer.parseInt (snum);
    System.out.print (text + " " + number);
}
----------------------------------------

public static void main (String args []) {
    Scanner scanner = new Scanner (System.in);
    for (int i = 0;
    i < 2; i ++) {
        String string = scanner.next ();
        int num = scanner.nextInt ();
        System.out.printf ("%-14s %03d %n", string, num);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31892579_31893193_1_46
31892579_33459967_6_17
Title: i need to separate the string and integer and also to display it in separate columns 
----------------------------------------

public static void main (String [] args) {
    String s = "java 100";
    int number;
    String snum = "";
    String text = "";
    for (int i = 0;
    i < s.length (); i ++) {
        switch (s.charAt (i)) {
            case '0' :
                snum += "0";
                break;
            case '1' :
                snum += "1";
                break;
            case '2' :
                snum += "2";
                break;
            case '3' :
                snum += "3";
                break;
            case '4' :
                snum += "4";
                break;
            case '5' :
                snum += "5";
                break;
            case '6' :
                snum += "6";
                break;
            case '7' :
                snum += "7";
                break;
            case '8' :
                snum += "8";
                break;
            case '9' :
                snum += "9";
                break;
            default :
                text += s.charAt (i);
                break;
        }
    }
    number = Integer.parseInt (snum);
    System.out.print (text + " " + number);
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    for (int i = 0;
    i < 3; i ++) {
        String s1 = sc.next ();
        int x = sc.nextInt ();
        System.out.printf ("%-14s %03d %n", s1, x);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31892579_31893193_1_46
31892579_48433545_1_16
Title: i need to separate the string and integer and also to display it in separate columns 
----------------------------------------

public static void main (String [] args) {
    String s = "java 100";
    int number;
    String snum = "";
    String text = "";
    for (int i = 0;
    i < s.length (); i ++) {
        switch (s.charAt (i)) {
            case '0' :
                snum += "0";
                break;
            case '1' :
                snum += "1";
                break;
            case '2' :
                snum += "2";
                break;
            case '3' :
                snum += "3";
                break;
            case '4' :
                snum += "4";
                break;
            case '5' :
                snum += "5";
                break;
            case '6' :
                snum += "6";
                break;
            case '7' :
                snum += "7";
                break;
            case '8' :
                snum += "8";
                break;
            case '9' :
                snum += "9";
                break;
            default :
                text += s.charAt (i);
                break;
        }
    }
    number = Integer.parseInt (snum);
    System.out.print (text + " " + number);
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("================================");
    for (int i = 0;
    i < 3; i ++) {
        String string = sc.next ();
        int num = sc.nextInt ();
        System.out.printf ("%-14s %03d %n", string, num);
    }
    System.out.println ("================================");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31892579_31893193_1_46
31892579_48735142_1_11
Title: i need to separate the string and integer and also to display it in separate columns 
----------------------------------------

public static void main (String [] args) {
    String s = "java 100";
    int number;
    String snum = "";
    String text = "";
    for (int i = 0;
    i < s.length (); i ++) {
        switch (s.charAt (i)) {
            case '0' :
                snum += "0";
                break;
            case '1' :
                snum += "1";
                break;
            case '2' :
                snum += "2";
                break;
            case '3' :
                snum += "3";
                break;
            case '4' :
                snum += "4";
                break;
            case '5' :
                snum += "5";
                break;
            case '6' :
                snum += "6";
                break;
            case '7' :
                snum += "7";
                break;
            case '8' :
                snum += "8";
                break;
            case '9' :
                snum += "9";
                break;
            default :
                text += s.charAt (i);
                break;
        }
    }
    number = Integer.parseInt (snum);
    System.out.print (text + " " + number);
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("================================");
    for (int i = 0;
    i < 3; i ++) {
        String s1 = sc.next ();
        int x = sc.nextInt ();
        System.out.printf ("%-15s%03d%n", s1, x);
    }
    System.out.println ("================================");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31892579_31893193_1_46
31892579_51351016_1_27
Title: i need to separate the string and integer and also to display it in separate columns 
----------------------------------------

public static void main (String [] args) {
    String s = "java 100";
    int number;
    String snum = "";
    String text = "";
    for (int i = 0;
    i < s.length (); i ++) {
        switch (s.charAt (i)) {
            case '0' :
                snum += "0";
                break;
            case '1' :
                snum += "1";
                break;
            case '2' :
                snum += "2";
                break;
            case '3' :
                snum += "3";
                break;
            case '4' :
                snum += "4";
                break;
            case '5' :
                snum += "5";
                break;
            case '6' :
                snum += "6";
                break;
            case '7' :
                snum += "7";
                break;
            case '8' :
                snum += "8";
                break;
            case '9' :
                snum += "9";
                break;
            default :
                text += s.charAt (i);
                break;
        }
    }
    number = Integer.parseInt (snum);
    System.out.print (text + " " + number);
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("================================");
    for (int i = 0;
    i < 3; i ++) {
        String s1 = sc.next ();
        int x = sc.nextInt ();
        int j = 0;
        if (s1.length () <= 10 && j < 1000) {
            String StringFormatted = String.format ("%-15s", s1);
            System.out.print (StringFormatted);
            if (x < 100) {
                String padded = String.format ("%03d", x);
                System.out.print (padded);
            } else {
                System.out.print (x);
            }
        }
        System.out.println ("");
    }
    System.out.println ("================================");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31892579_32346017_1_14
31892579_33459967_6_17
Title: i need to separate the string and integer and also to display it in separate columns 
----------------------------------------

public static void main (String args []) {
    Scanner scanner = new Scanner (System.in);
    for (int i = 0;
    i < 2; i ++) {
        String string = scanner.next ();
        int num = scanner.nextInt ();
        System.out.printf ("%-14s %03d %n", string, num);
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    for (int i = 0;
    i < 3; i ++) {
        String s1 = sc.next ();
        int x = sc.nextInt ();
        System.out.printf ("%-14s %03d %n", s1, x);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31892579_32346017_1_14
31892579_48433545_1_16
Title: i need to separate the string and integer and also to display it in separate columns 
----------------------------------------

public static void main (String args []) {
    Scanner scanner = new Scanner (System.in);
    for (int i = 0;
    i < 2; i ++) {
        String string = scanner.next ();
        int num = scanner.nextInt ();
        System.out.printf ("%-14s %03d %n", string, num);
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("================================");
    for (int i = 0;
    i < 3; i ++) {
        String string = sc.next ();
        int num = sc.nextInt ();
        System.out.printf ("%-14s %03d %n", string, num);
    }
    System.out.println ("================================");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31892579_32346017_1_14
31892579_48735142_1_11
Title: i need to separate the string and integer and also to display it in separate columns 
----------------------------------------

public static void main (String args []) {
    Scanner scanner = new Scanner (System.in);
    for (int i = 0;
    i < 2; i ++) {
        String string = scanner.next ();
        int num = scanner.nextInt ();
        System.out.printf ("%-14s %03d %n", string, num);
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("================================");
    for (int i = 0;
    i < 3; i ++) {
        String s1 = sc.next ();
        int x = sc.nextInt ();
        System.out.printf ("%-15s%03d%n", s1, x);
    }
    System.out.println ("================================");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31892579_32346017_1_14
31892579_51351016_1_27
Title: i need to separate the string and integer and also to display it in separate columns 
----------------------------------------

public static void main (String args []) {
    Scanner scanner = new Scanner (System.in);
    for (int i = 0;
    i < 2; i ++) {
        String string = scanner.next ();
        int num = scanner.nextInt ();
        System.out.printf ("%-14s %03d %n", string, num);
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("================================");
    for (int i = 0;
    i < 3; i ++) {
        String s1 = sc.next ();
        int x = sc.nextInt ();
        int j = 0;
        if (s1.length () <= 10 && j < 1000) {
            String StringFormatted = String.format ("%-15s", s1);
            System.out.print (StringFormatted);
            if (x < 100) {
                String padded = String.format ("%03d", x);
                System.out.print (padded);
            } else {
                System.out.print (x);
            }
        }
        System.out.println ("");
    }
    System.out.println ("================================");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31892579_33459967_6_17
31892579_48433545_1_16
Title: i need to separate the string and integer and also to display it in separate columns 
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    for (int i = 0;
    i < 3; i ++) {
        String s1 = sc.next ();
        int x = sc.nextInt ();
        System.out.printf ("%-14s %03d %n", s1, x);
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("================================");
    for (int i = 0;
    i < 3; i ++) {
        String string = sc.next ();
        int num = sc.nextInt ();
        System.out.printf ("%-14s %03d %n", string, num);
    }
    System.out.println ("================================");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31892579_33459967_6_17
31892579_48735142_1_11
Title: i need to separate the string and integer and also to display it in separate columns 
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    for (int i = 0;
    i < 3; i ++) {
        String s1 = sc.next ();
        int x = sc.nextInt ();
        System.out.printf ("%-14s %03d %n", s1, x);
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("================================");
    for (int i = 0;
    i < 3; i ++) {
        String s1 = sc.next ();
        int x = sc.nextInt ();
        System.out.printf ("%-15s%03d%n", s1, x);
    }
    System.out.println ("================================");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31892579_33459967_6_17
31892579_51351016_1_27
Title: i need to separate the string and integer and also to display it in separate columns 
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    for (int i = 0;
    i < 3; i ++) {
        String s1 = sc.next ();
        int x = sc.nextInt ();
        System.out.printf ("%-14s %03d %n", s1, x);
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("================================");
    for (int i = 0;
    i < 3; i ++) {
        String s1 = sc.next ();
        int x = sc.nextInt ();
        int j = 0;
        if (s1.length () <= 10 && j < 1000) {
            String StringFormatted = String.format ("%-15s", s1);
            System.out.print (StringFormatted);
            if (x < 100) {
                String padded = String.format ("%03d", x);
                System.out.print (padded);
            } else {
                System.out.print (x);
            }
        }
        System.out.println ("");
    }
    System.out.println ("================================");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31892579_48433545_1_16
31892579_48735142_1_11
Title: i need to separate the string and integer and also to display it in separate columns 
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("================================");
    for (int i = 0;
    i < 3; i ++) {
        String string = sc.next ();
        int num = sc.nextInt ();
        System.out.printf ("%-14s %03d %n", string, num);
    }
    System.out.println ("================================");
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("================================");
    for (int i = 0;
    i < 3; i ++) {
        String s1 = sc.next ();
        int x = sc.nextInt ();
        System.out.printf ("%-15s%03d%n", s1, x);
    }
    System.out.println ("================================");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31892579_48433545_1_16
31892579_51351016_1_27
Title: i need to separate the string and integer and also to display it in separate columns 
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("================================");
    for (int i = 0;
    i < 3; i ++) {
        String string = sc.next ();
        int num = sc.nextInt ();
        System.out.printf ("%-14s %03d %n", string, num);
    }
    System.out.println ("================================");
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("================================");
    for (int i = 0;
    i < 3; i ++) {
        String s1 = sc.next ();
        int x = sc.nextInt ();
        int j = 0;
        if (s1.length () <= 10 && j < 1000) {
            String StringFormatted = String.format ("%-15s", s1);
            System.out.print (StringFormatted);
            if (x < 100) {
                String padded = String.format ("%03d", x);
                System.out.print (padded);
            } else {
                System.out.print (x);
            }
        }
        System.out.println ("");
    }
    System.out.println ("================================");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31892579_48735142_1_11
31892579_51351016_1_27
Title: i need to separate the string and integer and also to display it in separate columns 
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("================================");
    for (int i = 0;
    i < 3; i ++) {
        String s1 = sc.next ();
        int x = sc.nextInt ();
        System.out.printf ("%-15s%03d%n", s1, x);
    }
    System.out.println ("================================");
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("================================");
    for (int i = 0;
    i < 3; i ++) {
        String s1 = sc.next ();
        int x = sc.nextInt ();
        int j = 0;
        if (s1.length () <= 10 && j < 1000) {
            String StringFormatted = String.format ("%-15s", s1);
            System.out.print (StringFormatted);
            if (x < 100) {
                String padded = String.format ("%03d", x);
                System.out.print (padded);
            } else {
                System.out.print (x);
            }
        }
        System.out.println ("");
    }
    System.out.println ("================================");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31895612_31945896_1_13
31895612_32403727_1_15
Title: how to stop a thread with thread interrupt method 
----------------------------------------

@Override
public void run () {
    while (! Thread.currentThread ().isInterrupted ()) {
        try {
            System.out.println ("Sleeping");
            Thread.sleep ((long) 10000);
            exitThread ();
            System.out.println ("Processing");
        } catch (InterruptedException e) {
            Thread.currentThread ().interrupt ();
        }
    }
}
----------------------------------------

@Override
public void run () {
    while (run) {
        try {
            System.out.println ("Sleeping...");
            exitThread ();
            Thread.sleep (10000);
            System.out.println ("Processing...");
        } catch (InterruptedException e) {
            System.out.println ("Thread intreputted " + e);
            run = false;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31895897_31896072_3_25
31895897_32829076_2_17
Title: Euler Project 2 
----------------------------------------

public static void main (String [] args) {
    int fiboFirst = 1;
    int fiboSecond = 2;
    int fib = 0;
    int sum = 0;
    while (fiboSecond < 4000000) {
        fib = fiboFirst + fiboSecond;
        fiboFirst = fiboSecond;
        fiboSecond = fib;
        if (fib % 2 == 0) {
            sum = sum + fib;
        }
    }
    System.out.println (sum + 2);
}
----------------------------------------

public static void main (String [] args) {
    int a = 0, b = 1;
    double sum = 0;
    while (b < 4000000) {
        int ob = b;
        b = a + b;
        a = ob;
        if (b % 2 == 0) sum += b;

    }
    System.out.println (sum);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31909458_31912188_22_47
31909458_31913069_11_54
Title: JavaFX Animation: Move Shape (Star) randomly 
----------------------------------------

public void start (Stage primaryStage) {
    Button btn = new Button ();
    btn.setText ("Do Animation");
    int x = new Random ().nextInt (500);
    int y = new Random ().nextInt (400);
    rectBasicTimeline = new Rectangle (x, y, 100, 50);
    rectBasicTimeline.setFill (Color.RED);
    btn.setOnAction (new EventHandler < ActionEvent > () {
        @Override
        public void handle (ActionEvent event) {
            play ();
        }}

    );
    AnchorPane root = new AnchorPane ();
    root.getChildren ().addAll (btn, rectBasicTimeline);
    Scene scene = new Scene (root, 800, 600);
    primaryStage.setTitle ("Hello World!");
    primaryStage.setScene (scene);
    primaryStage.show ();
}
----------------------------------------

public void start (Stage primaryStage) {
    Pos initPos = getRandomPos ();
    star = new Polygon ();
    star.setLayoutX (initPos.x);
    star.setLayoutY (initPos.y);
    star.setFill (Color.YELLOW);
    star.getPoints ().addAll (new Double [] {0.0, shs * 3, shs * 2, shs * 2, shs * 3, 0.0, shs * 4, shs * 2, shs * 6, shs * 3, shs * 4, shs * 4, shs * 3, shs * 6, shs * 2, shs * 4});
    timeline = new Timeline ();
    timeline.setCycleCount (Timeline.INDEFINITE);
    timeline.setAutoReverse (true);
    Button btnStart = new Button ("Do Animation");
    btnStart.setOnAction ((e) -> playNextKeyFrame ());
    Button btnStop = new Button ("Stop Animation");
    btnStop.setLayoutX (200);
    btnStart.setLayoutX (0);
    btnStop.setOnAction ((e) -> timeline.stop ());
    AnchorPane root = new AnchorPane (btnStart, btnStop, star);
    Scene scene = new Scene (root, 800, 600);
    primaryStage.setScene (scene);
    primaryStage.show ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31911769_31911860_1_9
31911769_31911894_1_13
Title: How do I find the largest negative value in an array with both positive and negative values? 
----------------------------------------

public int greatestNegative (int [] list) {
    int negNum = 0;
    for (int i = 0;
    i < list.length; i ++) {
        if (list [i] < negNum) {
            negNum = list [i];
        }
    }
    return negNum;
}
----------------------------------------

public static int greatestNegative (int [] list) {
    int max = Integer.MIN;
    boolean set = false;
    for (int i = 0;
    i < list.length; i ++) {
        if (list [i] < 0 && list [i] > max) {
            max = arr [i];
            set = true;
        }
    }
    if (! set) max = 0;

    return max;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31911769_31911860_1_9
31911769_31911944_10_18
Title: How do I find the largest negative value in an array with both positive and negative values? 
----------------------------------------

public int greatestNegative (int [] list) {
    int negNum = 0;
    for (int i = 0;
    i < list.length; i ++) {
        if (list [i] < negNum) {
            negNum = list [i];
        }
    }
    return negNum;
}
----------------------------------------

private static int greatestNegative (int [] arr) {
    Arrays.sort (arr);
    for (int i = arr.length - 1;
    i >= 0; i --) {
        if (isNegative (arr [i])) {
            return arr [i];
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31911769_31911860_1_9
31911769_31911993_1_14
Title: How do I find the largest negative value in an array with both positive and negative values? 
----------------------------------------

public int greatestNegative (int [] list) {
    int negNum = 0;
    for (int i = 0;
    i < list.length; i ++) {
        if (list [i] < negNum) {
            negNum = list [i];
        }
    }
    return negNum;
}
----------------------------------------

public static int greatestNegative (int [] list) {
    int negativeNumbers = Integer.MAX_VALUE;
    for (int i = 0;
    i < list.length; i ++) {
        if (list [i] < negativeNumbers) negativeNumbers = list [i];

    }
    if (negativeNumbers >= 0) return 0;
    else return negativeNumbers;

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31911769_31911860_1_9
31911769_31912110_1_11
Title: How do I find the largest negative value in an array with both positive and negative values? 
----------------------------------------

public int greatestNegative (int [] list) {
    int negNum = 0;
    for (int i = 0;
    i < list.length; i ++) {
        if (list [i] < negNum) {
            negNum = list [i];
        }
    }
    return negNum;
}
----------------------------------------

public int greatestNegative (int [] list) {
    int result = 0;
    for (int i = 0;
    i < list.length; i ++) {
        if (list [i] < 0) {
            if (result == 0 || list [i] > result) {
                result = list [i];
            }
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31911769_31911894_1_13
31911769_31911944_10_18
Title: How do I find the largest negative value in an array with both positive and negative values? 
----------------------------------------

public static int greatestNegative (int [] list) {
    int max = Integer.MIN;
    boolean set = false;
    for (int i = 0;
    i < list.length; i ++) {
        if (list [i] < 0 && list [i] > max) {
            max = arr [i];
            set = true;
        }
    }
    if (! set) max = 0;

    return max;
}
----------------------------------------

private static int greatestNegative (int [] arr) {
    Arrays.sort (arr);
    for (int i = arr.length - 1;
    i >= 0; i --) {
        if (isNegative (arr [i])) {
            return arr [i];
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31911769_31911894_1_13
31911769_31911993_1_14
Title: How do I find the largest negative value in an array with both positive and negative values? 
----------------------------------------

public static int greatestNegative (int [] list) {
    int max = Integer.MIN;
    boolean set = false;
    for (int i = 0;
    i < list.length; i ++) {
        if (list [i] < 0 && list [i] > max) {
            max = arr [i];
            set = true;
        }
    }
    if (! set) max = 0;

    return max;
}
----------------------------------------

public static int greatestNegative (int [] list) {
    int negativeNumbers = Integer.MAX_VALUE;
    for (int i = 0;
    i < list.length; i ++) {
        if (list [i] < negativeNumbers) negativeNumbers = list [i];

    }
    if (negativeNumbers >= 0) return 0;
    else return negativeNumbers;

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31911769_31911894_1_13
31911769_31912110_1_11
Title: How do I find the largest negative value in an array with both positive and negative values? 
----------------------------------------

public static int greatestNegative (int [] list) {
    int max = Integer.MIN;
    boolean set = false;
    for (int i = 0;
    i < list.length; i ++) {
        if (list [i] < 0 && list [i] > max) {
            max = arr [i];
            set = true;
        }
    }
    if (! set) max = 0;

    return max;
}
----------------------------------------

public int greatestNegative (int [] list) {
    int result = 0;
    for (int i = 0;
    i < list.length; i ++) {
        if (list [i] < 0) {
            if (result == 0 || list [i] > result) {
                result = list [i];
            }
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31911769_31911944_10_18
31911769_31911993_1_14
Title: How do I find the largest negative value in an array with both positive and negative values? 
----------------------------------------

private static int greatestNegative (int [] arr) {
    Arrays.sort (arr);
    for (int i = arr.length - 1;
    i >= 0; i --) {
        if (isNegative (arr [i])) {
            return arr [i];
        }
    }
    return 0;
}
----------------------------------------

public static int greatestNegative (int [] list) {
    int negativeNumbers = Integer.MAX_VALUE;
    for (int i = 0;
    i < list.length; i ++) {
        if (list [i] < negativeNumbers) negativeNumbers = list [i];

    }
    if (negativeNumbers >= 0) return 0;
    else return negativeNumbers;

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31911769_31911944_10_18
31911769_31912110_1_11
Title: How do I find the largest negative value in an array with both positive and negative values? 
----------------------------------------

private static int greatestNegative (int [] arr) {
    Arrays.sort (arr);
    for (int i = arr.length - 1;
    i >= 0; i --) {
        if (isNegative (arr [i])) {
            return arr [i];
        }
    }
    return 0;
}
----------------------------------------

public int greatestNegative (int [] list) {
    int result = 0;
    for (int i = 0;
    i < list.length; i ++) {
        if (list [i] < 0) {
            if (result == 0 || list [i] > result) {
                result = list [i];
            }
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31911769_31911993_1_14
31911769_31912110_1_11
Title: How do I find the largest negative value in an array with both positive and negative values? 
----------------------------------------

public static int greatestNegative (int [] list) {
    int negativeNumbers = Integer.MAX_VALUE;
    for (int i = 0;
    i < list.length; i ++) {
        if (list [i] < negativeNumbers) negativeNumbers = list [i];

    }
    if (negativeNumbers >= 0) return 0;
    else return negativeNumbers;

}
----------------------------------------

public int greatestNegative (int [] list) {
    int result = 0;
    for (int i = 0;
    i < list.length; i ++) {
        if (list [i] < 0) {
            if (result == 0 || list [i] > result) {
                result = list [i];
            }
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31917936_31918129_3_21
31917936_31918209_1_23
Title: ArayIndexOutOfBoundsException isn't working 
----------------------------------------

public static void main (String [] a) {
    int i = 0, n = 0;
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter the size of an array: ");
    n = sc.nextInt ();
    int [] ar = new int [n];
    System.out.println ("Enter " + n + " elements of an array: ");
    for (i = 0; i < n; i ++) {
        ar [i] = sc.nextInt ();
    }
    System.out.println ("Output Numbers: ");
    for (i = 0; i < n; i ++) {
        System.out.println (ar [i]);
    }
    sc.close ();
}
----------------------------------------

public static void main (String [] args) {
    int n = 0;
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter the size of an array: ");
    try {
        n = sc.nextInt ();
    } catch (ArrayIndexOutOfBoundsException e) {
        System.out.println ("Now you have gone too far");
    }
    int [] ar = new int [n];
    System.out.println ("Enter " + n + " elements of an array: ");
    for (int i = 0;
    i < n; i ++) {
        ar [i] = sc.nextInt ();
    }
    System.out.println ("Output Numbers: ");
    for (int i = 0;
    i < n; i ++) {
        System.out.println (ar [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31930130_32590980_13_49
31930130_32590980_18_31
Title: Android: Interrupt thread contained in a method 
----------------------------------------

public void run () {
    final Thread _this = this;
    Thread interruptingThread = new Thread (new Runnable () {
        @Override
        public void run () {
            try {
                Thread.sleep (1);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
            if (true) {
                System.out.println ("interrupting " + _this + " from thread " + this);
                synchronized (mutex) {
                    _this.interrupt ();
                }
            }
        }}

    , "interrupting thread");
    interruptingThread.start ();
    for (int x = 0;
    x < 75000; x ++) {
        synchronized (mutex) {
            System.out.println (x);
        }
        if (Thread.interrupted ()) {
            System.out.println ("" + this + " interrupted!");
            x = 0;
        }
    }
}
----------------------------------------

public void run () {
    try {
        Thread.sleep (1);
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    if (true) {
        System.out.println ("interrupting " + _this + " from thread " + this);
        synchronized (mutex) {
            _this.interrupt ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31930130_32590980_13_49
31930130_32591316_7_38
Title: Android: Interrupt thread contained in a method 
----------------------------------------

public void run () {
    final Thread _this = this;
    Thread interruptingThread = new Thread (new Runnable () {
        @Override
        public void run () {
            try {
                Thread.sleep (1);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
            if (true) {
                System.out.println ("interrupting " + _this + " from thread " + this);
                synchronized (mutex) {
                    _this.interrupt ();
                }
            }
        }}

    , "interrupting thread");
    interruptingThread.start ();
    for (int x = 0;
    x < 75000; x ++) {
        synchronized (mutex) {
            System.out.println (x);
        }
        if (Thread.interrupted ()) {
            System.out.println ("" + this + " interrupted!");
            x = 0;
        }
    }
}
----------------------------------------

public void run () {
    final Thread thread = Thread.currentThread ();
    for (int x = 0;
    x < 750 && ! Thread.interrupted (); x ++) {
        try {
            Thread.sleep (4);
            runOnUiThread (new Runnable () {
                @Override
                public void run () {
                    if (true) {
                        thread.interrupt ();
                    }
                }}

            );
        } catch (InterruptedException e) {
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31930130_32590980_13_49
31930130_32596782_12_29
Title: Android: Interrupt thread contained in a method 
----------------------------------------

public void run () {
    final Thread _this = this;
    Thread interruptingThread = new Thread (new Runnable () {
        @Override
        public void run () {
            try {
                Thread.sleep (1);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
            if (true) {
                System.out.println ("interrupting " + _this + " from thread " + this);
                synchronized (mutex) {
                    _this.interrupt ();
                }
            }
        }}

    , "interrupting thread");
    interruptingThread.start ();
    for (int x = 0;
    x < 75000; x ++) {
        synchronized (mutex) {
            System.out.println (x);
        }
        if (Thread.interrupted ()) {
            System.out.println ("" + this + " interrupted!");
            x = 0;
        }
    }
}
----------------------------------------

public void run () {
    if (m_bRunning) return;

    m_bRunning = true;
    m_tskStopper = null;
    for (int i = 0;
    i < THREAD_COUNT && m_bRunning; i ++) {
        try {
            (new Thread (new ParallelTask (this))).run ();
        } catch (Exception x) {
            Log.w ("ParallelTaskRunner.run()", "Caught exception.", x);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31930130_32590980_18_31
31930130_32591316_7_38
Title: Android: Interrupt thread contained in a method 
----------------------------------------

public void run () {
    try {
        Thread.sleep (1);
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    if (true) {
        System.out.println ("interrupting " + _this + " from thread " + this);
        synchronized (mutex) {
            _this.interrupt ();
        }
    }
}
----------------------------------------

public void run () {
    final Thread thread = Thread.currentThread ();
    for (int x = 0;
    x < 750 && ! Thread.interrupted (); x ++) {
        try {
            Thread.sleep (4);
            runOnUiThread (new Runnable () {
                @Override
                public void run () {
                    if (true) {
                        thread.interrupt ();
                    }
                }}

            );
        } catch (InterruptedException e) {
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31930130_32590980_18_31
31930130_32596782_12_29
Title: Android: Interrupt thread contained in a method 
----------------------------------------

public void run () {
    try {
        Thread.sleep (1);
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    if (true) {
        System.out.println ("interrupting " + _this + " from thread " + this);
        synchronized (mutex) {
            _this.interrupt ();
        }
    }
}
----------------------------------------

public void run () {
    if (m_bRunning) return;

    m_bRunning = true;
    m_tskStopper = null;
    for (int i = 0;
    i < THREAD_COUNT && m_bRunning; i ++) {
        try {
            (new Thread (new ParallelTask (this))).run ();
        } catch (Exception x) {
            Log.w ("ParallelTaskRunner.run()", "Caught exception.", x);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31930130_32590980_7_52
31930130_32591316_1_40
Title: Android: Interrupt thread contained in a method 
----------------------------------------

public void callthread () {
    final Object mutex = new Object ();
    final Thread myThread = new Thread ("myThread") {
        @Override
        public void run () {
            final Thread _this = this;
            Thread interruptingThread = new Thread (new Runnable () {
                @Override
                public void run () {
                    try {
                        Thread.sleep (1);
                    } catch (InterruptedException e) {
                        e.printStackTrace ();
                    }
                    if (true) {
                        System.out.println ("interrupting " + _this + " from thread " + this);
                        synchronized (mutex) {
                            _this.interrupt ();
                        }
                    }
                }}

            , "interrupting thread");
            interruptingThread.start ();
            for (int x = 0;
            x < 75000; x ++) {
                synchronized (mutex) {
                    System.out.println (x);
                }
                if (Thread.interrupted ()) {
                    System.out.println ("" + this + " interrupted!");
                    x = 0;
                }
            }
        }}

    ;
    myThread.start ();
}
----------------------------------------

public void callthread () {
    final Thread myThread = new Thread (new Runnable () {
        @Override
        public void run () {
            final Thread thread = Thread.currentThread ();
            for (int x = 0;
            x < 750 && ! Thread.interrupted (); x ++) {
                try {
                    Thread.sleep (4);
                    runOnUiThread (new Runnable () {
                        @Override
                        public void run () {
                            if (true) {
                                thread.interrupt ();
                            }
                        }}

                    );
                } catch (InterruptedException e) {
                }
            }
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31930130_32591316_7_38
31930130_32596782_12_29
Title: Android: Interrupt thread contained in a method 
----------------------------------------

public void run () {
    final Thread thread = Thread.currentThread ();
    for (int x = 0;
    x < 750 && ! Thread.interrupted (); x ++) {
        try {
            Thread.sleep (4);
            runOnUiThread (new Runnable () {
                @Override
                public void run () {
                    if (true) {
                        thread.interrupt ();
                    }
                }}

            );
        } catch (InterruptedException e) {
        }
    }
}
----------------------------------------

public void run () {
    if (m_bRunning) return;

    m_bRunning = true;
    m_tskStopper = null;
    for (int i = 0;
    i < THREAD_COUNT && m_bRunning; i ++) {
        try {
            (new Thread (new ParallelTask (this))).run ();
        } catch (Exception x) {
            Log.w ("ParallelTaskRunner.run()", "Caught exception.", x);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31934208_31934529_10_29
31934208_31934883_3_38
Title: "Remove duplicate items from a LinkedList where the nested collection items can be in any order" 
----------------------------------------

public static void main (String [] args) {
    List < Animal > list1 = new LinkedList < > (Arrays.asList (Cat, Mouse, Dog));
    List < Animal > list2 = new LinkedList < > (Arrays.asList (Dog, Mouse, Cat));
    List < Animal > list3 = new LinkedList < > (Arrays.asList (Dog, Horse, Cat));
    List < Animal > list4 = new LinkedList < > (Arrays.asList (Dog, Tiger, Lion));
    List < List < Animal > > list = new LinkedList < > (Arrays.asList (list1, list2, list3, list4));
    Set < List < Animal > > sorted = new LinkedHashSet < > ();
    for (List < Animal > animals : list) {
        List < Animal > arList = new ArrayList < > (animals);
        Collections.sort (arList);
        sorted.add (new LinkedList < > (arList));
    }
    for (List < Animal > animals : sorted) {
        System.out.println (animals);
    }
}
----------------------------------------

public static void main (String [] args) {
    List < String > list1 = new LinkedList < > (Arrays.asList ("Cat", "Mouse", "Dog"));
    List < String > list2 = new LinkedList < > (Arrays.asList ("Dog", "Mouse", "Cat"));
    List < String > list3 = new LinkedList < > (Arrays.asList ("Dog", "Horse", "Cat"));
    List < String > list4 = new LinkedList < > (Arrays.asList ("Dog", "Tiger", "Lion"));
    List < List < String > > list = new LinkedList < > (Arrays.asList (list1, list2, list3, list4));
    boolean flag = false;
    boolean matchFlag = true;
    for (int i = 0;
    i < list.size (); i ++) {
        for (int j = i + 1;
        j < list.size (); j ++) {
            if (list.get (i).size () == list.get (j).size ()) {
                matchFlag = true;
                for (String str : list.get (i)) {
                    flag = false;
                    for (String string : list.get (j)) {
                        if (str.equals (string)) {
                            flag = true;
                        }
                    }
                    if (flag == false) {
                        matchFlag = false;
                        break;
                    }
                }
                if (matchFlag) {
                    list.remove (j);
                    j --;
                }
            }
        }
    }
    System.out.println (list.size ());
    for (int i = 0;
    i < list.size (); i ++) {
        System.out.println (list.get (i));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31935532_31935610_5_14
31935532_35245050_7_23
Title: "Return the number of times that the string ""hello"" appears anywhere in the given string" 
----------------------------------------

public static int count (String str) {
    String [] arr = str.split (" ");
    int count = 0;
    for (String i : arr) {
        if (i.equalsIgnoreCase ("hello")) {
            count ++;
        }
    }
    return count;
}
----------------------------------------

public int count (String str1) {
    String str2 = "Hello";
    int len1 = str1.length ();
    int len2 = str2.length ();
    int count = 0;
    for (int i = 0;
    i < (len1 - len2 + 1); i ++) {
        String str = "";
        for (int j = i;
        j < i + len2; j ++) {
            str = str + str1.charAt (j);
            if (str.equalsIgnoreCase (str2)) count ++;

        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31935784_31935848_1_44
31935784_31948687_3_37
Title: Repeating if else statement 
----------------------------------------

public static void main (String [] args) {
    String Day;
    TextIO.put ("This program is to tell you what to eat for today.");
    TextIO.put ("\nBefore it starts, can you tell me what's the day today?");
    do {
        Day = TextIO.getln ();
        if (Day.equals ("Monday")) {
            System.out.print ("Eat Chocolates");
            break;
        } else if (Day.equals ("Tuesday")) {
            System.out.print ("Eat Oranges");
            break;
        } else if (Day.equals ("Wednesday")) {
            System.out.print ("Eat Strawberries");
            break;
        } else if (Day.equals ("Thursday")) {
            System.out.print ("Eat Lemons");
            break;
        } else if (Day.equals ("Friday")) {
            System.out.print ("Eat Bananas");
            break;
        } else if (Day.equals ("Saturday")) {
            System.out.print ("Eat Apples");
            break;
        } else if (Day.equals ("Sunday")) {
            System.out.print ("Eat Grass");
            break;
        } else if (Day.equals (false)) {
            System.out.print ("Error");
            System.out.print ("\nPlease re-eneter the answer");
        }

    } while (true);
}
----------------------------------------

public static void main (String [] args) {
    String Day;
    TextIO.put ("This program is to tell you what to eat for today.");
    TextIO.put ("\nBefore it starts, can you tell me what's the day today?");
    Day = TextIO.getln ();
    if (Day.equals ("Monday")) {
        System.out.print ("Eat Chocolates");
    } else if (Day.equals ("Tuesday")) {
        System.out.print ("Eat Oranges");
    } else if (Day.equals ("Wednesday")) {
        System.out.print ("Eat Strawberries");
    } else if (Day.equals ("Thursday")) {
        System.out.print ("Eat Lemons");
    } else if (Day.equals ("Friday")) {
        System.out.print ("Eat Bananas");
    } else if (Day.equals ("Saturday")) {
        System.out.print ("Eat Apples");
    } else if (Day.equals ("Sunday")) {
        System.out.print ("Eat Grass");
    } else if (Day.equals (false)) {
        System.out.print ("Error");
        System.out.print ("\nPlease re-eneter the answer");
        Day = TextIO.getln ();
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31938613_31941848_117_127
31938613_31941848_68_81
Title: Is my code thread-unsafe? 
----------------------------------------

public void run () {
    System.out.println ("Round " + roundNumber ++);
    electoralCommission.printResults ();
    electoralCommission.removeWeakCandidates ();
    if (electoralCommission.hasWinner) {
        String winnerName = electoralCommission.getWinner ();
        System.out.println ("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        System.out.println ("candidate " + winnerName + " won!");
        System.out.println ("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
    }
}
----------------------------------------

public void run () {
    while (! electoralCommission.hasWinner) {
        List < String > candidates = electoralCommission.getCandidates ();
        int voteIndex = new Random ().nextInt (candidates.size ());
        electoralCommission.acceptVote (voteIndex);
        try {
            cyclicBarrier.await ();
        } catch (InterruptedException e) {
            e.printStackTrace ();
        } catch (BrokenBarrierException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31942535_31942691_1_14
31942535_31942792_1_28
Title: Closing a PrintWriter Object that has been initialized in an if statement 
----------------------------------------

void myMethod (String [] argument3, File file) throws IOException {
    String [] cmd = {"command", "argument 1", "argument 2"};
    try (PrintWriter fileWriter = new PrintWriter (file)) {
        for (int i = 0;
        i < argument3.length; i ++) {
            Process process = Runtime.getRuntime ().exec (cmd);
            try (Scanner fileScanner = new Scanner (process.getInputStream ())) {
                cmd [3] = argument3 [i];
                while (fileScanner.hasNextLine ()) {
                    fileWriter.println (fileScanner.nextLine ());
                }
            }
        }
    }
}
----------------------------------------

public static synchronized void myMethod (String [] argument3, File file) {
    String [] cmd = {"command", "argument 1", "argument 2"};
    PrintWriter fileWriter = null;
    Scanner fileScanner = null;
    try {
        for (int i = 0;
        i < argument3.length; i ++) {
            fileWriter = new PrintWriter (new OutputStreamWriter (new FileOutputStream (file, true)));
            cmd [3] = argument3 [i];
            if (i == 0) {
                fileWriter = new PrintWriter (new OutputStreamWriter (new FileOutputStream (file, false)));
            }
            Process p = Runtime.getRuntime ().exec (cmd);
            fileScanner = new Scanner (p.getInputStream ());
            while (fileScanner.hasNextLine ()) {
                fileWriter.println (fileScanner.nextLine ());
            }
        }
    } catch (IOException e) {
        e.printStackTrace ();
    } finally {
        fileWriter.close ();
        fileScanner.close ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31956018_37668007_16_38
31956018_42964795_22_40
Title: Understanding phaser in java with an example 
----------------------------------------

public static void main (String a []) {
    ExecutorService execService = Executors.newFixedThreadPool (THREAD_POOL_SIZE);
    CompletionService < String > completionService = new ExecutorCompletionService < > (execService);
    Phaser phaser = new Phaser (THREAD_POOL_SIZE);
    IntStream.range (0, THREAD_POOL_SIZE).forEach (nbr -> completionService.submit (new PhaserUsage (phaser)));
    execService.shutdown ();
    try {
        while (! execService.isTerminated ()) {
            String result = completionService.take ().get ();
            System.out.println (format ("Result is: %s", result));
        }
    } catch (ExecutionException | InterruptedException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String a []) {
    ExecutorService execService = Executors.newFixedThreadPool (THREAD_POOL_SIZE);
    CompletionService < String > completionService = new ExecutorCompletionService < > (execService);
    Phaser phaser = new Phaser (1);
    IntStream.range (0, THREAD_POOL_SIZE).forEach (nbr -> completionService.submit (new PhaserUsage (phaser)));
    execService.shutdown ();
    try {
        while (! execService.isTerminated ()) {
            String result = completionService.take ().get ();
            System.out.println (format ("Result is: %s", result));
        }
    } catch (ExecutionException | InterruptedException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31956018_37668007_41_54
31956018_42964795_43_58
Title: Understanding phaser in java with an example 
----------------------------------------

public String call () {
    String threadName = Thread.currentThread ().getName ();
    System.out.println (format ("Arrive and await advance...%s", threadName));
    phaser.arriveAndAwaitAdvance ();
    int a = 0, b = 1;
    Random random = new Random ();
    for (int i = 0;
    i < random.nextInt (10000000); i ++) {
        a = a + b;
        b = a - b;
    }
    System.out.println (format ("De-registering...%s", threadName));
    phaser.arriveAndDeregister ();
    return format ("Thread %s results: a = %s, b = %s", threadName, a, b);
}
----------------------------------------

public String call () {
    String threadName = Thread.currentThread ().getName ();
    System.out.println (format ("Registering...%s", threadName));
    System.out.println (format ("Arrive and await advance...%s", threadName));
    phaser.arriveAndAwaitAdvance ();
    int a = 0, b = 1;
    Random random = new Random ();
    for (int i = 0;
    i < random.nextInt (10000000); i ++) {
        a = a + b;
        b = a - b;
    }
    System.out.println (format ("De-registering...%s", threadName));
    phaser.arriveAndDeregister ();
    return format ("Thread %s results: a = %s, b = %s", threadName, a, b);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31966225_31968087_1_25
31966225_31977560_1_17
Title: Project Euler #12 help needed 
----------------------------------------

public static void main (String [] args) {
    System.out.println (System.currentTimeMillis ());
    long trinumber = 0;
    for (int i = 1;
    ; i ++) {
        int numDivisors = 0;
        trinumber += i;
        for (int k = 1;
        k <= trinumber; k ++) {
            if (trinumber % k == 0) {
                numDivisors ++;
            }
        }
        if (numDivisors > 500) {
            System.out.println (trinumber);
            System.out.println (System.currentTimeMillis ());
            return;
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    long triNumber = 0;
    int j = 0;
    for (int n = 0;
    ; n ++) {
        triNumber = n * (n + 1) / 2;
        for (int i = 1;
        i <= triNumber; i ++) {
            if (triNumber % i == 0) {
                j ++;
            }
        }
        if (j >= 500) {
            System.out.println (triNumber);
            break;
        }
        j = 0;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31969663_31969861_11_58
31969663_32188773_3_61
Title: Parse.com login using email or username android 
----------------------------------------

public void onClick (View v) {
    final EditText emailView = (EditText) rootView.findViewById (R.id.login_email);
    final EditText passwordView = (EditText) rootView.findViewById (R.id.login_password);
    final String email = emailView.getText ().toString ().trim ();
    final String password = passwordView.getText ().toString ().trim ();
    if (email.isEmpty () || password.isEmpty ()) {
        Dialog.Builder newBuilder = new SimpleDialog.Builder (R.style.SimpleDialogLight);
        ((SimpleDialog.Builder) newBuilder).message ("Please make sure you entered all the fields correctly.").title ("Oops!").positiveAction ("OK");
        DialogFragment fragment = DialogFragment.newInstance (newBuilder);
        fragment.show (getFragmentManager (), null);
    }
    ParseUser.logInInBackground (email, password, new LogInCallback () {
        @Override
        public void done (ParseUser parseUser, com.parse.ParseException e) {
            if (parseUser != null) {
            } else {
                Dialog.Builder newBuilder = new SimpleDialog.Builder (R.style.SimpleDialogLight);
                ((SimpleDialog.Builder) newBuilder).message (e.getMessage ()).title ("Oops!").positiveAction ("OK");
                DialogFragment fragment = DialogFragment.newInstance (newBuilder);
                fragment.show (getFragmentManager (), null);
            }
        }}

    );
}
----------------------------------------

public void onClick (View v) {
    final String username_email = mUsernameEmailEtxt.getText ().toString ().toLowerCase ().trim ();
    final String password = mPasswordEtxt.getText ().toString ().trim ();
    if (isFormInputValid (username_email, password)) {
        if (username_email.indexOf ('@') != - 1) {
            ParseQuery < ParseUser > query = ParseUser.getQuery ();
            query.whereEqualTo ("email", username_email);
            query.getFirstInBackground (new GetCallback < ParseUser > () {
                public void done (ParseUser object, ParseException e) {
                    if (object == null) {
                        TextView error = (TextView) findViewById (R.id.info);
                        error.setVisibility (View.VISIBLE);
                        error.setText (getString (R.string.error_sign_in));
                        Log.d ("error", "The getFirst request failed. Probably because no associated account found");
                    } else {
                        String actualUsername = (String) object.get ("username");
                        ParseUser.logInInBackground (actualUsername, password, new LogInCallback () {
                            public void done (ParseUser user, ParseException e) {
                                if (user != null) {
                                    Intent intent = new Intent (getBaseContext (), MainActivity.class).addFlags (Intent.FLAG_ACTIVITY_NO_HISTORY | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                                    startActivity (intent);
                                    finish ();
                                } else {
                                    TextView error = (TextView) findViewById (R.id.info);
                                    error.setVisibility (View.VISIBLE);
                                    error.setText (getString (R.string.error_sign_in));
                                    Log.d ("error", "email or password  invalid");
                                }
                            }}

                        );
                    }
                }}

            );
        } else {
            Log.d ("detector", "username_email detected as username:" + username_email);
            ParseUser.logInInBackground (username_email, password, new LogInCallback () {
                public void done (ParseUser user, ParseException e) {
                    if (user != null) {
                        Intent intent = new Intent (getBaseContext (), MainActivity.class).addFlags (Intent.FLAG_ACTIVITY_NO_HISTORY | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                        startActivity (intent);
                        finish ();
                    } else {
                        TextView error = (TextView) findViewById (R.id.info);
                        error.setVisibility (View.VISIBLE);
                        error.setText (getString (R.string.error_sign_in));
                        Log.d ("error", "username or password invalid");
                    }
                }}

            );
        }
    }
}
----------------------------------------
