$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12770084_12770136_1_10
12770084_12770237_1_16
Title: "Exception in thread ""main"" java.lang.StackOverflowError" 
----------------------------------------

private static int printSyra (BigInteger num, int count) {
    if (num.equals (BigInteger.ONE)) {
        return count;
    }
    if (num.mod (BigInteger.valueOf (2)).equals (BigInteger.ZERO)) {
        return printSyra (num.divide (BigInteger.valueOf (2)), count + 1);
    } else {
        return printSyra (num.multiply (BigInteger.valueOf (3)).add (BigInteger.ONE), count + 1);
    }
}
----------------------------------------

private int printSyra (int num) {
    int count = 1;
    int n = num;
    while (n != 1) {
        if (n % 2 == 0) {
            n = n / 2;
            ++ count;
        } else {
            n = (n * 3) + 1;
            ++ count;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12773401_12773431_1_11
12773401_12773436_1_11
Title: "Java try/catch - either ""return isn't found"" or ""variable isn't initialized""?" 
----------------------------------------

private static double promptUserDecimal () throws OopsException {
    Scanner scan = new Scanner (System.in);
    System.out.println ("Enter a decimal");
    try {
        double input2 = Double.parseDouble (scan.nextLine ());
        return input2;
    } catch (NumberFormatException e) {
        System.out.println ("Sorry, you provided an invalid option, please try again.");
        throw new OopsException ();
    }
}
----------------------------------------

private static double promptUserDecimal () {
    Scanner scan = new Scanner (System.in);
    System.out.println ("Enter a decimal");
    double input2 = 0.0;
    try {
        double input2 = Double.parseDouble (scan.nextLine ());
    } catch (NumberFormatException e) {
        System.out.println ("Sorry, you provided an invalid option, please try again.");
    }
    return input2;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12773401_12773431_1_11
12773401_12773445_1_14
Title: "Java try/catch - either ""return isn't found"" or ""variable isn't initialized""?" 
----------------------------------------

private static double promptUserDecimal () throws OopsException {
    Scanner scan = new Scanner (System.in);
    System.out.println ("Enter a decimal");
    try {
        double input2 = Double.parseDouble (scan.nextLine ());
        return input2;
    } catch (NumberFormatException e) {
        System.out.println ("Sorry, you provided an invalid option, please try again.");
        throw new OopsException ();
    }
}
----------------------------------------

private static double promptUserDecimal () {
    final Scanner scan = new Scanner (System.in);
    while (true) {
        System.out.println ("Enter a decimal");
        try {
            return Double.parseDouble (scan.nextLine ());
        } catch (NumberFormatException e) {
            System.out.println ("Sorry, you provided an invalid option, please try again.");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12773401_12773431_1_11
12773401_12773522_1_11
Title: "Java try/catch - either ""return isn't found"" or ""variable isn't initialized""?" 
----------------------------------------

private static double promptUserDecimal () throws OopsException {
    Scanner scan = new Scanner (System.in);
    System.out.println ("Enter a decimal");
    try {
        double input2 = Double.parseDouble (scan.nextLine ());
        return input2;
    } catch (NumberFormatException e) {
        System.out.println ("Sorry, you provided an invalid option, please try again.");
        throw new OopsException ();
    }
}
----------------------------------------

private static double promptUserDecimal () {
    Scanner scan = new Scanner (System.in);
    System.out.println ("Enter a decimal");
    try {
        double input2 = Double.parseDouble (scan.nextLine ());
        return input2;
    } catch (NumberFormatException e) {
        System.out.println ("Sorry, you provided an invalid option, please try again.");
        return promptUserDecimal ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12773401_12773436_1_11
12773401_12773445_1_14
Title: "Java try/catch - either ""return isn't found"" or ""variable isn't initialized""?" 
----------------------------------------

private static double promptUserDecimal () {
    Scanner scan = new Scanner (System.in);
    System.out.println ("Enter a decimal");
    double input2 = 0.0;
    try {
        double input2 = Double.parseDouble (scan.nextLine ());
    } catch (NumberFormatException e) {
        System.out.println ("Sorry, you provided an invalid option, please try again.");
    }
    return input2;
}
----------------------------------------

private static double promptUserDecimal () {
    final Scanner scan = new Scanner (System.in);
    while (true) {
        System.out.println ("Enter a decimal");
        try {
            return Double.parseDouble (scan.nextLine ());
        } catch (NumberFormatException e) {
            System.out.println ("Sorry, you provided an invalid option, please try again.");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12773401_12773445_1_14
12773401_12773522_1_11
Title: "Java try/catch - either ""return isn't found"" or ""variable isn't initialized""?" 
----------------------------------------

private static double promptUserDecimal () {
    final Scanner scan = new Scanner (System.in);
    while (true) {
        System.out.println ("Enter a decimal");
        try {
            return Double.parseDouble (scan.nextLine ());
        } catch (NumberFormatException e) {
            System.out.println ("Sorry, you provided an invalid option, please try again.");
        }
    }
}
----------------------------------------

private static double promptUserDecimal () {
    Scanner scan = new Scanner (System.in);
    System.out.println ("Enter a decimal");
    try {
        double input2 = Double.parseDouble (scan.nextLine ());
        return input2;
    } catch (NumberFormatException e) {
        System.out.println ("Sorry, you provided an invalid option, please try again.");
        return promptUserDecimal ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12776813_12776901_9_24
12776813_52703324_10_23
Title: How to Store unique objects to avoid the duplicates in java Set? 
----------------------------------------

@Override
public boolean equals (Object obj) {
    if (this == obj) return true;

    if (obj == null) return false;

    if (getClass () != obj.getClass ()) return false;

    Employee other = (Employee) obj;
    if (id == null) {
        if (other.id != null) return false;

    } else if (! id.equals (other.id)) return false;

    return true;
}
----------------------------------------

@Override
public boolean equals (Object obj) {
    if (obj instanceof Employee) {
        final Employee employee = (Employee) obj;
        return new EqualsBuilder ().append (id, employee.id).append (id, employee.name).append (id, employee.salary).isEquals ();
    } else {
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1277880_1277955_1_13
1277880_16937102_1_17
Title: How can I get the count of line in a file in an efficient way? 
----------------------------------------

public static int countLines (File aFile) throws IOException {
    LineNumberReader reader = null;
    try {
        reader = new LineNumberReader (new FileReader (aFile));
        while ((reader.readLine ()) != null);

        return reader.getLineNumber ();
    } catch (Exception ex) {
        return - 1;
    } finally {
        if (reader != null) reader.close ();

    }
}
----------------------------------------

private int countLines (File file) throws IOException {
    int lines = 0;
    FileInputStream fis = new FileInputStream (file);
    byte [] buffer = new byte [BUFFER_SIZE];
    int read;
    while ((read = fis.read (buffer)) != - 1) {
        for (int i = 0;
        i < read; i ++) {
            if (buffer [i] == '\n') lines ++;

        }
    }
    fis.close ();
    return lines;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12793227_12793312_5_57
12793227_12793443_6_45
Title: Cannot store multiple input value in Java 
----------------------------------------

public static void main (String [] args) {
    int numberArray [] = {100, 200, 300, 400, 500};
    List < String > list = new ArrayList < String > ();
    Scanner input = new Scanner (System.in);
    boolean stay = true;
    do {
        System.out.println ("Add item? Please enter \"y\" or \"n\"");
        String next = input.next ();
        if (next.equalsIgnoreCase ("y")) {
            System.out.println ("Enter item number: ");
            next = input.next ();
            try {
                int value = Integer.parseInt (next);
                switch (value) {
                    case 1 :
                    case 2 :
                    case 3 :
                    case 4 :
                    case 5 :
                        if (! list.contains (next)) {
                            total += numberArray [value - 1];
                            list.add (next);
                            System.out.println ("Your total is now " + total);
                        } else {
                            System.out.println (next + " is already used");
                        }
                        break;
                    default :
                        break;
                }
            } catch (NumberFormatException numberFormatException) {
                System.out.println (next + " is not a valid number");
            }
        } else {
            System.out.println ("You have entered all the item(s).");
            stay = false;
        }
    } while (stay);
    System.out.println ("Your total is " + total);
}
----------------------------------------

public static void main (String [] args) {
    int numberArray [] = {100, 200, 300, 400, 500};
    List < String > list = new ArrayList < String > ();
    Scanner input = new Scanner (System.in);
    do {
        System.out.println ("Add item? Please enter \"y\" or \"n\"");
        if (input.next ().startsWith ("y")) {
            System.out.println ("Enter item number: ");
            String temp = input.next ();
            list.add (temp);
            if (temp.contains ("1")) {
                int item1 = numberArray [0];
                total = total + item1;
            } else if (temp.contains ("2")) {
                int item2 = numberArray [1];
                total = total + item2;
            } else if (temp.contains ("3")) {
                int item3 = numberArray [2];
                total = total + item3;
            } else if (temp.contains ("4")) {
                int item4 = numberArray [3];
                total = total + item4;
            } else {
                System.out.println ("You have entered invalid item number!");
                break;
            }

        } else {
            System.out.println ("You have entered all the item(s).");
            break;
        }
    } while (true);
    System.out.println ("Total is: " + total);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12795321_12795474_1_17
12795321_12795576_39_56
Title: Arraylist that is unserialized is always empty 
----------------------------------------

public static ArrayList < Info > load () {
    File f = new File ("savefile.dat");
    try {
        FileInputStream fis = new FileInputStream (f);
        ObjectInputStream ois = new ObjectInputStream (fis);
        try {
            ArrayList < Info > a = (ArrayList < Info >) ois.readObject ();
            return a;
        } catch (ClassNotFoundException cnfe) {
            System.out.println ("Failed to load");
        }
        fis.close ();
    } catch (IOException ioe) {
        System.out.println ("Failed to load");
    }
    return null;
}
----------------------------------------

public static List load () {
    List list = new ArrayList ();
    File f = new File ("savefile.dat");
    try {
        FileInputStream fis = new FileInputStream (f);
        ObjectInputStream ois = new ObjectInputStream (fis);
        try {
            list = (ArrayList < Info >) ois.readObject ();
        } catch (ClassNotFoundException cnfe) {
            System.out.println ("Failed to load");
        }
        fis.close ();
    } catch (IOException ioe) {
        System.out.println ("Failed to load");
    }
    return list;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12795855_12795933_2_15
12795855_12795958_6_31
Title: Print different array elements 
----------------------------------------

public static void main (String [] args) {
    String [] deck = {"Clubs", "Hearts", "Diamonds", "Spades"};
    String [] suit = {"2", "3", "4", "5", "6", "7", "8", "9", "10", "Jack", "Queen", "King", "Aces"};
    for (int a = 0;
    a < 7; a ++) {
        int i = (int) (Math.random () * deck.length);
        int j = (int) (Math.random () * suit.length);
        System.out.println ("Deck " + deck [i] + " Suit " + suit [j]);
    }
    System.out.println ();
}
----------------------------------------

public static void main (String [] args) {
    String [] deck = {"Clubs", "Hearts", "Diamonds", "Spades"};
    String [] suit = {"2", "3", "4", "5", "6", "7", "8", "9", "10", "Jack", "Queen", "King", "Aces"};
    Set < String > s = new HashSet < String > ();
    int totalCards = 0;
    while (s.size () < (deck.length * suit.length)) {
        int i = (int) (Math.random () * deck.length);
        int j = (int) (Math.random () * suit.length);
        if (! s.contains ("Deck " + deck [i] + " Suit " + suit [j])) {
            s.add ("Deck " + deck [i] + " Suit " + suit [j]);
            totalCards ++;
        }
    }
    System.out.println ("Cards at Random: ");
    for (String str : s) System.out.println (str);

    System.out.println ("Total Cards: " + totalCards);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12796419_12796515_2_20
12796419_12796626_9_35
Title: Count the number of occurrences in a string array 
----------------------------------------

public static void main (String [] args) {
    String [] suit = {"Clubs", "Hearts", "Diamonds", "Spades"};
    String [] deck = {"2", "3", "4", "5", "6", "7", "8", "9", "10", "Jack", "Queen", "King", "Aces"};
    int counts [] = new int [4];
    for (int a = 0;
    a < 7; a ++) {
        int i = (int) (Math.random () * suit.length);
        int j = (int) (Math.random () * deck.length);
        System.out.println (suit [i] + " : " + deck [j]);
        counts [i] ++;
    }
    System.out.println ();
    for (int i = 0;
    i < 4; ++ i) {
        System.out.println (suit [i] + " : " + counts [i]);
    }
}
----------------------------------------

public static void main (String [] args) {
    List < String > list = new ArrayList < String > ();
    list.add ("Clubs - 8");
    list.add ("Clubs - Ace");
    list.add ("Clubs - Jack");
    list.add ("Hearts - 9");
    list.add ("Spades - 3");
    list.add ("Hearts - 6");
    Map < String, Integer > countMap = new HashMap < String, Integer > ();
    for (String card : list) {
        String suit = card.split ("-") [0].trim ();
        String deck = card.split ("-") [0].trim ();
        if (countMap.containsKey (suit)) {
            countMap.put (suit, countMap.get (suit) + 1);
        } else {
            countMap.put (suit, 0);
        }
    }
    System.out.println ("Count of cards:");
    for (String card : countMap.keySet ()) {
        System.out.println (card + ":" + countMap.get (card));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12799640_12800309_3_38
12799640_12800669_13_21
Title: "Why does JSplitPane add a border to my components and how do I stop it?" 
----------------------------------------

public static void main (String [] args) {
    JSplitPane sp = new JSplitPane (JSplitPane.VERTICAL_SPLIT, makePanel (), makePanel ());
    SplitPaneUI ui = sp.getUI ();
    if (ui instanceof BasicSplitPaneUI) {
        ((BasicSplitPaneUI) ui).getDivider ().setBorder (null);
    }
    sp.setBorder (BorderFactory.createEmptyBorder ());
    sp = new JSplitPane (JSplitPane.VERTICAL_SPLIT, makePanel (), sp);
    ui = sp.getUI ();
    if (ui instanceof BasicSplitPaneUI) {
        ((BasicSplitPaneUI) ui).getDivider ().setBorder (null);
    }
    sp.setBorder (BorderFactory.createEmptyBorder ());
    sp = new JSplitPane (JSplitPane.VERTICAL_SPLIT, makePanel (), sp);
    ui = sp.getUI ();
    if (ui instanceof BasicSplitPaneUI) {
        ((BasicSplitPaneUI) ui).getDivider ().setBorder (null);
    }
    sp.setBorder (BorderFactory.createEmptyBorder ());
    sp = new JSplitPane (JSplitPane.VERTICAL_SPLIT, makePanel (), sp);
    ui = sp.getUI ();
    if (ui instanceof BasicSplitPaneUI) {
        ((BasicSplitPaneUI) ui).getDivider ().setBorder (null);
    }
    sp.setBorder (BorderFactory.createEmptyBorder ());
    JFrame frame = new JFrame ("JSplitPane Toy");
    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    frame.setContentPane (sp);
    frame.pack ();
    frame.setVisible (true);
}
----------------------------------------

public static void main (String [] args) {
    UIManager.getDefaults ().put ("SplitPane.border", BorderFactory.createEmptyBorder ());
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            new JSplitPaneToy ().initUI ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12800588_12800801_1_17
12800588_40342982_1_14
Title: How to calculate a file size from URL in java 
----------------------------------------

private static int getFileSize (URL url) {
    URLConnection conn = null;
    try {
        conn = url.openConnection ();
        if (conn instanceof HttpURLConnection) {
            ((HttpURLConnection) conn).setRequestMethod ("HEAD");
        }
        conn.getInputStream ();
        return conn.getContentLength ();
    } catch (IOException e) {
        throw new RuntimeException (e);
    } finally {
        if (conn instanceof HttpURLConnection) {
            ((HttpURLConnection) conn).disconnect ();
        }
    }
}
----------------------------------------

public long getFileSize (URL url) {
    HttpURLConnection conn = null;
    try {
        conn = (HttpURLConnection) url.openConnection ();
        conn.setRequestMethod ("HEAD");
        return conn.getContentLengthLong ();
    } catch (IOException e) {
        throw new RuntimeException (e);
    } finally {
        if (conn != null) {
            conn.disconnect ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12809396_12809548_1_11
12809396_12809922_41_48
Title: IllegalComponentStateException in Java Swing 
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            ModalDialogsTest newWindow = new ModalDialogsTest ();
            newWindow.setVisible (true);
        }}

    );
}
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            new ModalDialogsTest ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12810460_12810518_9_30
12810460_12811691_76_86
Title: JOptionPane - input dialog box program 
----------------------------------------

public static void main (String [] args) {
    String test1 = JOptionPane.showInputDialog ("Please input mark for test 1: ");
    String test2 = JOptionPane.showInputDialog ("Please input mark for test 2: ");
    String test3 = JOptionPane.showInputDialog ("Please input mark for test 3: ");
    int int1 = Integer.parseInt (test1);
    int int2 = Integer.parseInt (test2);
    int int3 = Integer.parseInt (test3);
    SortedSet < Integer > set = new TreeSet < > ();
    set.add (int1);
    set.add (int2);
    set.add (int3);
    Integer [] intArray = set.toArray (new Integer [3]);
    JFrame frame = new JFrame ();
    JOptionPane.showInternalMessageDialog (frame.getContentPane (), String.format ("Result %f", (intArray [1] + intArray [2]) / 2.0));
}
----------------------------------------

public static void main (String...args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            new AverageExample ().displayGUI ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12812040_12812103_1_12
12812040_12812160_3_12
Title: How to fix code to remove -Xlint:unchecked warning while compiling 
----------------------------------------

public boolean contains (E obj) {
    Node < E > curr = head;
    while (curr != null) {
        if (curr.data.equals (obj)) {
            return true;
        }
        curr = curr.next ();
    }
    return false;
}
----------------------------------------

public boolean contains (E obj) {
    Node < E > curr = head;
    while (curr != null) {
        if (obj.compareTo (curr.data) == 0) {
            return true;
        }
        curr = curr.next;
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12819676_12819885_19_27
12819676_12819885_7_15
Title: Problems related to mutexes in Java 
----------------------------------------

public void run () {
    synchronized (b) {
        try {
            Thread.sleep (1000);
        } catch (Exception e) {
        }
        synchronized (a) {
            System.out.println ("Acquired b, then a.");
        }
    }
}
----------------------------------------

public void run () {
    synchronized (a) {
        try {
            Thread.sleep (1000);
        } catch (Exception e) {
        }
        synchronized (b) {
            System.out.println ("Acquired a, then b.");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12830501_12830549_1_11
12830501_12830590_1_11
Title: What's wrong with my code. 
----------------------------------------

public float getPercentFailing (float [] grades) {
    int failed = 0;
    for (int i = 0;
    i < grades.length; i ++) {
        if (grades [i] < 0.6) {
            failed ++;
        }
    }
    return ((float) failed) / grades.length;
}
----------------------------------------

public float getPercentFailing (float [] grades) {
    int count = 0;
    float sum = 0;
    for (int i = 0;
    i < grades.length; i ++) {
        float grade = grades [i];
        if (grade < 0.6) sum = sum + grades [i];

        count ++;
    }
    return sum / count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12831759_12831859_1_16
12831759_12832043_1_20
Title: I can't get the Union of two arrayLists 
----------------------------------------

public static < E > ArrayList < E > union (ArrayList < E > array1, ArrayList < E > array2) {
    ArrayList < E > arrayUnion = new ArrayList < E > (array1);
    E current;
    for (int i = 0;
    i < arrayUnion.size (); i ++) {
        current = arrayUnion.get (i);
        if (! array2.contains (current)) {
            arrayUnion.remove (current);
        }
    }
    return arrayUnion;
}
----------------------------------------

public static < E > ArrayList < E > union (ArrayList < E > array1, ArrayList < E > array2) {
    ArrayList < E > arrayUnion = new ArrayList < E > (array1);
    arrayUnion.addAll (array2);
    E current;
    for (int i = 0;
    i < arrayUnion.size (); i ++) {
        for (int j = 0;
        j < arrayUnion.size (); j ++) {
            current = arrayUnion.get (i);
            if (i != j && current.equals (arrayUnion.get (j))) {
                arrayUnion.remove (j);
                -- j;
            }
        }
    }
    return arrayUnion;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12832847_12849674_20_70
12832847_12862163_9_45
Title: JTree setSelectionPaths takes too long to expand 
----------------------------------------

public JTreeExpanding () {
    super (BoxLayout.Y_AXIS);
    glassPane.setOpaque (false);
    DefaultMutableTreeNode root = new DefaultMutableTreeNode ("Root");
    for (int i = 0;
    i < 14000; i ++) {
        DefaultMutableTreeNode node = new DefaultMutableTreeNode ("Root" + i);
        node.add (new DefaultMutableTreeNode ("Child" + i));
        root.add (node);
    }
    final JTree tree = new JTree (root);
    tree.setRootVisible (false);
    final JScrollPane pane = new JScrollPane (tree);
    add (pane);
    JButton button = new JButton ("Expand");
    button.addActionListener (new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent e) {
            Thread t = new Thread (new Runnable () {
                @Override
                public void run () {
                    final TreePath [] paths = tree.getSelectionPaths ();
                    tree.setSelectionPath (paths [0]);
                    for (int i = 0;
                    i < paths.length; i ++) {
                        tree.expandPath (paths [i]);
                    }
                    glassPane.setVisible (false);
                }}

            );
            getRootPane ().setGlassPane (glassPane);
            glassPane.setVisible (true);
            t.start ();
        }}

    );
    add (button);
    glassPane.addMouseWheelListener (new MouseWheelListener () {
        @Override
        public void mouseWheelMoved (MouseWheelEvent e) {
            for (MouseWheelListener mwl : pane.getMouseWheelListeners ()) {
                mwl.mouseWheelMoved (e);
            }
        }}

    );
}
----------------------------------------

public JTreeExpanding () {
    super (BoxLayout.Y_AXIS);
    DefaultMutableTreeNode root = new DefaultMutableTreeNode ("Root");
    for (int i = 0;
    i < 14000; i ++) {
        DefaultMutableTreeNode node = new DefaultMutableTreeNode ("Root" + i);
        node.add (new DefaultMutableTreeNode ("Child" + i));
        root.add (node);
    }
    final CustomTree tree = new CustomTree (root);
    tree.setRootVisible (false);
    final JScrollPane pane = new JScrollPane (tree);
    add (pane);
    JButton button = new JButton ("Expand");
    button.addActionListener (new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent e) {
            long start = System.currentTimeMillis ();
            tree.expandSelectedPaths ();
            System.out.println (System.currentTimeMillis () - start);
        }}

    );
    add (button);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12835730_12835800_30_39
12835730_12835800_5_43
Title: JTextArea not updating after display jdialog 
----------------------------------------

public void run () {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            System.out.println ("Hello");
            area.setText ("zzzz");
        }}

    );
}
----------------------------------------

public void run () {
    try {
        UIManager.setLookAndFeel (UIManager.getSystemLookAndFeelClassName ());
    } catch (ClassNotFoundException ex) {
    } catch (InstantiationException ex) {
    } catch (IllegalAccessException ex) {
    } catch (UnsupportedLookAndFeelException ex) {
    }
    JFrame frame = new JFrame ();
    frame.setBounds (0, 0, 500, 500);
    frame.setVisible (true);
    JDialog dialog = new JDialog (frame);
    dialog.setModal (true);
    JPanel panel = new JPanel ();
    dialog.add (panel);
    final JTextArea area = new JTextArea ();
    panel.add (area);
    dialog.setBounds (100, 100, 200, 200);
    area.setLineWrap (true);
    area.setText ("bbbbbbbbbbbb");
    new Thread (new Runnable () {
        @Override
        public void run () {
            SwingUtilities.invokeLater (new Runnable () {
                @Override
                public void run () {
                    System.out.println ("Hello");
                    area.setText ("zzzz");
                }}

            );
        }}

    ).start ();
    dialog.setVisible (true);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12835852_45704524_19_38
12835852_45704524_1_17
Title: Printing Map of Arrays 
----------------------------------------

public static String toString (Map map) {
    if (map == null) return "null";

    final StringBuilder b = new StringBuilder ("{");
    for (Object key : map.keySet ()) {
        final Object value = map.get (key);
        b.append (key).append ("=");
        if (value == null) {
            b.append ("null");
        } else {
            if (value.getClass ().isArray ()) {
                b.append (toString ((Object []) value, ", "));
            } else if (value instanceof Map) {
                b.append (toString ((Map) value));
            } else {
                b.append (value);
            }

        }
    }
    return b.append ("}").toString ();
}
----------------------------------------

public static String toString (Object [] array) {
    if (array == null) return "null";

    final StringBuilder b = new StringBuilder ("[");
    for (Object o : array) {
        if (b.length () > 0) b.append (", ");

        if (o == null) {
            b.append ("null");
        } else if (o instanceof Map) {
            b.append (toString ((Map) o));
        } else if (o.getClass ().isArray ()) {
            b.append (toString ((Object []) o));
        } else {
            b.append (o.toString ());
        }

    }
    return b.append ("]").toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12837592_12840519_5_18
12837592_35782732_1_18
Title: How to scroll to make a Node within the content of a ScrollPane visible? 
----------------------------------------

private static void ensureVisible (ScrollPane pane, Node node) {
    double width = pane.getContent ().getBoundsInLocal ().getWidth ();
    double height = pane.getContent ().getBoundsInLocal ().getHeight ();
    double x = node.getBoundsInParent ().getMaxX ();
    double y = node.getBoundsInParent ().getMaxY ();
    pane.setVvalue (y / height);
    pane.setHvalue (x / width);
    node.requestFocus ();
}
----------------------------------------

private static void ensureVisible (ScrollPane pane, Node node) {
    Bounds viewport = scrollPane.getViewportBounds ();
    double contentHeight = scrollPane.getContent ().localToScene (scrollPane.getContent ().getBoundsInLocal ()).getHeight ();
    double nodeMinY = node.localToScene (node.getBoundsInLocal ()).getMinY ();
    double nodeMaxY = node.localToScene (node.getBoundsInLocal ()).getMaxY ();
    double vValueDelta = 0;
    double vValueCurrent = scrollPane.getVvalue ();
    if (nodeMaxY < 0) {
        vValueDelta = (nodeMinY - viewport.getHeight ()) / contentHeight;
    } else if (nodeMinY > viewport.getHeight ()) {
        vValueDelta = (nodeMinY + viewport.getHeight ()) / contentHeight;
    }

    scrollPane.setVvalue (vValueCurrent + vValueDelta);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12845208_12845811_11_25
12845208_40317052_1_16
Title: How to print Two-Dimensional Array like table 
----------------------------------------

public static void main (String [] args) {
    int twoDm [] [] = new int [7] [5];
    int i, j, k = 1;
    for (i = 0; i < 7; i ++) {
        for (j = 0; j < 5; j ++) {
            twoDm [i] [j] = k;
            k ++;
        }
    }
    for (int [] row : twoDm) {
        printRow (row);
    }
}
----------------------------------------

public static void main (String [] args) {
    int [] [] matrix = {{1, 2, 5}, {3, 4, 6}, {7, 8, 9}};
    System.out.println (" ** Matrix ** ");
    for (int rows = 0;
    rows < 3; rows ++) {
        System.out.println ("\n");
        for (int columns = 0;
        columns < matrix [rows].length; columns ++) {
            System.out.print (matrix [rows] [columns] + "\t");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12850461_12850981_35_48
12850461_12850981_54_64
Title: Sorting Arrays With Pairs of Numbers 
----------------------------------------

public int compare (EdgeI e1, EdgeI e2) {
    if (e1.from < e2.from) return 1;

    if (e1.from > e2.from) return - 1;

    if (e1.to < e2.to) return 1;

    if (e1.to > e2.to) return - 1;

    return 0;
}
----------------------------------------

public int compare (EdgeI e1, EdgeI e2) {
    if (e1.from < e2.from) {
        return - 1;
    } else if (e1.from == e2.from) {
        if (e1.to < e2.to) {
            return - 1;
        } else if (e1.to == e2.to) {
            return 0;
        } else if (e1.to > e2.to) {
            return 1;
        }

    }

    return 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12853121_12853188_1_13
12853121_12853313_1_10
Title: How to compare two array lists for similar objects which differ in at least one property in java? 
----------------------------------------

@override
public boolean equals (Object obj) {
    User other = (User) obj;
    if (this.id == other.id && this.empCode.equals (other.empCode) && this.firstname.equals (other.firstname) && this.lastname.equals (other.lastname) && this.email.equals (other.email)) {
        return true;
    } else {
        return false;
    }
}
----------------------------------------

@Override
public boolean equals (Object obj) {
    if (obj == null) return false;

    if (! (obj instanceof User)) return false;

    User u = (User) obj;
    return this.empCode == null ? false : this.empCode.equals (u.empCode);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12860478_28362360_1_26
12860478_46685817_6_50
Title: Tab key navigation in JavaFX TextArea 
----------------------------------------

@Override
public void handle (KeyEvent event) {
    if (event.getCode ().equals (KeyCode.TAB)) {
        Node node = (Node) event.getSource ();
        if (node instanceof TextField) {
            TextFieldSkin skin = (TextFieldSkin) ((TextField) node).getSkin ();
            if (event.isShiftDown ()) {
                skin.getBehavior ().traversePrevious ();
            } else {
                skin.getBehavior ().traverseNext ();
            }
        } else if (node instanceof TextArea) {
            TextAreaSkin skin = (TextAreaSkin) ((TextArea) node).getSkin ();
            if (event.isShiftDown ()) {
                skin.getBehavior ().traversePrevious ();
            } else {
                skin.getBehavior ().traverseNext ();
            }
        }

        event.consume ();
    }
}
----------------------------------------

public void handle (final KeyEvent event) {
    if (! KeyCode.TAB.equals (event.getCode ())) {
        return;
    }
    if (event.isAltDown () || event.isMetaDown () || event.isShiftDown ()) {
        return;
    }
    if (! (event.getSource () instanceof TextArea)) {
        return;
    }
    final TextArea textArea = (TextArea) event.getSource ();
    if (event.isControlDown ()) {
        if (! FOCUS_EVENT_TEXT.equalsIgnoreCase (event.getText ())) {
            event.consume ();
            textArea.replaceSelection ("\t");
        }
    } else {
        event.consume ();
        final KeyEvent tabControlEvent = new KeyEvent (event.getSource (), event.getTarget (), event.getEventType (), event.getCharacter (), FOCUS_EVENT_TEXT, event.getCode (), event.isShiftDown (), true, event.isAltDown (), event.isMetaDown ());
        textArea.fireEvent (tabControlEvent);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12860478_28362360_1_26
12860478_47512769_7_27
Title: Tab key navigation in JavaFX TextArea 
----------------------------------------

@Override
public void handle (KeyEvent event) {
    if (event.getCode ().equals (KeyCode.TAB)) {
        Node node = (Node) event.getSource ();
        if (node instanceof TextField) {
            TextFieldSkin skin = (TextFieldSkin) ((TextField) node).getSkin ();
            if (event.isShiftDown ()) {
                skin.getBehavior ().traversePrevious ();
            } else {
                skin.getBehavior ().traverseNext ();
            }
        } else if (node instanceof TextArea) {
            TextAreaSkin skin = (TextAreaSkin) ((TextArea) node).getSkin ();
            if (event.isShiftDown ()) {
                skin.getBehavior ().traversePrevious ();
            } else {
                skin.getBehavior ().traverseNext ();
            }
        }

        event.consume ();
    }
}
----------------------------------------

public void handle (KeyEvent event) {
    if (event.getCode ().equals (KeyCode.TAB)) {
        Node node = (Node) event.getSource ();
        if (node instanceof TextArea) {
            TextAreaSkin skin = (TextAreaSkin) ((TextArea) node).getSkin ();
            if (! event.isControlDown ()) {
                if (event.isShiftDown ()) {
                    skin.getBehavior ().traversePrevious ();
                } else {
                    skin.getBehavior ().traverseNext ();
                }
            } else {
                TextArea textArea = (TextArea) node;
                textArea.replaceSelection ("\t");
            }
            event.consume ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12860478_28362360_1_26
12860478_47645973_1_18
Title: Tab key navigation in JavaFX TextArea 
----------------------------------------

@Override
public void handle (KeyEvent event) {
    if (event.getCode ().equals (KeyCode.TAB)) {
        Node node = (Node) event.getSource ();
        if (node instanceof TextField) {
            TextFieldSkin skin = (TextFieldSkin) ((TextField) node).getSkin ();
            if (event.isShiftDown ()) {
                skin.getBehavior ().traversePrevious ();
            } else {
                skin.getBehavior ().traverseNext ();
            }
        } else if (node instanceof TextArea) {
            TextAreaSkin skin = (TextAreaSkin) ((TextArea) node).getSkin ();
            if (event.isShiftDown ()) {
                skin.getBehavior ().traversePrevious ();
            } else {
                skin.getBehavior ().traverseNext ();
            }
        }

        event.consume ();
    }
}
----------------------------------------

@Override
public void handle (KeyEvent event) {
    KeyCode code = event.getCode ();
    if (code == KeyCode.TAB && ! event.isShiftDown () && ! event.isControlDown ()) {
        event.consume ();
        Node node = (Node) event.getSource ();
        KeyEvent newEvent = new KeyEvent (event.getSource (), event.getTarget (), event.getEventType (), event.getCharacter (), event.getText (), event.getCode (), event.isShiftDown (), true, event.isAltDown (), event.isMetaDown ());
        node.fireEvent (newEvent);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12860478_46685817_6_50
12860478_47512769_7_27
Title: Tab key navigation in JavaFX TextArea 
----------------------------------------

public void handle (final KeyEvent event) {
    if (! KeyCode.TAB.equals (event.getCode ())) {
        return;
    }
    if (event.isAltDown () || event.isMetaDown () || event.isShiftDown ()) {
        return;
    }
    if (! (event.getSource () instanceof TextArea)) {
        return;
    }
    final TextArea textArea = (TextArea) event.getSource ();
    if (event.isControlDown ()) {
        if (! FOCUS_EVENT_TEXT.equalsIgnoreCase (event.getText ())) {
            event.consume ();
            textArea.replaceSelection ("\t");
        }
    } else {
        event.consume ();
        final KeyEvent tabControlEvent = new KeyEvent (event.getSource (), event.getTarget (), event.getEventType (), event.getCharacter (), FOCUS_EVENT_TEXT, event.getCode (), event.isShiftDown (), true, event.isAltDown (), event.isMetaDown ());
        textArea.fireEvent (tabControlEvent);
    }
}
----------------------------------------

public void handle (KeyEvent event) {
    if (event.getCode ().equals (KeyCode.TAB)) {
        Node node = (Node) event.getSource ();
        if (node instanceof TextArea) {
            TextAreaSkin skin = (TextAreaSkin) ((TextArea) node).getSkin ();
            if (! event.isControlDown ()) {
                if (event.isShiftDown ()) {
                    skin.getBehavior ().traversePrevious ();
                } else {
                    skin.getBehavior ().traverseNext ();
                }
            } else {
                TextArea textArea = (TextArea) node;
                textArea.replaceSelection ("\t");
            }
            event.consume ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12860478_46685817_6_50
12860478_47645973_1_18
Title: Tab key navigation in JavaFX TextArea 
----------------------------------------

public void handle (final KeyEvent event) {
    if (! KeyCode.TAB.equals (event.getCode ())) {
        return;
    }
    if (event.isAltDown () || event.isMetaDown () || event.isShiftDown ()) {
        return;
    }
    if (! (event.getSource () instanceof TextArea)) {
        return;
    }
    final TextArea textArea = (TextArea) event.getSource ();
    if (event.isControlDown ()) {
        if (! FOCUS_EVENT_TEXT.equalsIgnoreCase (event.getText ())) {
            event.consume ();
            textArea.replaceSelection ("\t");
        }
    } else {
        event.consume ();
        final KeyEvent tabControlEvent = new KeyEvent (event.getSource (), event.getTarget (), event.getEventType (), event.getCharacter (), FOCUS_EVENT_TEXT, event.getCode (), event.isShiftDown (), true, event.isAltDown (), event.isMetaDown ());
        textArea.fireEvent (tabControlEvent);
    }
}
----------------------------------------

@Override
public void handle (KeyEvent event) {
    KeyCode code = event.getCode ();
    if (code == KeyCode.TAB && ! event.isShiftDown () && ! event.isControlDown ()) {
        event.consume ();
        Node node = (Node) event.getSource ();
        KeyEvent newEvent = new KeyEvent (event.getSource (), event.getTarget (), event.getEventType (), event.getCharacter (), event.getText (), event.getCode (), event.isShiftDown (), true, event.isAltDown (), event.isMetaDown ());
        node.fireEvent (newEvent);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12860478_47512769_7_27
12860478_47645973_1_18
Title: Tab key navigation in JavaFX TextArea 
----------------------------------------

public void handle (KeyEvent event) {
    if (event.getCode ().equals (KeyCode.TAB)) {
        Node node = (Node) event.getSource ();
        if (node instanceof TextArea) {
            TextAreaSkin skin = (TextAreaSkin) ((TextArea) node).getSkin ();
            if (! event.isControlDown ()) {
                if (event.isShiftDown ()) {
                    skin.getBehavior ().traversePrevious ();
                } else {
                    skin.getBehavior ().traverseNext ();
                }
            } else {
                TextArea textArea = (TextArea) node;
                textArea.replaceSelection ("\t");
            }
            event.consume ();
        }
    }
}
----------------------------------------

@Override
public void handle (KeyEvent event) {
    KeyCode code = event.getCode ();
    if (code == KeyCode.TAB && ! event.isShiftDown () && ! event.isControlDown ()) {
        event.consume ();
        Node node = (Node) event.getSource ();
        KeyEvent newEvent = new KeyEvent (event.getSource (), event.getTarget (), event.getEventType (), event.getCharacter (), event.getText (), event.getCode (), event.isShiftDown (), true, event.isAltDown (), event.isMetaDown ());
        node.fireEvent (newEvent);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12863016_12866226_1_15
12863016_12867165_10_24
Title: How to use String.format to convert a long to a String in currency format in Java 
----------------------------------------

public static void main (String [] args) {
    DecimalFormat f = new DecimalFormat ("$#,##0.00;-$#,##0.00");
    long num1 = 9287;
    long num2 = - 9287;
    long num3 = 100000000;
    long num4 = 49;
    System.out.println ("num1 = " + f.format (num1 / 100.0));
    System.out.println ("num2 = " + f.format (num2 / 100.0));
    System.out.println ("num3 = " + f.format (num3 / 100.0));
    System.out.println ("num4 = " + f.format (num4 / 100.0));
}
----------------------------------------

public static void main (String [] args) {
    long value;
    value = 9287;
    print (value);
    value = - 9287;
    print (value);
    value = 100000000;
    print (value);
    value = 49;
    print (value);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12864998_12867757_14_60
12864998_12867849_112_124
Title: JTable Calls Custom Cell Renderer Method... Continuously 
----------------------------------------

public Component getTableCellRendererComponent (JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
    System.out.println ("Line Wrap Cell Renderer Called: " + numOfTimesCalled ++);
    System.out.println ("row:" + row + ", col:" + column);
    int fontHeight = this.getFontMetrics (this.getFont ()).getHeight ();
    int numWraps = value.toString ().split ("\r\n|\r|\n").length;
    int rowHeight = fontHeight * numWraps;
    if (rowHeight != table.getRowHeight (row)) {
        table.setRowHeight (row, rowHeight);
        setWrapStyleWord (true);
        setLineWrap (true);
        setFont (table.getFont ());
    }
    if (isSelected) {
        setBackground (table.getSelectionBackground ());
    } else {
        if (row % 2 == 1) {
            setBackground (UIManager.getColor ("Table.alternateRowColor"));
        } else {
            setBackground (table.getBackground ());
        }
    }
    this.setText (value.toString ());
    return this;
}
----------------------------------------

public Component getTableCellRendererComponent (JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
    if (isSelected) {
        setForeground (table.getSelectionForeground ());
        setBackground (table.getSelectionBackground ());
    } else {
        setForeground (table.getForeground ());
        setBackground (table.getBackground ());
        setBackground ((row % 2 == 0) ? evenColor : getBackground ());
    }
    setFont (table.getFont ());
    setText ((value == null) ? "" : value.toString ());
    return this;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12867000_12867139_1_11
12867000_14478567_1_11
Title: How to remove surrogate characters in Java? 
----------------------------------------

public static String removeSurrogates (String query) {
    StringBuilder sb = new StringBuilder ();
    for (int i = 0;
    i < query.length (); i ++) {
        char c = query.charAt (i);
        if (! (Character.isHighSurrogate (c) || Character.isLowSurrogate (c))) {
            sb.append (firstChar);
        }
    }
    return sb.toString ();
}
----------------------------------------

public static String removeSurrogates (String query) {
    StringBuilder sb = new StringBuilder ();
    for (int i = 0;
    i < query.length (); i ++) {
        char ch = query.charAt (i);
        if (Character.isHighSurrogate (ch)) i ++;
        else sb.append (ch);

    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12868514_12868639_10_27
12868514_12868716_127_139
Title: Worker thread blocking GUI repaint 
----------------------------------------

protected String doInBackground () throws Exception {
    try {
        publish ("Fetching preferences...");
        Thread.sleep (1000);
        publish ("Updating permissions...");
        Thread.sleep (1000);
        publish ("Scanning workbench...");
        Thread.sleep (1000);
        publish ("Finalizing...");
        Thread.sleep (2000);
        publish ("Finished...Please wait");
        Thread.sleep (1000);
        parent.getLayout ().show (parent.getMainFrame ().getContentPane (), "view.main");
    } catch (Exception e) {
    }
    return null;
}
----------------------------------------

protected String doInBackground () throws Exception {
    int counter = 0;
    while (counter < FINAL_VALUE) {
        firePropertyChange ("status", "", "value is: " + counter);
        try {
            Thread.sleep (100);
        } catch (InterruptedException ixe) {
        }
        counter ++;
    }
    return null;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12875366_12875411_2_10
12875366_19345037_2_10
Title: beginner java - printing a right triangle backwards 
----------------------------------------

public static void main (String [] args) {
    for (int i = 0;
    i < 100; i ++) {
        for (int j = 0;
        j < i; j ++) System.out.print (" ");

        for (int j = i;
        j < 100; j ++) System.out.print ("*");

        System.out.println ();
    }
}
----------------------------------------

public static void main (String [] args) {
    for (int i = 10;
    i > 0; i --) {
        for (int j = 1;
        j < i; j ++) System.out.print ("*");

        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12875366_12876201_2_10
12875366_19345037_2_10
Title: beginner java - printing a right triangle backwards 
----------------------------------------

public static void main (String [] args) {
    for (int i = 0;
    i < 100; i ++) {
        for (int j = 0;
        j < i; j ++) System.out.print (" ");

        for (int j = i;
        j < 100; j ++) System.out.print ("*");

        System.out.println ();
    }
}
----------------------------------------

public static void main (String [] args) {
    for (int i = 10;
    i > 0; i --) {
        for (int j = 1;
        j < i; j ++) System.out.print ("*");

        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12876471_12876494_3_37
12876471_12876542_13_35
Title: Switch Statement Survey 
----------------------------------------

public static void main (String [] args) {
    System.out.println ("What's your favorite kind music?: ");
    System.out.println ("1. Country");
    System.out.println ("2. Rock");
    System.out.println ("3. Heavy Metal");
    System.out.println ("4. Folk");
    try {
        BufferedReader bufferRead = new BufferedReader (new InputStreamReader (System.in));
        int s = Integer.parseInt (bufferRead.readLine ());
        switch (s) {
            case 1 :
                System.out.println ("Country");
                break;
            case 2 :
                System.out.println ("Rock");
                break;
            case 3 :
                System.out.println ("Heavy Metal");
                break;
            case 4 :
                System.out.println ("Folk");
                break;
            default :
                System.out.println ("Country");
                break;
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) {
    Map < Integer, String > musicOptions = new LinkedHashMap < Integer, String > ();
    musicOptions.put (1, DEFAULT_MUSIC);
    musicOptions.put (2, "Rock");
    musicOptions.put (3, "Heavy Metal");
    musicOptions.put (4, "Folk");
    out.println ("What's your favorite kind music?: ");
    for (Entry < Integer, String > option : musicOptions.entrySet ()) {
        Integer choice = option.getKey ();
        String music = option.getValue ();
        out.printf ("%d. %s\n", choice, music);
    }
    final int choice = new Scanner (in).nextInt ();
    String music = musicOptions.get (choice);
    if (music == null) {
        music = DEFAULT_MUSIC;
    }
    out.println (music);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12881782_12881912_76_84
12881782_12881912_87_95
Title: Java DB connection 
----------------------------------------

public static void close (Connection connection) {
    try {
        if (connection != null) {
            connection.close ();
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void close (Statement st) {
    try {
        if (st != null) {
            st.close ();
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12881782_12881912_76_84
12881782_12881912_97_105
Title: Java DB connection 
----------------------------------------

public static void close (Connection connection) {
    try {
        if (connection != null) {
            connection.close ();
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void close (ResultSet rs) {
    try {
        if (rs != null) {
            rs.close ();
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12881782_12881912_87_95
12881782_12881912_97_105
Title: Java DB connection 
----------------------------------------

public static void close (Statement st) {
    try {
        if (st != null) {
            st.close ();
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void close (ResultSet rs) {
    try {
        if (rs != null) {
            rs.close ();
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12886036_12886347_13_23
12886036_12886347_2_10
Title: deep copying a graph structure 
----------------------------------------

public Node deepCopy (Map < Node, Node > isomorphism) {
    Node copy = isomorphism.get (this);
    if (copy == null) {
        copy = new Node ();
        isomorphism.put (this, copy);
        for (Node connection : connections) {
            copy.connections.add (connection.deepCopy (isomorphism));
        }
    }
    return copy;
}
----------------------------------------

public Graph deepCopy () {
    Graph g = new Graph ();
    g.nodes = new ArrayList < Node > ();
    Map < Node, Node > isomorphism = new IdentityHashMap < Node, Node > ();
    for (Node n : nodes) {
        g.nodes.add (n.deepCopy (isomorphism));
    }
    return g;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12890661_12890872_1_18
12890661_12891162_13_51
Title: Java issue with scanner 
----------------------------------------

private static char getHighLow (Scanner inScanner) {
    System.out.print ("High, low or sevens (H/L/S):");
    String entered = inScanner.nextLine ();
    System.out.print (entered);
    if (entered.equals ("H") || entered.equals ("h")) {
        return 'h';
    } else if (entered.equals ("L") || entered.equals ("l")) {
        return 'l';
    } else if (entered.equals ("S") || entered.equals ("s")) {
        return 's';
    } else {
        System.out.println ("Invalid entry. Please try again using H/L/S!");
        return getHighLow (inScanner);
    }

}
----------------------------------------

private static String getHighLow (Scanner inScanner) {
    System.out.println ("High, low or sevens (H/L/S):");
    String entered;
    String result = "";
    boolean isCharFound = false;
    String temp = "";
    while (inScanner.hasNext ()) {
        temp = inScanner.next ();
        System.out.println (temp);
        for (int index = 0;
        index < temp.length (); index ++) {
            entered = new Character (temp.charAt (index)).toString ();
            if (entered.equals ("H") || entered.equals ("h")) {
                result = result + 'h';
                isCharFound = true;
            } else if (entered.equals ("L") || entered.equals ("l")) {
                result = result + 'l';
                isCharFound = true;
            } else if (entered.equals ("S") || entered.equals ("s")) {
                result = result + 's';
                isCharFound = true;
            }

            if (! isCharFound) {
                System.out.println ("Invalid entry. Please try again using H/L/S!");
            }
            isCharFound = false;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12893566_12897632_30_44
12893566_27260650_38_52
Title: Passing multiple variables in @RequestBody to a Spring MVC controller using Ajax 
----------------------------------------

private String getRequestBody (NativeWebRequest webRequest) {
    HttpServletRequest servletRequest = webRequest.getNativeRequest (HttpServletRequest.class);
    String jsonBody = (String) servletRequest.getAttribute (JSONBODYATTRIBUTE);
    if (jsonBody == null) {
        try {
            String body = IOUtils.toString (servletRequest.getInputStream ());
            servletRequest.setAttribute (JSONBODYATTRIBUTE, body);
            return body;
        } catch (IOException e) {
            throw new RuntimeException (e);
        }
    }
    return "";
}
----------------------------------------

private String getRequestBody (NativeWebRequest webRequest) {
    HttpServletRequest servletRequest = webRequest.getNativeRequest (HttpServletRequest.class);
    String jsonBody = (String) webRequest.getAttribute (JSONBODYATTRIBUTE, NativeWebRequest.SCOPE_REQUEST);
    if (jsonBody == null) {
        try {
            jsonBody = IOUtils.toString (servletRequest.getInputStream ());
            webRequest.setAttribute (JSONBODYATTRIBUTE, jsonBody, NativeWebRequest.SCOPE_REQUEST);
        } catch (IOException e) {
            throw new RuntimeException (e);
        }
    }
    return jsonBody;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12898187_12898413_1_18
12898187_12898498_1_13
Title: Stuck with while loop. In processing 
----------------------------------------

void setup () {
    int [] x = new int [100];
    int maxValue = 1768;
    int i;
    int sum = 0;
    while (sum < maxValue) {
        if (i % 2 == 0) {
            x [i] = i;
            sum += x [i];
            i ++;
        }
    }
    System.out.println (i + " Elements needed")
}
----------------------------------------

void setup () {
    int i = 0;
    int sum = 0;
    int counter = 0;
    while (sum < 1768) {
        sum += i;
        i += 2;
        counter ++;
    }
    System.out.println (counter);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12901302_12901466_76_86
12901302_12902608_21_30
Title: JAXB java.util.Map to key value pairs 
----------------------------------------

public MyMap marshal (Map < String, String > value) throws Exception {
    MyMap map = new MyMap ();
    map.entries = new ArrayList < MyEntry > ();
    for (String key : value.keySet ()) {
        MyEntry entry = new MyEntry ();
        entry.key = key;
        entry.value = value.get (key);
        map.entries.add (entry);
    }
    return map;
}
----------------------------------------

public MapWrapper marshal (Map < String, String > map) throws Exception {
    if (map == null) return null;

    MapWrapper w = new MapWrapper ();
    w.attributes = new HashMap < QName, Object > ();
    for (Map.Entry < String, String > entry : map.entrySet ()) {
        w.attributes.put (new QName (entry.getKey ()), entry.getValue ());
    }
    return w;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12902529_12903339_112_120
12902529_12903751_40_48
Title: JTextPane/JTextField strange behaviour with rare characters 
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            Fonts fs = new Fonts ();
        }}

    );
}
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            Scrap fs = new Scrap ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12909288_12910083_27_38
12909288_12910083_8_20
Title: "I can't finish thread (runnable) how it is?" 
----------------------------------------

public void run () {
    try {
        sleep (1000);
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    System.out.println ("Stopping recurring execution");
    mainThread.interrupt ();
}
----------------------------------------

public void run () {
    boolean continueExecution = true;
    while (continueExecution) {
        try {
            sleep (100);
            System.out.println ("Executing");
        } catch (InterruptedException e) {
            continueExecution = false;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12921410_12921485_1_14
12921410_12921491_1_12
Title: method declaration 
----------------------------------------

public static boolean checkInput (String zipcode) {
    if (zipcode.length () != 5) {
        return false;
    }
    for (int i = 0;
    i < zipcode.length (); i ++) {
        if (! Character.isDigit (zipcode.charAt (i))) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static boolean checkInput (String zipcode) {
    if (zipcode.length () != 5) {
        return false;
    }
    for (int i = 0;
    i < zipcode.length (); i ++) {
        char charAt = zipcode.charAt (i);
        if (! Character.isDigit (charAt)) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12921410_12921485_1_14
12921410_12921508_16_28
Title: method declaration 
----------------------------------------

public static boolean checkInput (String zipcode) {
    if (zipcode.length () != 5) {
        return false;
    }
    for (int i = 0;
    i < zipcode.length (); i ++) {
        if (! Character.isDigit (zipcode.charAt (i))) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static boolean checkInput (String zipcode) {
    boolean zipcodeLength = true;
    boolean zipcodeDigits = true;
    if (zipcode.length () != 5) {
        zipcodeLength = false;
    }
    for (int i = 0;
    i < zipcode.length (); i ++) {
        if (! Character.isDigit (zipcode.charAt (i))) {
            zipcodeDigits = false;
        }
    }
    return zipcodeLength && zipcodeDigits;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12921410_12921491_1_12
12921410_12921508_16_28
Title: method declaration 
----------------------------------------

public static boolean checkInput (String zipcode) {
    if (zipcode.length () != 5) {
        return false;
    }
    for (int i = 0;
    i < zipcode.length (); i ++) {
        char charAt = zipcode.charAt (i);
        if (! Character.isDigit (charAt)) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static boolean checkInput (String zipcode) {
    boolean zipcodeLength = true;
    boolean zipcodeDigits = true;
    if (zipcode.length () != 5) {
        zipcodeLength = false;
    }
    for (int i = 0;
    i < zipcode.length (); i ++) {
        if (! Character.isDigit (zipcode.charAt (i))) {
            zipcodeDigits = false;
        }
    }
    return zipcodeLength && zipcodeDigits;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12924430_12924532_1_12
12924430_12925817_5_21
Title: Basic recursion 
----------------------------------------

static void capitalizer (String a, int b) {
    if (b == - 1) {
        System.out.println (a);
    } else {
        char [] achars = a.toCharArray ();
        achars [b] -= 32;
        String caplet = new String (achars);
        capitalizer (caplet, b - 1);
        capitalizer (a, b - 1);
    }
}
----------------------------------------

private static void capitalizer (String prefix, String buffer) {
    if (buffer.isEmpty ()) {
        System.out.println (prefix);
        return;
    }
    char c = buffer.charAt (0);
    char cup = Character.toUpperCase (c);
    String p = prefix + c;
    String pup = prefix + cup;
    String b = buffer.length () == 0 ? "" : buffer.substring (1, buffer.length ());
    capitalizer (p, b);
    capitalizer (pup, b);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1292858_1293282_18_39
1292858_1293282_1_16
Title: Getting full string stack trace including inner exception 
----------------------------------------

public static void joinStackTrace (Throwable e, StringWriter writer) {
    PrintWriter printer = null;
    try {
        printer = new PrintWriter (writer);
        while (e != null) {
            printer.println (e);
            StackTraceElement [] trace = e.getStackTrace ();
            for (int i = 0;
            i < trace.length; i ++) printer.println ("\tat " + trace [i]);

            e = e.getCause ();
            if (e != null) printer.println ("Caused by:\r\n");

        }
    } finally {
        if (printer != null) printer.close ();

    }
}
----------------------------------------

public static String joinStackTrace (Throwable e) {
    StringWriter writer = null;
    try {
        writer = new StringWriter ();
        joinStackTrace (e, writer);
        return writer.toString ();
    } finally {
        if (writer != null) try {
            writer.close ();
        } catch (IOException e1) {
        }

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12928971_12930495_37_50
12928971_12932098_7_17
Title: Universal adapter for JAXB 
----------------------------------------

public static void main (String [] args) throws Exception {
    Person p = new Person ();
    p.firstName = "John";
    p.lastName = "Doe";
    JAXBContext jc = JAXBContext.newInstance (Person.class);
    StringWriter sw = new StringWriter ();
    jc.createMarshaller ().marshal (p, sw);
    String xml = sw.toString ();
    System.out.println (xml);
    StringReader sr = new StringReader (xml);
    p = (Person) jc.createUnmarshaller ().unmarshal (sr);
    assert "John".equals (p.firstName);
    assert "Doe".equals (p.lastName);
}
----------------------------------------

public static void main (String [] args) throws Exception {
    JAXBContext jc = JAXBContext.newInstance (Person.class);
    Unmarshaller unmarshaller = jc.createUnmarshaller ();
    File xml = new File ("src/forum12928971/input.xml");
    Person person = (Person) unmarshaller.unmarshal (xml);
    Marshaller marshaller = jc.createMarshaller ();
    marshaller.setProperty (Marshaller.JAXB_FORMATTED_OUTPUT, true);
    marshaller.marshal (person, System.out);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12929229_12929486_6_35
12929229_12940940_2_47
Title: Why does my simple UDPServer only receive packets from UDPClient only when it runs first? 
----------------------------------------

public static void main (String args []) throws Exception {
    while (true) {
        try {
            DatagramSocket clientSocket = new DatagramSocket ();
            InetAddress IPAddress = InetAddress.getByName ("localhost");
            byte [] sendData = new byte [100];
            byte [] receiveData = new byte [100];
            String sentence = "Hello Server!";
            sendData = sentence.getBytes ();
            DatagramPacket sendPacket = new DatagramPacket (sendData, sendData.length, IPAddress, 9876);
            clientSocket.send (sendPacket);
            DatagramPacket receivePacket = new DatagramPacket (receiveData, receiveData.length);
            clientSocket.receive (receivePacket);
            String modifiedSentence = new String (receivePacket.getData ());
            System.out.println ("FROM SERVER:" + modifiedSentence);
            clientSocket.close ();
        } catch (PortUnreachableException pe) {
            System.out.println ("COULDN'T CONNECT TO SERVER:" + pe.getMessage ());
        } catch (Exception ex) {
            System.out.println ("COULDN'T CONNECT TO SERVER:" + ex.getMessage ());
        }
        Thread.sleep (2000);
    }
}
----------------------------------------

public static void main (final String args []) throws Exception {
    final InetAddress IPAddress = InetAddress.getByName ("localhost");
    new Thread () {
        @Override
        public void run () {
            while (true) {
                DatagramSocket clientSocket = null;
                try {
                    clientSocket = new DatagramSocket ();
                    byte [] sendData = new byte [100];
                    final String sentence = "Hello Server!";
                    sendData = sentence.getBytes ();
                    final DatagramPacket sendPacket = new DatagramPacket (sendData, sendData.length, IPAddress, 9876);
                    clientSocket.send (sendPacket);
                    Thread.sleep (2000);
                } catch (final Exception e) {
                    e.printStackTrace ();
                } finally {
                    clientSocket.close ();
                }
            }
        }}

    .start ();
    new Thread () {
        @Override
        public void run () {
            DatagramSocket clientSocket = null;
            try {
                clientSocket = new DatagramSocket ();
            } catch (final SocketException e1) {
                e1.printStackTrace ();
            }
            while (true) {
                try {
                    final byte [] receiveData = new byte [100];
                    final DatagramPacket receivePacket = new DatagramPacket (receiveData, receiveData.length);
                    clientSocket.receive (receivePacket);
                    final String modifiedSentence = new String (receivePacket.getData ());
                    System.out.println ("FROM SERVER:" + modifiedSentence);
                } catch (final Exception e) {
                    e.printStackTrace ();
                }
            }
        }}

    .start ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12929229_12940940_27_45
12929229_12940940_6_23
Title: Why does my simple UDPServer only receive packets from UDPClient only when it runs first? 
----------------------------------------

public void run () {
    DatagramSocket clientSocket = null;
    try {
        clientSocket = new DatagramSocket ();
    } catch (final SocketException e1) {
        e1.printStackTrace ();
    }
    while (true) {
        try {
            final byte [] receiveData = new byte [100];
            final DatagramPacket receivePacket = new DatagramPacket (receiveData, receiveData.length);
            clientSocket.receive (receivePacket);
            final String modifiedSentence = new String (receivePacket.getData ());
            System.out.println ("FROM SERVER:" + modifiedSentence);
        } catch (final Exception e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------

public void run () {
    while (true) {
        DatagramSocket clientSocket = null;
        try {
            clientSocket = new DatagramSocket ();
            byte [] sendData = new byte [100];
            final String sentence = "Hello Server!";
            sendData = sentence.getBytes ();
            final DatagramPacket sendPacket = new DatagramPacket (sendData, sendData.length, IPAddress, 9876);
            clientSocket.send (sendPacket);
            Thread.sleep (2000);
        } catch (final Exception e) {
            e.printStackTrace ();
        } finally {
            clientSocket.close ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12935738_12937042_32_48
12935738_12937127_20_38
Title: Implementing a simple UDP network that continuously broadcasts to its neighbours 
----------------------------------------

public void run () {
    while (true) {
        System.out.println ("Send ...");
        try {
            Thread.sleep (3000);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------

public void run () {
    try {
        DatagramSocket socket = new DatagramSocket (ownPort);
        byte [] buffer = new byte [socket.getReceiveBufferSize ()];
        DatagramPacket packet = new DatagramPacket (buffer, buffer.length);
        while (true) {
            socket.receive (packet);
            System.out.println ("Received string");
        }
    } catch (final Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12935738_12937042_9_26
12935738_12937127_20_38
Title: Implementing a simple UDP network that continuously broadcasts to its neighbours 
----------------------------------------

public void run () {
    while (true) {
        Scanner scanner = new Scanner (System.in);
        System.out.println ("read: " + scanner.next ());
        try {
            Thread.sleep (3000);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------

public void run () {
    try {
        DatagramSocket socket = new DatagramSocket (ownPort);
        byte [] buffer = new byte [socket.getReceiveBufferSize ()];
        DatagramPacket packet = new DatagramPacket (buffer, buffer.length);
        while (true) {
            socket.receive (packet);
            System.out.println ("Received string");
        }
    } catch (final Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12944765_12945116_12_26
12944765_12945176_1_30
Title: java homework(recursion) 
----------------------------------------

public static boolean isPestaina (String in) {
    if (in.equals ("ab")) {
        return true;
    }
    if (in.equals ("cbac")) {
        return true;
    }
    if (in.length () > 3) {
        if ((in.startsWith ("ab") || in.startsWith ("cbac")) && (in.endsWith ("ab") || in.endsWith ("cbac"))) {
            return true;
        }
    }
    return false;
}
----------------------------------------

public boolean isPestaina (String p) {
    Set < String > existingPestainas = new HashSet < String > (Arrays.asList (new String [] {"ab", "cbac"}));
    boolean isP = false;
    int lengthParsed = 0;
    do {
        if (lengthParsed > 0) {
            if (p.substring (lengthParsed).startsWith ("a") || p.substring (lengthParsed).startsWith ("b")) {
                lengthParsed ++;
            } else {
                return false;
            }
        }
        for (String existingP : existingPestainas) {
            if (p.substring (lengthParsed).startsWith (existingP)) {
                isP = true;
                lengthParsed += existingP.length ();
            }
        }
        if (isP) {
            System.err.println ("Adding pestaina: " + p.substring (0, lengthParsed));
            existingPestainas.add (p.substring (0, lengthParsed));
        }
    } while (isP && p.length () >= lengthParsed + 1);
    return isP;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12945001_13017082_32_52
12945001_13017082_68_86
Title: How to avoid race conditions on alternating synchronous threads? 
----------------------------------------

public void run () {
    System.out.println ("MyRunnable1 started");
    for (int c = 0;
    c < 50; ++ c) {
        synchronized (locker) {
            System.out.println ("r1: " + (c));
            locker.notify ();
            if (c == 49) {
                oneDone = true;
            }
            try {
                if (! oneDone) {
                    locker.wait ();
                }
            } catch (java.lang.InterruptedException e) {
                System.out.println ("e: " + e);
            }
        }
    }
}
----------------------------------------

public void run () {
    System.out.println ("MyRunnable1 started");
    for (int c = 0;
    c < 50; ++ c) {
        synchronized (sequenceLock) {
            while (_match != sequence) {
                try {
                    sequenceLock.wait ();
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
            System.out.println ("r" + _match + ":" + (c));
            sequence = ! sequence;
            sequenceLock.notify ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12945001_13017082_32_52
12945001_13017082_7_28
Title: How to avoid race conditions on alternating synchronous threads? 
----------------------------------------

public void run () {
    System.out.println ("MyRunnable1 started");
    for (int c = 0;
    c < 50; ++ c) {
        synchronized (locker) {
            System.out.println ("r1: " + (c));
            locker.notify ();
            if (c == 49) {
                oneDone = true;
            }
            try {
                if (! oneDone) {
                    locker.wait ();
                }
            } catch (java.lang.InterruptedException e) {
                System.out.println ("e: " + e);
            }
        }
    }
}
----------------------------------------

public void run () {
    System.out.println ("MyRunnable2 started");
    for (int c = 0;
    c < 50; ++ c) {
        synchronized (locker) {
            System.out.println ("r2: " + (c));
            locker.notify ();
            if (c == 49) {
                oneDone = true;
            }
            try {
                if (! oneDone) {
                    locker.wait ();
                }
            } catch (java.lang.InterruptedException e) {
                System.out.println ("e: " + e);
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12945001_13017082_68_86
12945001_13017082_7_28
Title: How to avoid race conditions on alternating synchronous threads? 
----------------------------------------

public void run () {
    System.out.println ("MyRunnable1 started");
    for (int c = 0;
    c < 50; ++ c) {
        synchronized (sequenceLock) {
            while (_match != sequence) {
                try {
                    sequenceLock.wait ();
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
            System.out.println ("r" + _match + ":" + (c));
            sequence = ! sequence;
            sequenceLock.notify ();
        }
    }
}
----------------------------------------

public void run () {
    System.out.println ("MyRunnable2 started");
    for (int c = 0;
    c < 50; ++ c) {
        synchronized (locker) {
            System.out.println ("r2: " + (c));
            locker.notify ();
            if (c == 49) {
                oneDone = true;
            }
            try {
                if (! oneDone) {
                    locker.wait ();
                }
            } catch (java.lang.InterruptedException e) {
                System.out.println ("e: " + e);
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12945537_12945678_85_95
12945537_15483338_1_11
Title: How to set output stream to TextArea 
----------------------------------------

public void write (int b) throws IOException {
    char c = (char) b;
    String value = Character.toString (c);
    buffer.append (value);
    if (value.equals ("\n")) {
        consumer.appendText (buffer.toString ());
        buffer.delete (0, buffer.length ());
        buffer.append ("[").append (prefix).append ("] ");
    }
    old.print (c);
}
----------------------------------------

@Override
public void write (int b) {
    if ('\n' == (char) b) {
        consumer.appendText (toString ());
        reset ();
    } else {
        super.write (b);
    }
    old.write (b);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12945537_12945678_85_95
12945537_17626400_27_40
Title: How to set output stream to TextArea 
----------------------------------------

public void write (int b) throws IOException {
    char c = (char) b;
    String value = Character.toString (c);
    buffer.append (value);
    if (value.equals ("\n")) {
        consumer.appendText (buffer.toString ());
        buffer.delete (0, buffer.length ());
        buffer.append ("[").append (prefix).append ("] ");
    }
    old.print (c);
}
----------------------------------------

private void write (String str) {
    String [] s = str.split ("\n", - 1);
    if (s.length == 0) return;

    for (int i = 0;
    i < s.length - 1; i ++) {
        writeWithPotentialIndent (s [i]);
        writeWithPotentialIndent ("\n");
        atLineStart = true;
    }
    String last = s [s.length - 1];
    if (! last.equals ("")) {
        writeWithPotentialIndent (last);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12945537_15483338_1_11
12945537_17626400_27_40
Title: How to set output stream to TextArea 
----------------------------------------

@Override
public void write (int b) {
    if ('\n' == (char) b) {
        consumer.appendText (toString ());
        reset ();
    } else {
        super.write (b);
    }
    old.write (b);
}
----------------------------------------

private void write (String str) {
    String [] s = str.split ("\n", - 1);
    if (s.length == 0) return;

    for (int i = 0;
    i < s.length - 1; i ++) {
        writeWithPotentialIndent (s [i]);
        writeWithPotentialIndent ("\n");
        atLineStart = true;
    }
    String last = s [s.length - 1];
    if (! last.equals ("")) {
        writeWithPotentialIndent (last);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12957427_12964952_10_33
12957427_12964952_78_96
Title: JFrame calling multiple concurrent Threads that updates a JProgressBar in the caller JFrame 
----------------------------------------

public void run () {
    try {
        UIManager.setLookAndFeel (UIManager.getSystemLookAndFeelClassName ());
    } catch (ClassNotFoundException ex) {
    } catch (InstantiationException ex) {
    } catch (IllegalAccessException ex) {
    } catch (UnsupportedLookAndFeelException ex) {
    }
    JPanel progressPane = new JPanel (new GridBagLayout ());
    JProgressBar progressBar = new JProgressBar (0, 100);
    progressPane.add (progressBar);
    JFrame frame = new JFrame ();
    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    frame.setLayout (new BorderLayout ());
    frame.add (progressPane);
    frame.setSize (200, 200);
    frame.setLocationRelativeTo (null);
    frame.setVisible (true);
    new Thread (new MainThread (progressBar)).start ();
}
----------------------------------------

public void run () {
    for (int index = 0;
    index < 5; index ++) {
        ChildSpawn spawn = new ChildSpawn (this);
        running.add (spawn);
    }
    for (Runnable runnable : running) {
        new Thread (runnable).start ();
    }
    while (running.size () > 0) {
        synchronized (WAIT_LOCK) {
            try {
                WAIT_LOCK.wait ();
            } catch (InterruptedException ex) {
            }
        }
    }
    System.out.println ("I'm all done");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12967896_17198116_1_121
12967896_37534256_7_21
Title: Converting Integers to Roman Numerals - Java 
----------------------------------------

String convert (int i) {
    String ones = "";
    String tens = "";
    String hundreds = "";
    String thousands = "";
    String result;
    boolean error = false;
    Vector v = new Vector ();
    int temp = i;
    if (temp >= 4000) {
        error = true;
    }
    while (temp / 10 != 0) {
        if (temp / 10 != 0 && temp < 4000) {
            v.add (temp % 10);
            temp = temp / 10;
        } else {
            break;
        }
    }
    v.add (temp);
    for (int j = 0;
    j < v.size (); j ++) {
        if (j == 0) {
            switch (v.get (0).toString ()) {
                case "0" :
                    ones = "";
                    break;
                case "1" :
                    ones = "I";
                    break;
                case "2" :
                    ones = "II";
                    break;
                case "3" :
                    ones = "III";
                    break;
                case "4" :
                    ones = "IV";
                    break;
                case "5" :
                    ones = "V";
                    break;
                case "6" :
                    ones = "VI";
                    break;
                case "7" :
                    ones = "VII";
                    break;
                case "8" :
                    ones = "VIII";
                    break;
                case "9" :
                    ones = "IX";
                    break;
            }
        } else if (j == 1) {
            switch (v.get (1).toString ()) {
                case "0" :
                    tens = "";
                    break;
                case "1" :
                    tens = "X";
                    break;
                case "2" :
                    tens = "XX";
                    break;
                case "3" :
                    tens = "XXX";
                    break;
                case "4" :
                    tens = "XL";
                    break;
                case "5" :
                    tens = "L";
                    break;
                case "6" :
                    tens = "LX";
                    break;
                case "7" :
                    tens = "LXX";
                    break;
                case "8" :
                    tens = "LXXX";
                    break;
                case "9" :
                    tens = "XC";
                    break;
            }
        } else if (j == 2) {
            switch (v.get (2).toString ()) {
                case "0" :
                    hundreds = "";
                    break;
                case "1" :
                    hundreds = "C";
                    break;
                case "2" :
                    hundreds = "CC";
                    break;
                case "3" :
                    hundreds = "CCC";
                    break;
                case "4" :
                    hundreds = "CD";
                    break;
                case "5" :
                    hundreds = "D";
                    break;
                case "6" :
                    hundreds = "DC";
                    break;
                case "7" :
                    hundreds = "DCC";
                    break;
                case "8" :
                    hundreds = "DCCC";
                    break;
                case "9" :
                    hundreds = "CM";
                    break;
            }
        } else if (j == 3) {
            switch (v.get (3).toString ()) {
                case "0" :
                    thousands = "";
                    break;
                case "1" :
                    thousands = "M";
                    break;
                case "2" :
                    thousands = "MM";
                    break;
                case "3" :
                    thousands = "MMM";
                    break;
            }
        }

    }
    if (error) {
        result = "Error!";
    } else {
        result = thousands + hundreds + tens + ones;
    }
    return result;
}
----------------------------------------

public static String convert (int arabicNumber) {
    StringBuilder romanNumerals = new StringBuilder ();
    int remainder = arabicNumber;
    for (int i = 0;
    i < arabic.length; i ++) {
        while (remainder >= arabic [i]) {
            romanNumerals.append (roman [i]);
            remainder -= arabic [i];
        }
    }
    return romanNumerals.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12967896_24982006_78_122
12967896_28972634_1_27
Title: Converting Integers to Roman Numerals - Java 
----------------------------------------

public static void main (String [] args) {
    for (int number = 1;
    number <= 3999; number ++) {
        String roman = of (number);
        int parsed = parse (roman);
        if (parsed != number) {
            System.err.format ("ERROR: number: %d, roman: %s, parsed: %d\n", number, roman, parsed);
        }
    }
    int [] illegalNumbers = {- 1, 0, 4000, 4001};
    for (int illegalNumber : illegalNumbers) {
        try {
            of (illegalNumber);
            System.err.format ("ERROR: Expected failure on number %d\n", illegalNumber);
        } catch (IllegalArgumentException e) {
        }
    }
    String [] illegalRomans = {"MMMM", "CDCD", "IM", "T", "", "VV", "DM"};
    for (String illegalRoman : illegalRomans) {
        try {
            parse (illegalRoman);
            System.err.format ("ERROR: Expected failure on roman %s\n", illegalRoman);
        } catch (NumberFormatException e) {
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int number = 2345;
    number = Math.min (3999, Math.max (1, number));
    String asRomanNumerals = "";
    String [] RN = {"I", "V", "X", "L", "C", "D", "M"};
    int i = 0;
    while (number > 0) {
        switch (number % 10) {
            case 1 :
                asRomanNumerals = RN [i] + asRomanNumerals;
                break;
            case 2 :
                asRomanNumerals = RN [i] + RN [i] + asRomanNumerals;
                break;
            case 3 :
                asRomanNumerals = RN [i] + RN [i] + RN [i] + asRomanNumerals;
                break;
            case 4 :
                asRomanNumerals = RN [i] + RN [i + 1] + asRomanNumerals;
                break;
            case 5 :
                asRomanNumerals = RN [i + 1] + asRomanNumerals;
                break;
            case 6 :
                asRomanNumerals = RN [i + 1] + RN [i] + asRomanNumerals;
                break;
            case 7 :
                asRomanNumerals = RN [i + 1] + RN [i] + RN [i] + asRomanNumerals;
                break;
            case 8 :
                asRomanNumerals = RN [i + 1] + RN [i] + RN [i] + RN [i] + asRomanNumerals;
                break;
            case 9 :
                asRomanNumerals = RN [i] + RN [i + 2] + asRomanNumerals;
                break;
        }
        number = (int) number / 10;
        i += 2;
    }
    System.out.println (asRomanNumerals);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12967896_24982006_78_122
12967896_30406772_9_16
Title: Converting Integers to Roman Numerals - Java 
----------------------------------------

public static void main (String [] args) {
    for (int number = 1;
    number <= 3999; number ++) {
        String roman = of (number);
        int parsed = parse (roman);
        if (parsed != number) {
            System.err.format ("ERROR: number: %d, roman: %s, parsed: %d\n", number, roman, parsed);
        }
    }
    int [] illegalNumbers = {- 1, 0, 4000, 4001};
    for (int illegalNumber : illegalNumbers) {
        try {
            of (illegalNumber);
            System.err.format ("ERROR: Expected failure on number %d\n", illegalNumber);
        } catch (IllegalArgumentException e) {
        }
    }
    String [] illegalRomans = {"MMMM", "CDCD", "IM", "T", "", "VV", "DM"};
    for (String illegalRoman : illegalRomans) {
        try {
            parse (illegalRoman);
            System.err.format ("ERROR: Expected failure on roman %s\n", illegalRoman);
        } catch (NumberFormatException e) {
        }
    }
}
----------------------------------------

public static void main (String args []) {
    Scanner in = new Scanner (System.in);
    System.out.print ("give us an integer < 4000: ");
    System.out.println ("the roman numeral version is: " + toRoman (in.nextInt ()));
    for (int i = 1;
    i <= 3999; i ++) {
        System.out.println (i + " === " + toRoman (i));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12967896_24982006_78_122
12967896_31289946_6_59
Title: Converting Integers to Roman Numerals - Java 
----------------------------------------

public static void main (String [] args) {
    for (int number = 1;
    number <= 3999; number ++) {
        String roman = of (number);
        int parsed = parse (roman);
        if (parsed != number) {
            System.err.format ("ERROR: number: %d, roman: %s, parsed: %d\n", number, roman, parsed);
        }
    }
    int [] illegalNumbers = {- 1, 0, 4000, 4001};
    for (int illegalNumber : illegalNumbers) {
        try {
            of (illegalNumber);
            System.err.format ("ERROR: Expected failure on number %d\n", illegalNumber);
        } catch (IllegalArgumentException e) {
        }
    }
    String [] illegalRomans = {"MMMM", "CDCD", "IM", "T", "", "VV", "DM"};
    for (String illegalRoman : illegalRomans) {
        try {
            parse (illegalRoman);
            System.err.format ("ERROR: Expected failure on roman %s\n", illegalRoman);
        } catch (NumberFormatException e) {
        }
    }
}
----------------------------------------

public static void main (String args []) {
    File file = new File ("lettered.in");
    try {
        Scanner input = new Scanner (file);
        int dataCollect = input.nextInt ();
        int sum = 0;
        String lineInput = "";
        for (int i = 0;
        i <= dataCollect; i ++) {
            while (input.hasNext ()) {
                lineInput = input.next ();
                char lineArray [] = lineInput.toCharArray ();
                for (int j = 0;
                j < lineArray.length; j ++) {
                    if (lineArray [j] == 'A') {
                        sum += 1;
                    } else if (lineArray [j] == 'B') {
                        sum += 10;
                    } else if (lineArray [j] == 'C') {
                        sum += 100;
                    } else if (lineArray [j] == 'D') {
                        sum += 1000;
                    } else if (lineArray [j] == 'E') {
                        sum += 10000;
                    } else if (lineArray [j] == 'F') {
                        sum += 100000;
                    } else if (lineArray [j] == 'G') {
                        sum += 1000000;
                    } else if (lineArray [j] == 'X') {
                        System.out.println (sum);
                        sum = 0;
                    }

                }
            }
        }
    } catch (FileNotFoundException e) {
        System.out.println ("ERROR");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12967896_28972634_1_27
12967896_30406772_9_16
Title: Converting Integers to Roman Numerals - Java 
----------------------------------------

public static void main (String [] args) {
    int number = 2345;
    number = Math.min (3999, Math.max (1, number));
    String asRomanNumerals = "";
    String [] RN = {"I", "V", "X", "L", "C", "D", "M"};
    int i = 0;
    while (number > 0) {
        switch (number % 10) {
            case 1 :
                asRomanNumerals = RN [i] + asRomanNumerals;
                break;
            case 2 :
                asRomanNumerals = RN [i] + RN [i] + asRomanNumerals;
                break;
            case 3 :
                asRomanNumerals = RN [i] + RN [i] + RN [i] + asRomanNumerals;
                break;
            case 4 :
                asRomanNumerals = RN [i] + RN [i + 1] + asRomanNumerals;
                break;
            case 5 :
                asRomanNumerals = RN [i + 1] + asRomanNumerals;
                break;
            case 6 :
                asRomanNumerals = RN [i + 1] + RN [i] + asRomanNumerals;
                break;
            case 7 :
                asRomanNumerals = RN [i + 1] + RN [i] + RN [i] + asRomanNumerals;
                break;
            case 8 :
                asRomanNumerals = RN [i + 1] + RN [i] + RN [i] + RN [i] + asRomanNumerals;
                break;
            case 9 :
                asRomanNumerals = RN [i] + RN [i + 2] + asRomanNumerals;
                break;
        }
        number = (int) number / 10;
        i += 2;
    }
    System.out.println (asRomanNumerals);
}
----------------------------------------

public static void main (String args []) {
    Scanner in = new Scanner (System.in);
    System.out.print ("give us an integer < 4000: ");
    System.out.println ("the roman numeral version is: " + toRoman (in.nextInt ()));
    for (int i = 1;
    i <= 3999; i ++) {
        System.out.println (i + " === " + toRoman (i));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12967896_28972634_1_27
12967896_31289946_6_59
Title: Converting Integers to Roman Numerals - Java 
----------------------------------------

public static void main (String [] args) {
    int number = 2345;
    number = Math.min (3999, Math.max (1, number));
    String asRomanNumerals = "";
    String [] RN = {"I", "V", "X", "L", "C", "D", "M"};
    int i = 0;
    while (number > 0) {
        switch (number % 10) {
            case 1 :
                asRomanNumerals = RN [i] + asRomanNumerals;
                break;
            case 2 :
                asRomanNumerals = RN [i] + RN [i] + asRomanNumerals;
                break;
            case 3 :
                asRomanNumerals = RN [i] + RN [i] + RN [i] + asRomanNumerals;
                break;
            case 4 :
                asRomanNumerals = RN [i] + RN [i + 1] + asRomanNumerals;
                break;
            case 5 :
                asRomanNumerals = RN [i + 1] + asRomanNumerals;
                break;
            case 6 :
                asRomanNumerals = RN [i + 1] + RN [i] + asRomanNumerals;
                break;
            case 7 :
                asRomanNumerals = RN [i + 1] + RN [i] + RN [i] + asRomanNumerals;
                break;
            case 8 :
                asRomanNumerals = RN [i + 1] + RN [i] + RN [i] + RN [i] + asRomanNumerals;
                break;
            case 9 :
                asRomanNumerals = RN [i] + RN [i + 2] + asRomanNumerals;
                break;
        }
        number = (int) number / 10;
        i += 2;
    }
    System.out.println (asRomanNumerals);
}
----------------------------------------

public static void main (String args []) {
    File file = new File ("lettered.in");
    try {
        Scanner input = new Scanner (file);
        int dataCollect = input.nextInt ();
        int sum = 0;
        String lineInput = "";
        for (int i = 0;
        i <= dataCollect; i ++) {
            while (input.hasNext ()) {
                lineInput = input.next ();
                char lineArray [] = lineInput.toCharArray ();
                for (int j = 0;
                j < lineArray.length; j ++) {
                    if (lineArray [j] == 'A') {
                        sum += 1;
                    } else if (lineArray [j] == 'B') {
                        sum += 10;
                    } else if (lineArray [j] == 'C') {
                        sum += 100;
                    } else if (lineArray [j] == 'D') {
                        sum += 1000;
                    } else if (lineArray [j] == 'E') {
                        sum += 10000;
                    } else if (lineArray [j] == 'F') {
                        sum += 100000;
                    } else if (lineArray [j] == 'G') {
                        sum += 1000000;
                    } else if (lineArray [j] == 'X') {
                        System.out.println (sum);
                        sum = 0;
                    }

                }
            }
        }
    } catch (FileNotFoundException e) {
        System.out.println ("ERROR");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12967896_30406772_9_16
12967896_31289946_6_59
Title: Converting Integers to Roman Numerals - Java 
----------------------------------------

public static void main (String args []) {
    Scanner in = new Scanner (System.in);
    System.out.print ("give us an integer < 4000: ");
    System.out.println ("the roman numeral version is: " + toRoman (in.nextInt ()));
    for (int i = 1;
    i <= 3999; i ++) {
        System.out.println (i + " === " + toRoman (i));
    }
}
----------------------------------------

public static void main (String args []) {
    File file = new File ("lettered.in");
    try {
        Scanner input = new Scanner (file);
        int dataCollect = input.nextInt ();
        int sum = 0;
        String lineInput = "";
        for (int i = 0;
        i <= dataCollect; i ++) {
            while (input.hasNext ()) {
                lineInput = input.next ();
                char lineArray [] = lineInput.toCharArray ();
                for (int j = 0;
                j < lineArray.length; j ++) {
                    if (lineArray [j] == 'A') {
                        sum += 1;
                    } else if (lineArray [j] == 'B') {
                        sum += 10;
                    } else if (lineArray [j] == 'C') {
                        sum += 100;
                    } else if (lineArray [j] == 'D') {
                        sum += 1000;
                    } else if (lineArray [j] == 'E') {
                        sum += 10000;
                    } else if (lineArray [j] == 'F') {
                        sum += 100000;
                    } else if (lineArray [j] == 'G') {
                        sum += 1000000;
                    } else if (lineArray [j] == 'X') {
                        System.out.println (sum);
                        sum = 0;
                    }

                }
            }
        }
    } catch (FileNotFoundException e) {
        System.out.println ("ERROR");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12967896_34474649_1_14
12967896_42053578_1_54
Title: Converting Integers to Roman Numerals - Java 
----------------------------------------

private static String convertToRoman (int mInt) {
    String [] rnChars = {"M", "CM", "D", "C", "XC", "L", "X", "IX", "V", "I"};
    int [] rnVals = {1000, 900, 500, 100, 90, 50, 10, 9, 5, 1};
    String retVal = "";
    for (int i = 0;
    i < rnVals.length; i ++) {
        int numberInPlace = mInt / rnVals [i];
        if (numberInPlace == 0) continue;

        retVal += numberInPlace == 4 && i > 0 ? rnChars [i] + rnChars [i - 1] : new String (new char [numberInPlace]).replace ("\0", rnChars [i]);
        mInt = mInt % rnVals [i];
    }
    return retVal;
}
----------------------------------------

private String convertToRoman (int num) {
    String result = "";
    while (num > 0) {
        if (num >= 1000) {
            result += "M";
            num -= 1000;
        } else if (num >= 900) {
            result += "CM";
            num -= 900;
        } else if (num >= 500) {
            result += "D";
            num -= 500;
        } else if (num >= 400) {
            result += "CD";
            num -= 400;
        } else if (num >= 100) {
            result += "C";
            num -= 100;
        } else if (num >= 90) {
            result += "XC";
            num -= 90;
        } else if (num >= 50) {
            result += "L";
            num -= 50;
        } else if (num >= 40) {
            result += "XL";
            num -= 40;
        } else if (num >= 10) {
            result += "X";
            num -= 10;
        } else if (num >= 9) {
            result += "IX";
            num -= 9;
        } else if (num >= 5) {
            result += "V";
            num -= 5;
        } else if (num >= 4) {
            result += "IV";
            num -= 4;
        } else if (num >= 1) {
            result += "I";
            num -= 1;
        } else {
            break;
        }

    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12967896_47810627_4_76
12967896_51509330_1_19
Title: Converting Integers to Roman Numerals - Java 
----------------------------------------

public static String toRoman (int number) {
    StringBuilder br = new StringBuilder ("");
    while (number != 0) {
        while (number >= 1000) {
            br.append ("M");
            number -= 1000;
        }
        while (number >= 900) {
            br.append ("CM");
            number -= 900;
        }
        while (number >= 500) {
            br.append ("D");
            number -= 500;
        }
        while (number >= 400) {
            br.append ("CD");
            number -= 400;
        }
        while (number >= 100) {
            br.append ("C");
            number -= 100;
        }
        while (number >= 90) {
            br.append ("XC");
            number -= 90;
        }
        while (number >= 50) {
            br.append ("L");
            number -= 50;
        }
        while (number >= 40) {
            br.append ("XL");
            number -= 40;
        }
        while (number >= 10) {
            br.append ("X");
            number -= 10;
        }
        while (number >= 9) {
            br.append ("IX");
            number -= 9;
        }
        while (number >= 5) {
            br.append ("V");
            number -= 5;
        }
        while (number >= 4) {
            br.append ("IV");
            number -= 4;
        }
        while (number >= 1) {
            br.append ("I");
            number -= 1;
        }
    }
    return br.toString ();
}
----------------------------------------

private static String toRoman (int n) {
    String [] romanNumerals = {"M", "CM", "D", "CD", "C", "XC", "L", "X", "IX", "V", "I"};
    int [] romanNumeralNums = {1000, 900, 500, 400, 100, 90, 50, 10, 9, 5, 1};
    String finalRomanNum = "";
    for (int i = 0;
    i < romanNumeralNums.length; i ++) {
        int currentNum = n / romanNumeralNums [i];
        if (currentNum == 0) {
            continue;
        }
        for (int j = 0;
        j < currentNum; j ++) {
            finalRomanNum += romanNumerals [i];
        }
        n = n % romanNumeralNums [i];
    }
    return finalRomanNum;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12982021_12982566_14_49
12982021_13010227_83_110
Title: BlackBerry class equivalent to AsyncTask? 
----------------------------------------

public void execute () {
    try {
        runnable = new Runnable () {
            public void run () {
                UiApplication.getUiApplication ().invokeLater (new Runnable () {
                    public void run () {
                        onPreExecute ();
                    }}

                );
                doInBackground ();
                UiApplication.getUiApplication ().invokeLater (new Runnable () {
                    public void run () {
                        onPostExecute ();
                    }}

                );
            }}

        ;
        threadToRun = new Thread (runnable);
        threadToRun.start ();
    } catch (Exception e) {
        Dialog.alert ("Async Error Occured. " + e.toString ());
    }
}
----------------------------------------

public AsyncTask execute (final Object [] params) throws IllegalStateException {
    if (getStatus () != PENDING) {
        throw new IllegalStateException ("An AsyncTask can only be executed once!");
    } else {
        try {
            onPreExecute ();
            _worker = new Thread (new Runnable () {
                public void run () {
                    try {
                        final Object result = doInBackground (params);
                        completeTask (result);
                    } catch (Exception e) {
                        completeTask (null);
                    }
                }}

            );
            _status = RUNNING;
            _worker.start ();
        } catch (Exception e) {
        }
    }
    return this;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12984922_12984937_1_15
12984922_12985058_57_65
Title: Giving extending classes a specific behaviour? 
----------------------------------------

public void addFruit (Fruit fruit) {
    try {
        Class < Fruit > clazz = fruit.getClass ();
        String clazzName = clazz.getName ();
        String listName = clazzName.toLowercase () + "s";
        Class < FruitStore > fsClazz = store.getClass ();
        Field listField = fsClazz.getDeclaredField (listName);
        listField.setAccessible (true);
        List < Fruit > list = (List < Fruit >) listField.get (store);
        list.add (fruit);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public void addFruit (Fruit fruit) {
    Class < ? extends Fruit > fruitClass = fruit.getClass ();
    List < Fruit > fruitList = fruitMap.get (fruitClass);
    if (fruitList == null) {
        fruitList = new ArrayList < Fruit > ();
    }
    fruitList.add (fruit);
    fruitMap.put (fruitClass, fruitList);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12987892_12988026_21_36
12987892_18007229_5_31
Title: Better minimum and maximum algorithm using an array in Java 
----------------------------------------

public static void main (String [] args) {
    int [] ar = new int [10];
    for (int i = 0;
    i < 10; i ++) {
        ar [i] = new Random ().nextInt (50);
        System.out.println (ar [i]);
    }
    int maxValue = max (ar);
    int minValue = min (ar);
    System.out.println ("The max is " + maxValue);
    System.out.println ("The min is " + minValue);
}
----------------------------------------

public static void main (String [] args) throws IOException {
    BufferedReader c = new BufferedReader (new InputStreamReader (System.in));
    System.out.print ("Enter Number Column : ");
    int column = Integer.parseInt (c.readLine ());
    System.out.print ("Enter Number Row : ");
    int row = Integer.parseInt (c.readLine ());
    int array [] [] = new int [column] [row];
    int max = array [0] [0];
    int min = array [0] [0];
    int sum = 0;
    for (int i = 0;
    i < array.length; i ++) {
        for (int j = 0;
        j < array [i].length; j ++) {
            System.out.print ("Enter Array Values [" + i + "][" + j + "]: ");
            array [i] [j] = Integer.parseInt (c.readLine ());
            min = Math.min (min, array [i] [j]);
            max = Math.max (max, array [i] [j]);
            sum += array [i] [j];
        }
    }
    System.out.println ("The Min Number :" + min);
    System.out.println ("The Max Number :" + max + " total is " + sum);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12989397_23097860_14_32
12989397_36910354_48_69
Title: running 3 threads in sequence java 
----------------------------------------

public void run () {
    synchronized (myLock) {
        while (myThreadID != threadAllowedToRun) {
            try {
                myLock.wait ();
            } catch (InterruptedException e) {
            } catch (Exception e) {
            }
        }
        try {
            Thread.sleep (2000);
        } catch (InterruptedException e) {
        }
        System.out.println ("myThreadID is running: " + myThreadID);
        myLock.notifyAll ();
        threadAllowedToRun ++;
    }
}
----------------------------------------

public void run () {
    synchronized (this) {
        for (int value : data) {
            try {
                while (dependentAction.isDependent ()) wait (100);

            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
            dependentAction.setDependent (true);
            System.out.println (Thread.currentThread ().getName () + " :: " + value);
            dependent = false;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12989397_23097860_14_32
12989397_38784417_27_42
Title: running 3 threads in sequence java 
----------------------------------------

public void run () {
    synchronized (myLock) {
        while (myThreadID != threadAllowedToRun) {
            try {
                myLock.wait ();
            } catch (InterruptedException e) {
            } catch (Exception e) {
            }
        }
        try {
            Thread.sleep (2000);
        } catch (InterruptedException e) {
        }
        System.out.println ("myThreadID is running: " + myThreadID);
        myLock.notifyAll ();
        threadAllowedToRun ++;
    }
}
----------------------------------------

public void run () {
    synchronized (s) {
        for (int i = 0;
        i < 10; i ++) {
            while (s.valve != 1) {
                try {
                    s.wait ();
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
            System.out.println ("A");
            s.valve = 2;
            s.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12989397_23097860_14_32
12989397_38784417_52_67
Title: running 3 threads in sequence java 
----------------------------------------

public void run () {
    synchronized (myLock) {
        while (myThreadID != threadAllowedToRun) {
            try {
                myLock.wait ();
            } catch (InterruptedException e) {
            } catch (Exception e) {
            }
        }
        try {
            Thread.sleep (2000);
        } catch (InterruptedException e) {
        }
        System.out.println ("myThreadID is running: " + myThreadID);
        myLock.notifyAll ();
        threadAllowedToRun ++;
    }
}
----------------------------------------

public void run () {
    synchronized (s) {
        for (int i = 0;
        i < 10; i ++) {
            while (s.valve != 2) {
                try {
                    s.wait ();
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
            System.out.println ("B");
            s.valve = 3;
            s.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12989397_23097860_14_32
12989397_38784417_77_92
Title: running 3 threads in sequence java 
----------------------------------------

public void run () {
    synchronized (myLock) {
        while (myThreadID != threadAllowedToRun) {
            try {
                myLock.wait ();
            } catch (InterruptedException e) {
            } catch (Exception e) {
            }
        }
        try {
            Thread.sleep (2000);
        } catch (InterruptedException e) {
        }
        System.out.println ("myThreadID is running: " + myThreadID);
        myLock.notifyAll ();
        threadAllowedToRun ++;
    }
}
----------------------------------------

public void run () {
    synchronized (s) {
        for (int i = 0;
        i < 10; i ++) {
            while (s.valve != 3) {
                try {
                    s.wait ();
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
            System.out.println ("C");
            s.valve = 1;
            s.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12989397_23097860_14_32
12989397_42516190_32_49
Title: running 3 threads in sequence java 
----------------------------------------

public void run () {
    synchronized (myLock) {
        while (myThreadID != threadAllowedToRun) {
            try {
                myLock.wait ();
            } catch (InterruptedException e) {
            } catch (Exception e) {
            }
        }
        try {
            Thread.sleep (2000);
        } catch (InterruptedException e) {
        }
        System.out.println ("myThreadID is running: " + myThreadID);
        myLock.notifyAll ();
        threadAllowedToRun ++;
    }
}
----------------------------------------

public void run () {
    while (true) {
        synchronized (lock) {
            while (ch != AlternateCharPrinter.ch) {
                try {
                    lock.wait ();
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
            System.out.println (AlternateCharPrinter.ch ++);
            if (AlternateCharPrinter.ch == (65 + runnerCount)) {
                AlternateCharPrinter.ch = 65;
            }
            lock.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12989397_23097860_34_53
12989397_36910354_4_22
Title: running 3 threads in sequence java 
----------------------------------------

public static void main (String [] args) {
    Thread t1 = new Thread (new RunThreadsInOrder ());
    Thread t2 = new Thread (new RunThreadsInOrder ());
    Thread t3 = new Thread (new RunThreadsInOrder ());
    Thread t4 = new Thread (new RunThreadsInOrder ());
    Thread t5 = new Thread (new RunThreadsInOrder ());
    Thread t6 = new Thread (new RunThreadsInOrder ());
    Thread t7 = new Thread (new RunThreadsInOrder ());
    t7.start ();
    t6.start ();
    t5.start ();
    t4.start ();
    t3.start ();
    t2.start ();
    t1.start ();
}
----------------------------------------

public static void main (String [] args) {
    SyncPrinterAction printAction1 = new SyncPrinterAction (new int [] {1, 5, 9, 13}, true);
    SyncPrinterAction printAction2 = new SyncPrinterAction (new int [] {2, 6, 10, 14}, true);
    SyncPrinterAction printAction3 = new SyncPrinterAction (new int [] {3, 7, 11, 15}, true);
    SyncPrinterAction printAction4 = new SyncPrinterAction (new int [] {4, 8, 12, 16}, false);
    printAction1.setDependentAction (printAction4);
    printAction2.setDependentAction (printAction1);
    printAction3.setDependentAction (printAction2);
    printAction4.setDependentAction (printAction3);
    new Thread (printAction1, "T1").start ();
    new Thread (printAction2, "T2").start ();
    new Thread (printAction3, "T3").start ();
    new Thread (printAction4, "T4").start ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12989397_23097860_34_53
12989397_38784417_3_17
Title: running 3 threads in sequence java 
----------------------------------------

public static void main (String [] args) {
    Thread t1 = new Thread (new RunThreadsInOrder ());
    Thread t2 = new Thread (new RunThreadsInOrder ());
    Thread t3 = new Thread (new RunThreadsInOrder ());
    Thread t4 = new Thread (new RunThreadsInOrder ());
    Thread t5 = new Thread (new RunThreadsInOrder ());
    Thread t6 = new Thread (new RunThreadsInOrder ());
    Thread t7 = new Thread (new RunThreadsInOrder ());
    t7.start ();
    t6.start ();
    t5.start ();
    t4.start ();
    t3.start ();
    t2.start ();
    t1.start ();
}
----------------------------------------

public static void main (String [] args) {
    Sequence s = new Sequence ();
    ExecutorService es = Executors.newFixedThreadPool (3);
    List < Runnable > rList = new ArrayList < > ();
    rList.add (new A (s));
    rList.add (new B (s));
    rList.add (new C (s));
    for (int i = 0;
    i < rList.size (); i ++) {
        es.submit (rList.get (i));
    }
    es.shutdown ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12989397_36910354_48_69
12989397_38784417_27_42
Title: running 3 threads in sequence java 
----------------------------------------

public void run () {
    synchronized (this) {
        for (int value : data) {
            try {
                while (dependentAction.isDependent ()) wait (100);

            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
            dependentAction.setDependent (true);
            System.out.println (Thread.currentThread ().getName () + " :: " + value);
            dependent = false;
        }
    }
}
----------------------------------------

public void run () {
    synchronized (s) {
        for (int i = 0;
        i < 10; i ++) {
            while (s.valve != 1) {
                try {
                    s.wait ();
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
            System.out.println ("A");
            s.valve = 2;
            s.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12989397_36910354_48_69
12989397_38784417_52_67
Title: running 3 threads in sequence java 
----------------------------------------

public void run () {
    synchronized (this) {
        for (int value : data) {
            try {
                while (dependentAction.isDependent ()) wait (100);

            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
            dependentAction.setDependent (true);
            System.out.println (Thread.currentThread ().getName () + " :: " + value);
            dependent = false;
        }
    }
}
----------------------------------------

public void run () {
    synchronized (s) {
        for (int i = 0;
        i < 10; i ++) {
            while (s.valve != 2) {
                try {
                    s.wait ();
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
            System.out.println ("B");
            s.valve = 3;
            s.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12989397_36910354_48_69
12989397_38784417_77_92
Title: running 3 threads in sequence java 
----------------------------------------

public void run () {
    synchronized (this) {
        for (int value : data) {
            try {
                while (dependentAction.isDependent ()) wait (100);

            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
            dependentAction.setDependent (true);
            System.out.println (Thread.currentThread ().getName () + " :: " + value);
            dependent = false;
        }
    }
}
----------------------------------------

public void run () {
    synchronized (s) {
        for (int i = 0;
        i < 10; i ++) {
            while (s.valve != 3) {
                try {
                    s.wait ();
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
            System.out.println ("C");
            s.valve = 1;
            s.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12989397_36910354_48_69
12989397_42516190_32_49
Title: running 3 threads in sequence java 
----------------------------------------

public void run () {
    synchronized (this) {
        for (int value : data) {
            try {
                while (dependentAction.isDependent ()) wait (100);

            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
            dependentAction.setDependent (true);
            System.out.println (Thread.currentThread ().getName () + " :: " + value);
            dependent = false;
        }
    }
}
----------------------------------------

public void run () {
    while (true) {
        synchronized (lock) {
            while (ch != AlternateCharPrinter.ch) {
                try {
                    lock.wait ();
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
            System.out.println (AlternateCharPrinter.ch ++);
            if (AlternateCharPrinter.ch == (65 + runnerCount)) {
                AlternateCharPrinter.ch = 65;
            }
            lock.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12989397_36910354_4_22
12989397_38784417_3_17
Title: running 3 threads in sequence java 
----------------------------------------

public static void main (String [] args) {
    SyncPrinterAction printAction1 = new SyncPrinterAction (new int [] {1, 5, 9, 13}, true);
    SyncPrinterAction printAction2 = new SyncPrinterAction (new int [] {2, 6, 10, 14}, true);
    SyncPrinterAction printAction3 = new SyncPrinterAction (new int [] {3, 7, 11, 15}, true);
    SyncPrinterAction printAction4 = new SyncPrinterAction (new int [] {4, 8, 12, 16}, false);
    printAction1.setDependentAction (printAction4);
    printAction2.setDependentAction (printAction1);
    printAction3.setDependentAction (printAction2);
    printAction4.setDependentAction (printAction3);
    new Thread (printAction1, "T1").start ();
    new Thread (printAction2, "T2").start ();
    new Thread (printAction3, "T3").start ();
    new Thread (printAction4, "T4").start ();
}
----------------------------------------

public static void main (String [] args) {
    Sequence s = new Sequence ();
    ExecutorService es = Executors.newFixedThreadPool (3);
    List < Runnable > rList = new ArrayList < > ();
    rList.add (new A (s));
    rList.add (new B (s));
    rList.add (new C (s));
    for (int i = 0;
    i < rList.size (); i ++) {
        es.submit (rList.get (i));
    }
    es.shutdown ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12989397_38784417_27_42
12989397_42516190_32_49
Title: running 3 threads in sequence java 
----------------------------------------

public void run () {
    synchronized (s) {
        for (int i = 0;
        i < 10; i ++) {
            while (s.valve != 1) {
                try {
                    s.wait ();
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
            System.out.println ("A");
            s.valve = 2;
            s.notifyAll ();
        }
    }
}
----------------------------------------

public void run () {
    while (true) {
        synchronized (lock) {
            while (ch != AlternateCharPrinter.ch) {
                try {
                    lock.wait ();
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
            System.out.println (AlternateCharPrinter.ch ++);
            if (AlternateCharPrinter.ch == (65 + runnerCount)) {
                AlternateCharPrinter.ch = 65;
            }
            lock.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12989397_38784417_52_67
12989397_42516190_32_49
Title: running 3 threads in sequence java 
----------------------------------------

public void run () {
    synchronized (s) {
        for (int i = 0;
        i < 10; i ++) {
            while (s.valve != 2) {
                try {
                    s.wait ();
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
            System.out.println ("B");
            s.valve = 3;
            s.notifyAll ();
        }
    }
}
----------------------------------------

public void run () {
    while (true) {
        synchronized (lock) {
            while (ch != AlternateCharPrinter.ch) {
                try {
                    lock.wait ();
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
            System.out.println (AlternateCharPrinter.ch ++);
            if (AlternateCharPrinter.ch == (65 + runnerCount)) {
                AlternateCharPrinter.ch = 65;
            }
            lock.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12989397_38784417_77_92
12989397_42516190_32_49
Title: running 3 threads in sequence java 
----------------------------------------

public void run () {
    synchronized (s) {
        for (int i = 0;
        i < 10; i ++) {
            while (s.valve != 3) {
                try {
                    s.wait ();
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
            System.out.println ("C");
            s.valve = 1;
            s.notifyAll ();
        }
    }
}
----------------------------------------

public void run () {
    while (true) {
        synchronized (lock) {
            while (ch != AlternateCharPrinter.ch) {
                try {
                    lock.wait ();
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
            System.out.println (AlternateCharPrinter.ch ++);
            if (AlternateCharPrinter.ch == (65 + runnerCount)) {
                AlternateCharPrinter.ch = 65;
            }
            lock.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12995568_12995713_68_78
12995568_12995713_95_107
Title: How do I use wait/notifyAll 
----------------------------------------

public void run () {
    int value = 0;
    for (int i = 0;
    i < 100; i ++) {
        value = cubbyhole.get ();
        takeSum += value;
    }
    System.out.println ("Take Sum for Consumer: " + number + " is " + takeSum);
}
----------------------------------------

public void run () {
    for (int i = 0;
    i < 100; i ++) {
        int rnd = (int) (Math.random () * 10);
        cubbyhole.put (rnd);
        putSum += rnd;
        try {
            sleep ((int) (Math.random () * 100));
        } catch (InterruptedException e) {
        }
    }
    System.out.println ("Put Sum for Producer: " + number + " is " + putSum);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13000679_13000719_10_23
13000679_13000725_7_15
Title: Multithreading Deadlock in Java 
----------------------------------------

public void run () {
    try {
        synchronized (signal) {
            while (true) {
                while (current.equals (info)) signal.wait ();

                System.out.println (info);
                current = info;
                signal.notify ();
            }
        }
    } catch (Exception e) {
    }
}
----------------------------------------

public synchronized void run () {
    try {
        while (true) {
            System.out.println (info);
            wait ();
        }
    } catch (Exception e) {
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13003280_13004927_74_125
13003280_13004927_94_114
Title: Update JTextField from another thread in Java 
----------------------------------------

public void actionPerformed (ActionEvent ae) {
    if (sizeField.getDocument ().getLength () > 0) {
        size = Integer.parseInt (sizeField.getText ());
        vField = new JTextField [size];
        createPanel.setVisible (true);
        for (int i = 0;
        i < size; i ++) {
            vField [i] = new JTextField (5);
            if (i == (size - 1)) {
                vField [i].addActionListener (new ActionListener () {
                    @Override
                    public void actionPerformed (ActionEvent ae) {
                        animationPanel.setLayout (new GridLayout (1, size, 2, 2));
                        animationPanel.setVisible (true);
                        vLabel = new JLabel [size];
                        for (int i = 0;
                        i < size; i ++) {
                            vLabel [i] = new JLabel (vField [i].getText (), JLabel.CENTER);
                            vLabel [i].setOpaque (true);
                            vLabel [i].setBackground (Color.YELLOW);
                            vLabel [i].setForeground (Color.RED);
                            animationPanel.add (vLabel [i]);
                        }
                        animationPanel.revalidate ();
                        animationPanel.repaint ();
                        bubbleSort = new BubbleSort (vLabel, size);
                        Thread t = new Thread (bubbleSort);
                        t.start ();
                    }}

                );
            }
            createPanel.add (vField [i]);
        }
        createPanel.revalidate ();
        createPanel.repaint ();
        createButton.setEnabled (false);
    } else size = 5;

}
----------------------------------------

public void actionPerformed (ActionEvent ae) {
    animationPanel.setLayout (new GridLayout (1, size, 2, 2));
    animationPanel.setVisible (true);
    vLabel = new JLabel [size];
    for (int i = 0;
    i < size; i ++) {
        vLabel [i] = new JLabel (vField [i].getText (), JLabel.CENTER);
        vLabel [i].setOpaque (true);
        vLabel [i].setBackground (Color.YELLOW);
        vLabel [i].setForeground (Color.RED);
        animationPanel.add (vLabel [i]);
    }
    animationPanel.revalidate ();
    animationPanel.repaint ();
    bubbleSort = new BubbleSort (vLabel, size);
    Thread t = new Thread (bubbleSort);
    t.start ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13003323_13003602_69_77
13003323_18202579_1_13
Title: JavaFX how to change stage 
----------------------------------------

public void start (Stage primaryStage) {
    try {
        stage = primaryStage;
        gotoLogin ();
        primaryStage.show ();
    } catch (Exception ex) {
        Logger.getLogger (App.class.getName ()).log (Level.SEVERE, null, ex);
    }
}
----------------------------------------

@Override
public void start (Stage stage) throws Exception {
    URL location = getClass ().getResource ("Main.fxml");
    FXMLLoader fxmlLoader = new FXMLLoader ();
    fxmlLoader.setLocation (location);
    fxmlLoader.setBuilderFactory (new JavaFXBuilderFactory ());
    Parent root = (Parent) fxmlLoader.load (location.openStream ());
    Scene scene = new Scene (root);
    stage.setScene (scene);
    MainController mainController = fxmlLoader.getController ();
    mainController.setStage (stage);
    mainController.showStage ();
}
----------------------------------------
