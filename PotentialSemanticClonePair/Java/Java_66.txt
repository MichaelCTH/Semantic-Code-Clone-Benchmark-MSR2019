$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29638733_29638980_6_20
29638733_29639168_15_30
Title: Java: Draw a circular spiral using drawArc 
----------------------------------------

public void paintComponent (Graphics g) {
    int centerX = getWidth () / 2;
    int centerY = getHeight () / 2;
    int numIterations = 5;
    int arcWidth = 10;
    int arcGrowDelta = 30;
    for (int i = 0;
    i < numIterations; i ++) {
        g.drawArc (centerX - arcWidth, centerY - arcWidth, 2 * arcWidth, 2 * arcWidth, 0, 180);
        arcWidth += arcGrowDelta;
        g.drawArc (centerX - arcWidth, centerY - arcWidth, 2 * arcWidth - arcGrowDelta, 2 * arcWidth, 180, 180);
    }
}
----------------------------------------

public void paintComponent (Graphics g) {
    int x = PREF_W / 2;
    int y = PREF_H / 2;
    int width = 1;
    int height = 1;
    int startAngle = 0;
    int arcAngle = ARC_ANGLE;
    for (int i = 0;
    i < LOOP_MAX; i ++) {
        g.drawArc (x, y, width, height, startAngle, arcAngle);
        x = x - DELTA;
        y = y - DELTA;
        width += 2 * DELTA;
        height += 2 * DELTA;
        startAngle = startAngle - arcAngle;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29638733_29638980_6_20
29638733_29639475_7_32
Title: Java: Draw a circular spiral using drawArc 
----------------------------------------

public void paintComponent (Graphics g) {
    int centerX = getWidth () / 2;
    int centerY = getHeight () / 2;
    int numIterations = 5;
    int arcWidth = 10;
    int arcGrowDelta = 30;
    for (int i = 0;
    i < numIterations; i ++) {
        g.drawArc (centerX - arcWidth, centerY - arcWidth, 2 * arcWidth, 2 * arcWidth, 0, 180);
        arcWidth += arcGrowDelta;
        g.drawArc (centerX - arcWidth, centerY - arcWidth, 2 * arcWidth - arcGrowDelta, 2 * arcWidth, 180, 180);
    }
}
----------------------------------------

public void paintComponent (Graphics g) {
    int x = getSize ().width / 2 - 10;
    int y = getSize ().height / 2 - 10;
    int width = 20;
    int height = 20;
    int startAngle = 0;
    int arcAngle = 180;
    int depth = 10;
    for (int i = 0;
    i < 10; i ++) {
        if (i % 2 == 0) {
            y = y - depth;
            width = width + 2 * depth;
            height = height + 2 * depth;
            g.drawArc (x, y, width, height, startAngle, - arcAngle);
        } else {
            x = x - 2 * depth;
            y = y - depth;
            width = width + 2 * depth;
            height = height + 2 * depth;
            g.drawArc (x, y, width, height, startAngle, arcAngle);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29638733_29638980_6_20
29638733_40943119_14_49
Title: Java: Draw a circular spiral using drawArc 
----------------------------------------

public void paintComponent (Graphics g) {
    int centerX = getWidth () / 2;
    int centerY = getHeight () / 2;
    int numIterations = 5;
    int arcWidth = 10;
    int arcGrowDelta = 30;
    for (int i = 0;
    i < numIterations; i ++) {
        g.drawArc (centerX - arcWidth, centerY - arcWidth, 2 * arcWidth, 2 * arcWidth, 0, 180);
        arcWidth += arcGrowDelta;
        g.drawArc (centerX - arcWidth, centerY - arcWidth, 2 * arcWidth - arcGrowDelta, 2 * arcWidth, 180, 180);
    }
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2d = (Graphics2D) g;
    g2d.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    g2d.setRenderingHint (RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
    int width = 10;
    int height = 10;
    int startAngle = 0;
    int arcAngle = 180;
    int x = (getWidth () - width) / 2;
    int y = (getHeight () - height) / 2;
    int i = 0;
    int t = 0;
    while (i < 36) {
        g2d.drawArc (x + t, y, width, height, startAngle, arcAngle);
        if (i % 2 == 0) {
            t -= 10;
        }
        y -= 5;
        width += 10;
        height += 10;
        startAngle += 180;
        i ++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29638733_29639168_15_30
29638733_29639475_7_32
Title: Java: Draw a circular spiral using drawArc 
----------------------------------------

public void paintComponent (Graphics g) {
    int x = PREF_W / 2;
    int y = PREF_H / 2;
    int width = 1;
    int height = 1;
    int startAngle = 0;
    int arcAngle = ARC_ANGLE;
    for (int i = 0;
    i < LOOP_MAX; i ++) {
        g.drawArc (x, y, width, height, startAngle, arcAngle);
        x = x - DELTA;
        y = y - DELTA;
        width += 2 * DELTA;
        height += 2 * DELTA;
        startAngle = startAngle - arcAngle;
    }
}
----------------------------------------

public void paintComponent (Graphics g) {
    int x = getSize ().width / 2 - 10;
    int y = getSize ().height / 2 - 10;
    int width = 20;
    int height = 20;
    int startAngle = 0;
    int arcAngle = 180;
    int depth = 10;
    for (int i = 0;
    i < 10; i ++) {
        if (i % 2 == 0) {
            y = y - depth;
            width = width + 2 * depth;
            height = height + 2 * depth;
            g.drawArc (x, y, width, height, startAngle, - arcAngle);
        } else {
            x = x - 2 * depth;
            y = y - depth;
            width = width + 2 * depth;
            height = height + 2 * depth;
            g.drawArc (x, y, width, height, startAngle, arcAngle);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29638733_29639168_15_30
29638733_40943119_14_49
Title: Java: Draw a circular spiral using drawArc 
----------------------------------------

public void paintComponent (Graphics g) {
    int x = PREF_W / 2;
    int y = PREF_H / 2;
    int width = 1;
    int height = 1;
    int startAngle = 0;
    int arcAngle = ARC_ANGLE;
    for (int i = 0;
    i < LOOP_MAX; i ++) {
        g.drawArc (x, y, width, height, startAngle, arcAngle);
        x = x - DELTA;
        y = y - DELTA;
        width += 2 * DELTA;
        height += 2 * DELTA;
        startAngle = startAngle - arcAngle;
    }
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2d = (Graphics2D) g;
    g2d.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    g2d.setRenderingHint (RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
    int width = 10;
    int height = 10;
    int startAngle = 0;
    int arcAngle = 180;
    int x = (getWidth () - width) / 2;
    int y = (getHeight () - height) / 2;
    int i = 0;
    int t = 0;
    while (i < 36) {
        g2d.drawArc (x + t, y, width, height, startAngle, arcAngle);
        if (i % 2 == 0) {
            t -= 10;
        }
        y -= 5;
        width += 10;
        height += 10;
        startAngle += 180;
        i ++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29638733_29639475_7_32
29638733_40943119_14_49
Title: Java: Draw a circular spiral using drawArc 
----------------------------------------

public void paintComponent (Graphics g) {
    int x = getSize ().width / 2 - 10;
    int y = getSize ().height / 2 - 10;
    int width = 20;
    int height = 20;
    int startAngle = 0;
    int arcAngle = 180;
    int depth = 10;
    for (int i = 0;
    i < 10; i ++) {
        if (i % 2 == 0) {
            y = y - depth;
            width = width + 2 * depth;
            height = height + 2 * depth;
            g.drawArc (x, y, width, height, startAngle, - arcAngle);
        } else {
            x = x - 2 * depth;
            y = y - depth;
            width = width + 2 * depth;
            height = height + 2 * depth;
            g.drawArc (x, y, width, height, startAngle, arcAngle);
        }
    }
}
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2d = (Graphics2D) g;
    g2d.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    g2d.setRenderingHint (RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
    int width = 10;
    int height = 10;
    int startAngle = 0;
    int arcAngle = 180;
    int x = (getWidth () - width) / 2;
    int y = (getHeight () - height) / 2;
    int i = 0;
    int t = 0;
    while (i < 36) {
        g2d.drawArc (x + t, y, width, height, startAngle, arcAngle);
        if (i % 2 == 0) {
            t -= 10;
        }
        y -= 5;
        width += 10;
        height += 10;
        startAngle += 180;
        i ++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29639529_29639592_7_56
29639529_29639595_5_25
Title: implementing a try/catch block 
----------------------------------------

public static void main (String [] args) {
    int secretNumber, guess;
    secretNumber = (int) (Math.random () * 10 + 1);
    Scanner keyboard = new Scanner (System.in);
    System.out.println ("Welcome to my guess a number program!");
    System.out.println ("Please enter in a number to begin guess what the secret number is(1-10): ");
    do {
        System.out.println ("Enter a guess (1-10): ");
        try {
            guess = keyboard.nextInt ();
            if (guess < 1 || guess > 10) {
                throw new Exception ("Number must be  between 1 and 10");
            } else if (guess == secretNumber) {
                throw new Exception ("YOU WIN");
            } else if (guess < secretNumber) {
                throw new Exception ("NUMBER IS +");
            } else if (guess > secretNumber) {
                throw new Exception ("NUMBER IS -");
            }

        } catch (InputMismatchException e) {
            System.println ("mustbeanumber");
        } catch (Exception e) {
            System.out.println (e.getMessage ());
        }
    } while (guess != secretNumber);
    System.out.println ();
    System.out.println ("Hope you enjoyed using this program!");
}
----------------------------------------

public static void main (String [] args) {
    do {
        try {
            guess = keyboard.nextInt ();
            if (guess < 1 || guess > 10) {
                System.out.println ("Your guess is not in the corre try again.");
            }
            if (guess == secretNumber) {
                System.out.println ("Your guess is correct. Congratulations!");
            } else if (guess < secretNumber) {
                System.out.println ("Your guess is smaller than the secret number.");
            } else if (guess > secretNumber) {
                System.out.println ("Your guess is greater than the secret number.");
            }

        } catch (InputMismatchException e) {
            System.out.println ("Not a valid integer");
        }
    } while (guess != secretNumber);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29646542_29646598_12_22
29646542_29646751_1_10
Title: Points of intersection in middle of text 
----------------------------------------

public < T > List < T > intersection (List < T > list1, List < T > list2) {
    List < T > list = new ArrayList < T > ();
    for (T t : list1) {
        if (list2.contains (t)) {
            list.add (t);
        }
    }
    return list;
}
----------------------------------------

public static < T > List < T > intersection (List < T > list1, List < T > list2) {
    List < T > list = new ArrayList < > ();
    Predicate < ? super T > con = (t) -> {
        Predicate < ? super T > p = (u) -> u.toString ().contains ((CharSequence) t);
        return list1.stream ().anyMatch (p);
    };
    list2.stream ().filter (con).forEach (list :: add);
    return list;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29648866_29649342_8_42
29648866_29669664_4_37
Title: Write a program with while loop code in it to calculate the amount of exam scores enter by a user 
----------------------------------------

public static void main (String [] args) {
    int A_grades = 0;
    int B_grades = 0;
    int C_grades = 0;
    int D_grades = 0;
    int F_grades = 0;
    int count = 0;
    try {
        BufferedReader br = new BufferedReader (new InputStreamReader (System.in));
        System.out.println ("Enter exam score as integer percentage in range 0 to 100 :");
        int score = Integer.parseInt (br.readLine ());
        while (score > 0) {
            count ++;
            if (score >= 90 && score <= 100) A_grades ++;
            else if (score >= 80 && score <= 89) B_grades ++;
            else if (score >= 70 && score <= 79) C_grades ++;
            else if (score >= 60 && score <= 69) D_grades ++;
            else if (score >= 0 && score <= 59) F_grades ++;

            System.out.println ("Enter exam score as integer percentage in range 0 to 100 :");
            score = Integer.parseInt (br.readLine ());
        }
    } catch (IOException ioe) {
    }
    System.out.println ("Total number of grades :" + count);
    System.out.println ("Total number of A grades :" + A_grades);
    System.out.println ("Total number of B grades :" + B_grades);
    System.out.println ("Total number of C grades :" + C_grades);
    System.out.println ("Total number of D grades :" + D_grades);
    System.out.println ("Total number of F grades :" + F_grades);
}
----------------------------------------

public static void main (String [] args) {
    int A_grades = 0;
    int B_grades = 0;
    int C_grades = 0;
    int D_grades = 0;
    int F_grades = 0;
    int count = 0;
    Scanner in = new Scanner (System.in);
    System.out.println ("Enter exam score as integer percentage in range 0 to 100");
    System.out.println ("And enter a negative score at the end of the list :");
    int score = in.nextInt ();
    while (score > 0) {
        count ++;
        if (score >= 90 && score <= 100) A_grades ++;
        else if (score >= 80 && score <= 89) B_grades ++;
        else if (score >= 70 && score <= 79) C_grades ++;
        else if (score >= 60 && score <= 69) D_grades ++;
        else if (score >= 0 && score <= 59) F_grades ++;

        score = in.nextInt ();
    }
    System.out.println ("Total number of grades :" + count);
    System.out.println ("Total number of A grades :" + A_grades);
    System.out.println ("Total number of B grades :" + B_grades);
    System.out.println ("Total number of C grades :" + C_grades);
    System.out.println ("Total number of D grades :" + D_grades);
    System.out.println ("Total number of F grades :" + F_grades);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29651468_29652755_11_33
29651468_29653027_7_25
Title: Searching a sorted list with two different algorithms to find if there exists an index i such that X[i]=i 
----------------------------------------

public static int binarySearch (int [] x) {
    if (x == null || x.length == 0) return - 1;

    int low = 0;
    if (x [low] == low) return 0;
    else if (x [low] > low) return - 1;

    int high = x.length - 1;
    if (x [high] == high) return high;
    else if (x [high] < high) return - 1;

    while (high - low >= 2) {
        int mid = (high + low) / 2;
        if (x [mid] == mid) return mid;
        else if (x [mid] > mid) high = mid;
        else low = mid;

    }
    return - 1;
}
----------------------------------------

public static boolean binarySearch (int [] list, int value) {
    int i = 0;
    int size = list.length - 1;
    while (i <= size) {
        int mid = (i + size) / 2;
        if (value == list [mid]) {
            return true;
        }
        if (value < list [mid]) {
            size = mid - 1;
        } else {
            i = mid + 1;
        }
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29652015_29652360_1_20
29652015_29652807_5_20
Title: How would I display a Airplane seating chart? 
----------------------------------------

public static void main (String [] args) {
    System.out.println ("Enter n:");
    Scanner scanner = new Scanner (System.in);
    int n = scanner.nextInt ();
    int [] [] airplane = new int [n] [4];
    for (int i = 1;
    i <= 4; i ++) {
        System.out.printf ("\t%d\t", i);
    }
    System.out.println ("");
    for (int j = 1;
    j <= n; j ++) {
        System.out.printf ("%d", j);
        for (int k = 1;
        k <= 4; k ++) {
            System.out.print ("\t-\t");
        }
        System.out.println ("");
    }
}
----------------------------------------

public static void main (String [] args) {
    System.out.println ("Enter n:");
    Scanner scanner = new Scanner (System.in);
    int n = scanner.nextInt ();
    int [] [] airplane = new int [n] [4];
    for (int i = 1;
    i <= 4; i ++) {
        System.out.printf ("%3d\t", i);
    }
    System.out.println ();
    for (int j = 1;
    j <= n; j ++) {
        System.out.println ((j) + " -" + "       -" + "       -" + "       -");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29654549_29654758_32_48
29654549_29654758_58_71
Title: How make Thread - notify()/notifyAll() private 
----------------------------------------

public void run () {
    Thread.currentThread ().setName ("X");
    try {
        Thread.sleep (1000 * 5);
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    synchronized (this.monitor) {
        this.monitor.notify ();
        System.out.println ("Notified from " + Thread.currentThread ().getName () + " Thread");
    }
}
----------------------------------------

public void run () {
    Thread.currentThread ().setName ("OtherThread");
    try {
        Thread.sleep (1000 * 1);
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    synchronized (t) {
        t.notify ();
        System.out.println ("Notified from " + Thread.currentThread ().getName () + " Thread");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29655689_29655809_1_15
29655689_29655941_10_22
Title: How to get individual letters in a string 
----------------------------------------

public int getNumVowels (String [] ray, char vowel) {
    int count = 0;
    for (String s : ray) {
        char [] array = s.toLowerCase ().toCharArray ();
        for (int i = 0;
        i < array.length; i ++) {
            if (array [i] == vowel) {
                count = count + 1;
            }
        }
    }
    return count;
}
----------------------------------------

public static int getNumVowels (String word) {
    int count = 0;
    for (int i = 0;
    i < word.length (); i ++) {
        if (vowels.contains (word.charAt (i) + "")) {
            count ++;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29656649_29656792_1_11
29656649_29657452_1_13
Title: Split a list into two sublists in all possible ways 
----------------------------------------

public static void main (String [] args) {
    int [] l = new int [] {1, 2, 3, 4};
    boolean [] flags = new boolean [l.length];
    for (int i = 0;
    i != l.length;) {
        ArrayList < Integer > a = new ArrayList < > (), b = new ArrayList < > ();
        for (int j = 0;
        j < l.length; j ++) if (flags [j]) a.add (l [j]);
        else b.add (l [j]);

        System.out.println ("" + a + ", " + b);
        for (i = 0; i < l.length && ! (flags [i] = ! flags [i]); i ++);

    }
}
----------------------------------------

public static void main (String [] args) {
    List < Integer > num = Arrays.asList (1, 2, 3, 4);
    List < List < Integer > > sublists = new ArrayList < List < Integer > > ();
    for (int i = 0;
    i <= num.size (); i ++) {
        permutation (num, sublists, i, new ArrayList < Integer > (), 0);
    }
    for (List < Integer > subList : sublists) {
        List < Integer > numCopy = new ArrayList < Integer > (num);
        numCopy.removeAll (subList);
        System.out.println ("(" + subList + ", " + numCopy + ")");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29661393_29661843_1_21
29661393_29667269_1_31
Title: My Apache Camel Processor is Not Working 
----------------------------------------

public static void main (String [] args) throws Exception {
    CamelContext context = new DefaultCamelContext ();
    RouteBuilder builder = new RouteBuilder () {
        public void configure () {
            from ("direct:source").process (new Processor () {
                @Override
                public void process (Exchange exchange) throws Exception {
                    System.out.println ("Success!");
                }}

            );
        }}

    ;
    context.addRoutes (builder);
    ProducerTemplate template = context.createProducerTemplate ();
    context.start ();
    template.sendBody ("direct:source", "test");
}
----------------------------------------

public static void main (String args []) throws Exception {
    CamelContext context = new DefaultCamelContext ();
    ConnectionFactory connectionFactory = new ActiveMQConnectionFactory ("tcp://localhost:61616");
    context.addComponent ("jms", JmsComponent.jmsComponentAutoAcknowledge (connectionFactory));
    context.addRoutes (new RouteBuilder () {
        @Override
        public void configure () {
            from ("jms:queue:QueueA").process (new Processor () {
                public void process (Exchange exchange) throws Exception {
                    String s = exchange.getIn ().getBody (String.class);
                    System.out.println ("The body of the message is: " + s);
                }}

            ).to ("jms:queue:QueueB");
        }}

    );
    context.start ();
    Thread.sleep (10000);
    context.stop ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29661393_29661843_6_13
29661393_29667269_14_22
Title: My Apache Camel Processor is Not Working 
----------------------------------------

public void configure () {
    from ("direct:source").process (new Processor () {
        @Override
        public void process (Exchange exchange) throws Exception {
            System.out.println ("Success!");
        }}

    );
}
----------------------------------------

public void configure () {
    from ("jms:queue:QueueA").process (new Processor () {
        public void process (Exchange exchange) throws Exception {
            String s = exchange.getIn ().getBody (String.class);
            System.out.println ("The body of the message is: " + s);
        }}

    ).to ("jms:queue:QueueB");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2966333_5279860_13_21
2966333_5279860_3_11
Title: Append data into a file using Apache Commons I/O 
----------------------------------------

public static void appendToFile (final String in, final File f) throws IOException {
    InputStream stream = null;
    try {
        stream = IOUtils.toInputStream (in);
        appendToFile (stream, f);
    } finally {
        IOUtils.closeQuietly (stream);
    }
}
----------------------------------------

public static void appendToFile (final InputStream in, final File f) throws IOException {
    OutputStream stream = null;
    try {
        stream = outStream (f);
        IOUtils.copy (in, stream);
    } finally {
        IOUtils.closeQuietly (stream);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2967474_2967800_5_25
2967474_2967956_4_19
Title: java - question about thread abortion and deadlock - volatile keyword 
----------------------------------------

public void run () {
    for (int i = 0;
    i < Integer.MAX_VALUE; ++ i) {
    }
    try {
        synchronized (someObject) {
            someObject.wait ();
        }
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    System.out.println ("WE COME HERE AFTER INTERRUPTED EXCEPTION");
    try {
        synchronized (someObject) {
            someObject.wait ();
        }
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    System.out.println ("HOWEVER, WE NEVER COME HERE, THE INTERRUPTED FLAG SEEMS TO BE RESETTED");
}
----------------------------------------

public void run () {
    main : while (shouldContinue) {
        synchronized (someObject) {
            while (someObject.someCondition () == false && shouldContinue) {
                try {
                    someObject.wait ();
                } catch (InterruptedException e) {
                    if (! shouldContinue) {
                        break main;
                    }
                }
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29676713_29676970_1_10
29676713_29677244_5_18
Title: Numbers too big for variables 
----------------------------------------

public static void main (String [] args) {
    BigInteger acc = BigInteger.ZERO;
    for (int k = 1;
    k <= 1000; k ++) {
        BigInteger pow = BigInteger.valueOf (k).pow (k);
        acc = acc.add (pow);
    }
    System.out.println (acc);
}
----------------------------------------

public static void main (String [] args) {
    BigInteger result = new BigInteger ("1");
    BigInteger temp = new BigInteger ("1");
    BigInteger I;
    for (int i = 1;
    i < 1001; i ++) {
        I = new BigInteger ("" + i);
        for (int j = 1;
        j < i; j ++) {
            temp = temp.multiply (I);
        }
        result = result.multiply (temp);
        temp = new BigInteger ("1");
    }
    System.out.println (result);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29676713_29676970_1_10
29676713_29677781_263_275
Title: Numbers too big for variables 
----------------------------------------

public static void main (String [] args) {
    BigInteger acc = BigInteger.ZERO;
    for (int k = 1;
    k <= 1000; k ++) {
        BigInteger pow = BigInteger.valueOf (k).pow (k);
        acc = acc.add (pow);
    }
    System.out.println (acc);
}
----------------------------------------

public static void main (String...args) {
    int ref = 0;
    IntEx result = new IntEx (0);
    while (++ ref <= 1000) {
        IntEx mul = new IntEx (1000);
        for (int i = 0;
        i < 1000; ++ i) {
            mul.multiply (new IntEx (i));
        }
        result.add (mul);
    }
    System.out.println (result.toString ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29676713_29676970_1_10
29676713_29680524_34_55
Title: Numbers too big for variables 
----------------------------------------

public static void main (String [] args) {
    BigInteger acc = BigInteger.ZERO;
    for (int k = 1;
    k <= 1000; k ++) {
        BigInteger pow = BigInteger.valueOf (k).pow (k);
        acc = acc.add (pow);
    }
    System.out.println (acc);
}
----------------------------------------

public static void main (String [] args) {
    long twoTo10 = 1024;
    long sum210 = 0;
    for (long i = 1;
    i <= 1000; i ++) {
        sum210 += pow (i, i, twoTo10);
        sum210 %= twoTo10;
    }
    long fiveTo10 = 9_765_625;
    long sum510 = 0;
    for (long i = 1;
    i <= 1000; i ++) {
        sum510 += pow (i, i, fiveTo10);
        sum510 %= fiveTo10;
    }
    long tenTo10 = 10_000_000_000L;
    long answer = sum210 * inverse (fiveTo10, twoTo10) * fiveTo10 + sum510 * inverse (twoTo10, fiveTo10) * twoTo10;
    answer %= tenTo10;
    System.out.println (answer);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29676713_29677244_5_18
29676713_29677781_263_275
Title: Numbers too big for variables 
----------------------------------------

public static void main (String [] args) {
    BigInteger result = new BigInteger ("1");
    BigInteger temp = new BigInteger ("1");
    BigInteger I;
    for (int i = 1;
    i < 1001; i ++) {
        I = new BigInteger ("" + i);
        for (int j = 1;
        j < i; j ++) {
            temp = temp.multiply (I);
        }
        result = result.multiply (temp);
        temp = new BigInteger ("1");
    }
    System.out.println (result);
}
----------------------------------------

public static void main (String...args) {
    int ref = 0;
    IntEx result = new IntEx (0);
    while (++ ref <= 1000) {
        IntEx mul = new IntEx (1000);
        for (int i = 0;
        i < 1000; ++ i) {
            mul.multiply (new IntEx (i));
        }
        result.add (mul);
    }
    System.out.println (result.toString ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29676713_29677244_5_18
29676713_29680524_34_55
Title: Numbers too big for variables 
----------------------------------------

public static void main (String [] args) {
    BigInteger result = new BigInteger ("1");
    BigInteger temp = new BigInteger ("1");
    BigInteger I;
    for (int i = 1;
    i < 1001; i ++) {
        I = new BigInteger ("" + i);
        for (int j = 1;
        j < i; j ++) {
            temp = temp.multiply (I);
        }
        result = result.multiply (temp);
        temp = new BigInteger ("1");
    }
    System.out.println (result);
}
----------------------------------------

public static void main (String [] args) {
    long twoTo10 = 1024;
    long sum210 = 0;
    for (long i = 1;
    i <= 1000; i ++) {
        sum210 += pow (i, i, twoTo10);
        sum210 %= twoTo10;
    }
    long fiveTo10 = 9_765_625;
    long sum510 = 0;
    for (long i = 1;
    i <= 1000; i ++) {
        sum510 += pow (i, i, fiveTo10);
        sum510 %= fiveTo10;
    }
    long tenTo10 = 10_000_000_000L;
    long answer = sum210 * inverse (fiveTo10, twoTo10) * fiveTo10 + sum510 * inverse (twoTo10, fiveTo10) * twoTo10;
    answer %= tenTo10;
    System.out.println (answer);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29676713_29677781_263_275
29676713_29680524_34_55
Title: Numbers too big for variables 
----------------------------------------

public static void main (String...args) {
    int ref = 0;
    IntEx result = new IntEx (0);
    while (++ ref <= 1000) {
        IntEx mul = new IntEx (1000);
        for (int i = 0;
        i < 1000; ++ i) {
            mul.multiply (new IntEx (i));
        }
        result.add (mul);
    }
    System.out.println (result.toString ());
}
----------------------------------------

public static void main (String [] args) {
    long twoTo10 = 1024;
    long sum210 = 0;
    for (long i = 1;
    i <= 1000; i ++) {
        sum210 += pow (i, i, twoTo10);
        sum210 %= twoTo10;
    }
    long fiveTo10 = 9_765_625;
    long sum510 = 0;
    for (long i = 1;
    i <= 1000; i ++) {
        sum510 += pow (i, i, fiveTo10);
        sum510 %= fiveTo10;
    }
    long tenTo10 = 10_000_000_000L;
    long answer = sum210 * inverse (fiveTo10, twoTo10) * fiveTo10 + sum510 * inverse (twoTo10, fiveTo10) * twoTo10;
    answer %= tenTo10;
    System.out.println (answer);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29678710_29686739_1_15
29678710_29700331_103_117
Title: I can't save my Image (mid blend) to file? 
----------------------------------------

public static void saveToFile (BufferedImage img, File file) {
    String filename = file.getName ();
    String suffix = filename.substring (filename.lastIndexOf ('.') + 1);
    suffix = suffix.toLowerCase ();
    if (suffix.equals ("jpg") || suffix.equals ("png")) {
        try {
            ImageIO.write (img, suffix, file);
        } catch (IOException e) {
            e.printStackTrace ();
        }
    } else {
        System.out.println ("Error: filename must end in .jpg or .png");
    }
}
----------------------------------------

public static void saveToFile (BufferedImage img, File file) {
    String filename = file.getName ();
    String suffix = filename.substring (filename.lastIndexOf ('.') + 1);
    suffix = suffix.toLowerCase ();
    if (suffix.equals ("jpg") || suffix.equals ("png")) {
        try {
            ImageIO.write (img, suffix, file);
        } catch (IOException e) {
            e.printStackTrace ();
        }
    } else {
        System.out.println ("Error: filename must end in .jpg or .png");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29682895_29683080_9_30
29682895_29746800_47_72
Title: Manage identical requests with RxJava 
----------------------------------------

public static void main (String [] args) {
    final Observable < Integer > cachedSomething = getSomething ().cache ();
    System.out.println ("before first subscription");
    cachedSomething.subscribe (new SimpleLoggingSubscriber < Integer > ("1"));
    try {
        Thread.sleep (1000);
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    System.out.println ("before second subscription");
    cachedSomething.subscribe (new SimpleLoggingSubscriber < Integer > ("2"));
    try {
        Thread.sleep (5000);
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    System.out.println ("quit");
}
----------------------------------------

public static void main (String [] args) throws Exception {
    ObservableImageCache cache = new ObservableImageCache ();
    CountDownLatch cdl = new CountDownLatch (4);
    Observable < BufferedImage > img1 = cache.get ("https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/create.png");
    System.out.println ("Subscribing for IMG1");
    img1.subscribe (e -> System.out.println ("IMG1: " + e.getWidth () + "x" + e.getHeight ()), Throwable :: printStackTrace, cdl :: countDown);
    Thread.sleep (500);
    Observable < BufferedImage > img2 = cache.get ("https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/create.png");
    System.out.println ("Subscribing for IMG2");
    img2.subscribe (e -> System.out.println ("IMG2: " + e.getWidth () + "x" + e.getHeight ()), Throwable :: printStackTrace, cdl :: countDown);
    Observable < BufferedImage > img3 = cache.get ("https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png");
    Observable < BufferedImage > img4 = cache.get ("https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png");
    Thread.sleep (500);
    System.out.println ("Subscribing for IMG3");
    img3.subscribe (e -> System.out.println ("IMG3: " + e.getWidth () + "x" + e.getHeight ()), Throwable :: printStackTrace, cdl :: countDown);
    Thread.sleep (1000);
    System.out.println ("-> Should be immediate: ");
    System.out.println ("Subscribing for IMG4");
    img4.subscribe (e -> System.out.println ("IMG4: " + e.getWidth () + "x" + e.getHeight ()), Throwable :: printStackTrace, cdl :: countDown);
    cdl.await ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29690253_29690348_10_24
29690253_29690422_7_18
Title: Select an object on the basis of its minimum attribute value from list in Java 
----------------------------------------

public static void main (String [] args) {
    LocationDistances [] arr = new LocationDistances [] {new LocationDistances ("abc", 23.234556), new LocationDistances ("xyz", 3.3444566),};
    ArrayList < LocationDistances > locsDis = new ArrayList (Arrays.asList (arr));
    Collections.sort (locsDis, new Comparator < LocationDistances > () {
        public int compare (LocationDistances o1, LocationDistances o2) {
            return (int) (o1.distances - o2.distances);
        }}

    );
}
----------------------------------------

public static void main (String [] args) {
    ArrayList < LocationDistances > locsDis = new ArrayList (Arrays.asList (new LocationDistances ("abc", 23.234556), new LocationDistances ("xyz", 3.3444566)));
    ArrayList < Double > distances = new ArrayList < Double > ();
    for (LocationDistances locationDistances : locsDis) {
        distances.add (locationDistances.getDistances ());
    }
    double minimum = Collections.min (distances);
    System.out.println (minimum);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29698293_29698328_1_13
29698293_29698425_1_12
Title: Boolean Type Method 
----------------------------------------

public static boolean duplicateKDistance (int [] array, int m) {
    for (int i = 0;
    i < array.length; i ++) {
        for (int j = i + 1;
        j <= m;) {
            if (array [i] == array [j]) return true;
            else return false;

        }
    }
    return false;
}
----------------------------------------

public static boolean duplicateKDistance (int [] array, int m) {
    for (int i = 0;
    i < array.length; i ++) {
        for (int j = i + 1;
        j <= m; j ++) {
            if (array [i] == array [j]) return true;

        }
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29698958_29699062_22_36
29698958_29699201_33_48
Title: Cannot resolve inflater and container 
----------------------------------------

public boolean onKey (View v, int keyCode, KeyEvent event) {
    if (event.getAction () == KeyEvent.ACTION_DOWN) {
        WebView webView = (WebView) v;
        switch (keyCode) {
            case KeyEvent.KEYCODE_BACK :
                if (webView.canGoBack ()) {
                    webView.goBack ();
                    return true;
                }
                break;
        }
    }
    return false;
}
----------------------------------------

public boolean onKey (View v, int keyCode, KeyEvent event) {
    if (event.getAction () == KeyEvent.ACTION_DOWN) {
        WebView webView = (WebView) v;
        switch (keyCode) {
            case KeyEvent.KEYCODE_BACK :
                if (webView.canGoBack ()) {
                    webView.goBack ();
                    return true;
                }
                break;
        }
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29709986_29710297_7_32
29709986_29744761_6_40
Title: Display words in decreasing order of their occurance 
----------------------------------------

public static void main (String [] args) {
    Map < String, Integer > map = new HashMap < > ();
    try {
        BufferedReader br = new BufferedReader (new FileReader (new File ("F:/Demo/file_reading/bin/demo/hello.txt")));
        String str;
        while ((str = br.readLine ()) != null) {
            Scanner sc = new Scanner (str);
            while (sc.hasNext ()) {
                String word = sc.next ();
                if (map.containsKey (word)) map.put (word, map.get (word) + 1);
                else map.put (word, 1);

            }
        }
        System.out.println ("yes");
    } catch (IOException e) {
        e.printStackTrace ();
    }
    map.entrySet ().stream ().sorted (Collections.reverseOrder (Map.Entry.comparingByValue ())).forEachOrdered (System.out :: println);
}
----------------------------------------

public static void main (String [] args) {
    Map < String, Integer > map = new LinkedHashMap < > ();
    try {
        BufferedReader br = new BufferedReader (new FileReader (new File ("/home/netiq/Documents/input.txt")));
        String str;
        while ((str = br.readLine ()) != null) {
            Scanner sc = new Scanner (str);
            while (sc.hasNext ()) {
                String word = sc.next ();
                if (map.containsKey (word)) map.put (word, map.get (word) + 1);
                else map.put (word, 1);

            }
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
    Comparator < String > comparator = new MyDemoComprator (map);
    Map < String, Integer > treemap = new TreeMap < String, Integer > (comparator);
    treemap.putAll (map);
    for (Map.Entry < String, Integer > entry : treemap.entrySet ()) {
        System.out.print (entry.getKey ());
        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29712933_29713185_4_30
29712933_29713390_2_41
Title: "Is there a way to convert this into a ""while loop"" or a ""do while loop""?" 
----------------------------------------

public static void main (String [] args) {
    Scanner Scanner = new Scanner (System.in);
    int x = 20;
    int y = 25;
    int Small = 0;
    int Large = 0;
    while (Small + Large <= 8) {
        System.out.println ("Enter number of small dogs: ");
        Small = Scanner.nextInt ();
        System.out.println ("Enter number of large dogs: ");
        Large = Scanner.nextInt ();
        int Revenue = ((Small * x) + (Large * y));
        int Food = ((Small + Large) * (2));
        int Facility = 30;
        int Expenses = (Food + Facility);
        int Difference = (Revenue - Expenses);
        if ((Small + Large) <= 8) {
            System.out.println ("Revenue is " + ((Small * x) + (Large * y)));
            System.out.println ("Expenses = " + (Food + Facility));
            System.out.println ("Difference = " + (Revenue - Expenses));
        }
    }
    System.out.println ("The number of dogs has exceeded the facility limit.");
}
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    int valueSmall = 20;
    int valueLarge = 25;
    int small = 0;
    int large = 0;
    int quit = 0;
    while (quit == 0) {
        System.out.println ("Enter number of small dogs: ");
        small = scanner.nextInt ();
        System.out.println ("Enter number of large dogs: ");
        large = scanner.nextInt ();
        int revenue = ((small * valueSmall) + (large * valueLarge));
        int food = ((small + large) * (2));
        int facility = 30;
        int expenses = (food + facility);
        int difference = (revenue - expenses);
        if ((small + large) <= 8) {
            System.out.println ("Revenue is " + revenue);
            System.out.println ("Expenses = " + expenses);
            System.out.println ("Difference = " + difference);
        } else {
            System.out.println ("The number of dogs has exceeded the facility limit.");
        }
        System.out.println ("Quit? Enter 0 for NO or 1 for YES:");
        quit = scanner.nextInt ();
    }
    System.out.println ("Goodbye");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29715650_29715721_1_45
29715650_29716608_1_23
Title: Taking Backup of MySQL database using Java 
----------------------------------------

public static void main (String [] args) {
    Connection con = null;
    Statement st = null;
    ResultSet rs = null;
    String url = "jdbc:mysql://localhost/t";
    String user = "";
    String password = "";
    try {
        Class.forName ("com.mysql.jdbc.Driver");
        con = DriverManager.getConnection (url, user, password);
        st = con.createStatement ();
        rs = st.executeQuery ("SELECT * FROM.........;");
        if (rs.next ()) {
            System.out.println (rs.getString (1));
        }
    } catch (SQLException ex) {
        Logger lgr = Logger.getLogger (Version.class.getName ());
        lgr.log (Level.SEVERE, ex.getMessage (), ex);
    } finally {
        try {
            if (rs != null) {
                rs.close ();
            }
            if (st != null) {
                st.close ();
            }
            if (con != null) {
                con.close ();
            }
        } catch (SQLException ex) {
            Logger lgr = Logger.getLogger (Version.class.getName ());
            lgr.log (Level.WARNING, ex.getMessage (), ex);
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    try {
        File dir = new File ("/root/");
        Runtime runtime = Runtime.getRuntime ();
        Process p = runtime.exec ("mysqldump database_name >/path-for-backpfile/database.sql", null, dir);
        BufferedReader reader = new BufferedReader (new InputStreamReader (p.getInputStream ()));
        String line = reader.readLine ();
        while (line != null) {
            System.out.println (line);
            line = reader.readLine ();
        }
    } catch (IOException e1) {
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29722378_29722417_1_19
29722378_29722498_1_23
Title: rerun program before main terminates 
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    int value = - 1;
    do {
        System.out.println ("Enter menu number: ");
        value = scanner.nextInt ();
        if (value == 1) {
            System.out.println ("first");
        } else if (value == 2) {
            System.out.println ("second");
        } else if (value == 3) {
            System.out.println ("third");
        } else {
            System.out.println ("closing program");
        }

    } while (value != - 1);
}
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    String userInput = "";
    while (true) {
        System.out.println ("Enter menu number: ");
        userInput = scanner.next ();
        if (userInput.trim ().toUpperCase ().equals ("EXIT")) {
            break;
        }
        int value = Integer.parseInt (userInput);
        if (value == 1) {
            System.out.println ("first");
        } else if (value == 2) {
            System.out.println ("second");
        } else if (value == 3) {
            System.out.println ("third");
        }

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29723077_29723156_1_21
29723077_29723178_2_26
Title: Java string compression is printing wrong string. What am I missing here? 
----------------------------------------

public String compress (String str) {
    char chararr [] = str.toCharArray ();
    StringBuilder sb = new StringBuilder ();
    int count = 1;
    char previous = chararr [0];
    for (int i = 1;
    i < chararr.length; i ++) {
        char current = chararr [i];
        if (current == previous) {
            count ++;
            continue;
        } else {
            sb.append (previous).append (count);
            count = 1;
        }
        previous = current;
    }
    sb.append (previous).append (count);
    System.out.println (sb.toString ());
    return sb.toString ();
}
----------------------------------------

public String compress (String str) {
    char chararr [] = str.toCharArray ();
    StringBuilder sb = new StringBuilder ();
    int count = 0;
    char previous = chararr [0];
    for (int i = 0;
    i < chararr.length; i ++) {
        char current = chararr [i];
        if (current == previous) {
            count ++;
        } else {
            sb.append (previous);
            if (count != 1) {
                sb.append (count);
            }
            count = 1;
        }
        previous = current;
    }
    sb.append (previous);
    if (count != 1) {
        sb.append (count);
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29723077_29723156_1_21
29723077_29723605_1_19
Title: Java string compression is printing wrong string. What am I missing here? 
----------------------------------------

public String compress (String str) {
    char chararr [] = str.toCharArray ();
    StringBuilder sb = new StringBuilder ();
    int count = 1;
    char previous = chararr [0];
    for (int i = 1;
    i < chararr.length; i ++) {
        char current = chararr [i];
        if (current == previous) {
            count ++;
            continue;
        } else {
            sb.append (previous).append (count);
            count = 1;
        }
        previous = current;
    }
    sb.append (previous).append (count);
    System.out.println (sb.toString ());
    return sb.toString ();
}
----------------------------------------

public String compress (String str) {
    String result = "";
    StringBuilder sb = new StringBuilder (str);
    while (sb.length () != 0) {
        int count = 0;
        char test = sb.charAt (0);
        while (sb.indexOf (test + "") != - 1) {
            sb.deleteCharAt (sb.indexOf (test + ""));
            count ++;
        }
        result = result + test + count;
    }
    System.out.println (result);
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29723077_29723178_2_26
29723077_29723605_1_19
Title: Java string compression is printing wrong string. What am I missing here? 
----------------------------------------

public String compress (String str) {
    char chararr [] = str.toCharArray ();
    StringBuilder sb = new StringBuilder ();
    int count = 0;
    char previous = chararr [0];
    for (int i = 0;
    i < chararr.length; i ++) {
        char current = chararr [i];
        if (current == previous) {
            count ++;
        } else {
            sb.append (previous);
            if (count != 1) {
                sb.append (count);
            }
            count = 1;
        }
        previous = current;
    }
    sb.append (previous);
    if (count != 1) {
        sb.append (count);
    }
    return sb.toString ();
}
----------------------------------------

public String compress (String str) {
    String result = "";
    StringBuilder sb = new StringBuilder (str);
    while (sb.length () != 0) {
        int count = 0;
        char test = sb.charAt (0);
        while (sb.indexOf (test + "") != - 1) {
            sb.deleteCharAt (sb.indexOf (test + ""));
            count ++;
        }
        result = result + test + count;
    }
    System.out.println (result);
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29725031_29725919_16_28
29725031_29725919_30_43
Title: Calling multiple constructors - Only goes to the same one? 
----------------------------------------

public Car () {
    numberOfCars = 1;
    company = "BMW";
    modelName = "BMW M3 DTM";
    modelYear = "2012";
    hp = 500;
    doors = 2;
    gears = "Clutch";
    color = "Black";
    racingCar = true;
    price = - 1;
}
----------------------------------------

public Car (String companyName, String modelNa, String modelYe) {
    numberOfCars = 1;
    company = companyName;
    modelName = modelNa;
    modelYear = modelYe;
    hp = 500;
    doors = 2;
    gears = "Clutch";
    color = "White";
    racingCar = true;
    price = 100000;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29725031_29725919_16_28
29725031_29725919_44_57
Title: Calling multiple constructors - Only goes to the same one? 
----------------------------------------

public Car () {
    numberOfCars = 1;
    company = "BMW";
    modelName = "BMW M3 DTM";
    modelYear = "2012";
    hp = 500;
    doors = 2;
    gears = "Clutch";
    color = "Black";
    racingCar = true;
    price = - 1;
}
----------------------------------------

public Car (int carAmount, String companyTitle, String modelTitle, String modelBirth, double horsePower, int door, String gearType, String colors, boolean raceCar, double prices) {
    numberOfCars = carAmount;
    company = companyTitle;
    modelName = modelTitle;
    modelYear = modelBirth;
    hp = horsePower;
    doors = door;
    gears = gearType;
    color = colors;
    racingCar = raceCar;
    price = prices;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29725031_29725919_30_43
29725031_29725919_44_57
Title: Calling multiple constructors - Only goes to the same one? 
----------------------------------------

public Car (String companyName, String modelNa, String modelYe) {
    numberOfCars = 1;
    company = companyName;
    modelName = modelNa;
    modelYear = modelYe;
    hp = 500;
    doors = 2;
    gears = "Clutch";
    color = "White";
    racingCar = true;
    price = 100000;
}
----------------------------------------

public Car (int carAmount, String companyTitle, String modelTitle, String modelBirth, double horsePower, int door, String gearType, String colors, boolean raceCar, double prices) {
    numberOfCars = carAmount;
    company = companyTitle;
    modelName = modelTitle;
    modelYear = modelBirth;
    hp = horsePower;
    doors = door;
    gears = gearType;
    color = colors;
    racingCar = raceCar;
    price = prices;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29725528_29725830_1_13
29725528_29725950_1_14
Title: How to write base case for this recursive function that removes children of nodes that hold odd keys? 
----------------------------------------

private void removeOddSubtrees (Node root) {
    if (root != null) {
        removeOddSubtrees (root.left);
        removeOddSubtrees (root.right);
        if (root.key % 2 != 0) {
            root.right = null;
            root.left = null;
            root = null;
        } else {
            return;
        }
    }
}
----------------------------------------

private void removeOddSubtrees (Node root) {
    if (root == null) {
        return;
    }
    if (root.key % 2 != 0) {
        root.right = null;
        root.left = null;
        return;
    }
    removeOddSubtrees (root.left);
    removeOddSubtrees (root.right);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29725817_29725837_1_10
29725817_29725868_1_12
Title: Values from letters in Java 
----------------------------------------

public static void printLetters (char a, char b) {
    char temp;
    if (a > b) {
        temp = a;
        a = b;
        b = temp;
    }
    while (a <= b) System.out.print ((char) a ++);

}
----------------------------------------

public static void printLetters (char a, char b) {
    char temp;
    if (a > b) {
        temp = a;
        a = b;
        b = temp;
    }
    while (a < b) {
        a ++;
        System.out.println (a);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29728997_29729028_2_11
29728997_29729031_1_13
Title: How to fix bug found by find bugs 
----------------------------------------

@Override
public boolean equals (Object o) {
    if (! (o instanceof Date)) return false;

    Date dateIn = (Date) o;
    if (day == dateIn.day && month == dateIn.month && year == dateIn.year) return true;
    else return false;

}
----------------------------------------

@Override
public boolean equals (Object other) {
    if (this == other) return true;

    if (! (other instanceof Date)) return false;

    Date dateIn = (Date) other;
    if (day == dateIn.day && month == dateIn.month && year == dateIn.year) return true;
    else return false;

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29728997_29729028_2_11
29728997_29729053_2_12
Title: How to fix bug found by find bugs 
----------------------------------------

@Override
public boolean equals (Object o) {
    if (! (o instanceof Date)) return false;

    Date dateIn = (Date) o;
    if (day == dateIn.day && month == dateIn.month && year == dateIn.year) return true;
    else return false;

}
----------------------------------------

@Override
public boolean equals (Object object) {
    if (this == object) return true;

    if (! (object instanceof Date)) return false;

    Date dateIn = (Date) object;
    if (day == dateIn.day && month == dateIn.month && year == dateIn.year) return true;
    else return false;

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29728997_29729031_1_13
29728997_29729053_2_12
Title: How to fix bug found by find bugs 
----------------------------------------

@Override
public boolean equals (Object other) {
    if (this == other) return true;

    if (! (other instanceof Date)) return false;

    Date dateIn = (Date) other;
    if (day == dateIn.day && month == dateIn.month && year == dateIn.year) return true;
    else return false;

}
----------------------------------------

@Override
public boolean equals (Object object) {
    if (this == object) return true;

    if (! (object instanceof Date)) return false;

    Date dateIn = (Date) object;
    if (day == dateIn.day && month == dateIn.month && year == dateIn.year) return true;
    else return false;

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29740976_41445743_15_50
29740976_47702002_10_36
Title: How to use joptimizer for linear programming 
----------------------------------------

public static void main (String [] args) throws Exception {
    LinearMultivariateRealFunction objectiveFunction = new LinearMultivariateRealFunction (new double [] {3.0, 4.0}, 0);
    ConvexMultivariateRealFunction [] inequalities = new ConvexMultivariateRealFunction [4];
    inequalities [0] = new LinearMultivariateRealFunction (new double [] {- 1.0, 0.00}, 0.0);
    inequalities [1] = new LinearMultivariateRealFunction (new double [] {0.0, - 1.00}, 0.0);
    inequalities [2] = new LinearMultivariateRealFunction (new double [] {- 2.0, - 3.00}, 8.0);
    inequalities [3] = new LinearMultivariateRealFunction (new double [] {- 5.0, - 2.00}, 12.0);
    OptimizationRequest or = new OptimizationRequest ();
    or.setF0 (objectiveFunction);
    or.setFi (inequalities);
    or.setToleranceFeas (1.E-9);
    or.setTolerance (1.E-9);
    JOptimizer opt = new JOptimizer ();
    opt.setOptimizationRequest (or);
    int returnCode = opt.optimize ();
    double [] sol = opt.getOptimizationResponse ().getSolution ();
    System.out.println ("Length: " + sol.length);
    for (int i = 0;
    i < sol.length / 2; i ++) {
        System.out.println ("X" + (i + 1) + ": " + Math.round (sol [i]) + "\ty" + (i + 1) + ": " + Math.round (sol [i + 1]));
    }
}
----------------------------------------

public static void main (String [] args) throws Exception {
    double [] c = new double [] {- 1., - 1.};
    double [] [] G = new double [] [] {{4./ 3., - 1}, {- 1./ 2., 1.}, {- 2., - 1.}, {1./ 3., 1.}};
    double [] h = new double [] {2., 1./ 2., 2., 1./ 2.};
    double [] lb = new double [] {0, 0};
    double [] ub = new double [] {10, 10};
    LPOptimizationRequest or = new LPOptimizationRequest ();
    or.setC (c);
    or.setG (G);
    or.setH (h);
    or.setLb (lb);
    or.setUb (ub);
    or.setDumpProblem (true);
    LPPrimalDualMethod opt = new LPPrimalDualMethod ();
    opt.setLPOptimizationRequest (or);
    opt.optimize ();
    double [] sol = opt.getOptimizationResponse ().getSolution ();
    System.out.println ("Solution = " + Arrays.toString (sol));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29742530_29743147_1_26
29742530_29746636_3_64
Title: Sorting groups of values according to total value 
----------------------------------------

public static void main (String [] args) {
    Team t1 = new Team ("T1");
    List < Competitors > t1Competitors = new ArrayList < > ();
    Competitor c1 = new Competitor ("John", "Doe");
    List < Integer > c1Punctuation = new ArrayList < > ();
    c1Punctuation.add ("10");
    c1Punctuation.add ("20");
    c1Punctuation.add ("30");
    c1.setPunctuation (c1Punctuation);
    t1Competitors.add (c1);
    t1.setCompetitors (t1Competitors);
    int t1Score = t1.getScore ();
}
----------------------------------------

public static void main (String [] args) {
    Player pOne = new Player ();
    pOne.setD1 (10);
    pOne.setD2 (20);
    pOne.setD3 (30);
    pOne.setD4 (60);
    pOne.setRank (2);
    pOne.setName ("ABD");
    pOne.setTotal (60);
    Player pTwo = new Player ();
    pTwo.setD1 (20);
    pTwo.setD2 (20);
    pTwo.setD3 (40);
    pTwo.setD4 (70);
    pTwo.setRank (2);
    pTwo.setName ("SPC");
    pTwo.setTotal (60);
    ArrayList < Player > playerListOne = new ArrayList < Player > ();
    playerListOne.add (pOne);
    playerListOne.add (pTwo);
    Player pTOne = new Player ();
    pTOne.setD1 (10);
    pTOne.setD2 (70);
    pTOne.setD3 (30);
    pTOne.setD4 (90);
    pTOne.setRank (2);
    pTOne.setName ("ABD");
    pTOne.setTotal (60);
    Player pTTwo = new Player ();
    pTTwo.setD1 (20);
    pTTwo.setD2 (20);
    pTTwo.setD3 (40);
    pTTwo.setD4 (60);
    pTTwo.setRank (2);
    pTTwo.setName ("SPC");
    pTTwo.setTotal (80);
    ArrayList < Player > playerListTwo = new ArrayList < Player > ();
    playerListTwo.add (pTOne);
    playerListTwo.add (pTTwo);
    Team one = new Team ();
    one.setPlayer (playerListOne);
    one.setTeamTotal (playerListOne);
    Team two = new Team ();
    two.setPlayer (playerListTwo);
    two.setTeamTotal (playerListTwo);
    ArrayList < Team > team = new ArrayList < Team > ();
    team.add (one);
    team.add (two);
    Collections.sort (team, Team.totalComparator);
    System.out.println (team);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29786197_38785072_10_17
29786197_38785072_19_30
Title: Gson JsonObject copy value affected others JsonObject instance 
----------------------------------------

@Nonnull
public static JsonArray deepCopy (@Nonnull
JsonArray jsonArray) {
    JsonArray result = new JsonArray ();
    for (JsonElement e : jsonArray) {
        result.add (deepCopy (e));
    }
    return result;
}
----------------------------------------

@Nonnull
public static JsonElement deepCopy (@Nonnull
JsonElement jsonElement) {
    if (jsonElement.isJsonPrimitive () || jsonElement.isJsonNull ()) {
        return jsonElement;
    } else if (jsonElement.isJsonObject ()) {
        return deepCopy (jsonElement.getAsJsonObject ());
    } else if (jsonElement.isJsonArray ()) {
        return deepCopy (jsonElement.getAsJsonArray ());
    } else {
        throw new UnsupportedOperationException ("Unsupported element: " + jsonElement);
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29786197_38785072_10_17
29786197_38785072_1_8
Title: Gson JsonObject copy value affected others JsonObject instance 
----------------------------------------

@Nonnull
public static JsonArray deepCopy (@Nonnull
JsonArray jsonArray) {
    JsonArray result = new JsonArray ();
    for (JsonElement e : jsonArray) {
        result.add (deepCopy (e));
    }
    return result;
}
----------------------------------------

@Nonnull
public static JsonObject deepCopy (@Nonnull
JsonObject jsonObject) {
    JsonObject result = new JsonObject ();
    for (Map.Entry < String, JsonElement > entry : jsonObject.entrySet ()) {
        result.add (entry.getKey (), deepCopy (entry.getValue ()));
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29786197_38785072_19_30
29786197_38785072_1_8
Title: Gson JsonObject copy value affected others JsonObject instance 
----------------------------------------

@Nonnull
public static JsonElement deepCopy (@Nonnull
JsonElement jsonElement) {
    if (jsonElement.isJsonPrimitive () || jsonElement.isJsonNull ()) {
        return jsonElement;
    } else if (jsonElement.isJsonObject ()) {
        return deepCopy (jsonElement.getAsJsonObject ());
    } else if (jsonElement.isJsonArray ()) {
        return deepCopy (jsonElement.getAsJsonArray ());
    } else {
        throw new UnsupportedOperationException ("Unsupported element: " + jsonElement);
    }

}
----------------------------------------

@Nonnull
public static JsonObject deepCopy (@Nonnull
JsonObject jsonObject) {
    JsonObject result = new JsonObject ();
    for (Map.Entry < String, JsonElement > entry : jsonObject.entrySet ()) {
        result.add (entry.getKey (), deepCopy (entry.getValue ()));
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29787284_29787495_28_49
29787284_29787685_3_15
Title: Why is my bubble sort not working? Java 
----------------------------------------

public static void MichaelBubbleSort (int [] arr, String [] firstName, String [] lastName) {
    int temp;
    String tempFirstName, tempLastName;
    for (int i = 0;
    i < arr.length - 1; i ++) {
        for (int j = 1;
        j < arr.length - i; j ++) {
            if (arr [j - 1] > arr [j]) {
                temp = arr [j - 1];
                arr [j - 1] = arr [j];
                arr [j] = temp;
                tempFirstName = firstName [j - 1];
                firstName [j - 1] = firstName [j];
                firstName [j] = tempFirstName;
                tempLastName = lastName [j - 1];
                lastName [j - 1] = lastName [j];
                lastName [j] = tempLastName;
            }
        }
    }
}
----------------------------------------

public static void MichaelBubbleSort (Person [] arr) {
    Person temp;
    for (int i = 0;
    i < arr.length - 1; i ++) {
        for (int j = 1;
        j < arr.length - i; j ++) {
            if (arr [j - 1].score > arr [j].score) {
                temp = arr [j - 1];
                arr [j - 1] = arr [j];
                arr [j] = temp;
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29796871_29798504_7_64
29796871_29802041_159_194
Title: How to slowly change object color from one to another? 
----------------------------------------

public static void main (String args []) {
    final JFrame frame = new JFrame ();
    frame.setBounds (100, 100, 300, 300);
    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    final Component comp = frame.getContentPane ();
    comp.setBackground (new Color ((float) Math.random (), (float) Math.random (), (float) Math.random ()));
    frame.setVisible (true);
    final Timer timer = new Timer (50, new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent evt) {
            final Color targetColor = new Color (30, 40, 50);
            final int changingSpeed = 5;
            final Color currentColor = comp.getBackground ();
            int r = currentColor.getRed ();
            int g = currentColor.getGreen ();
            int b = currentColor.getBlue ();
            double dr = targetColor.getRed () - r;
            double dg = targetColor.getGreen () - g;
            double db = targetColor.getBlue () - b;
            double norm = Math.sqrt (dr * dr + dg * dg + db * db);
            if (norm < .001) {
                ((Timer) (evt.getSource ())).stop ();
                return;
            }
            dr /= norm;
            dg /= norm;
            db /= norm;
            dr *= Math.min (changingSpeed, norm);
            dg *= Math.min (changingSpeed, norm);
            db *= Math.min (changingSpeed, norm);
            r += dr;
            g += dg;
            b += db;
            comp.setBackground (new Color (r, g, b));
            frame.repaint ();
        }}

    );
    timer.start ();
}
----------------------------------------

public static void main (String [] args) {
    JComponent textField1 = new JTextField (10);
    textField1.setBackground (Color.YELLOW);
    JComponent textField3 = new JTextField (10);
    JComponent textField4 = new JTextField (10);
    JComponent button = new JButton ("Start");
    JComponent checkBox = new JCheckBox ("Check Box");
    JFrame frame = new JFrame ("Fading Background");
    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    frame.getContentPane ().add (textField1, BorderLayout.NORTH);
    frame.getContentPane ().add (button, BorderLayout.SOUTH);
    frame.getContentPane ().add (textField3, BorderLayout.WEST);
    frame.getContentPane ().add (textField4, BorderLayout.EAST);
    frame.getContentPane ().add (checkBox);
    Fader fader = new Fader (new Color (155, 255, 155), 10, 50);
    fader.add (textField1);
    fader.add (textField3);
    fader.add (checkBox);
    fader = new Fader (new Color (255, 155, 155), 1, 1);
    fader.add (textField4);
    fader.add (button);
    frame.pack ();
    frame.setVisible (true);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29802290_29802635_7_23
29802290_29804193_6_20
Title: How to find smallest number without using java sort() 
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter size of Array::");
    int size = sc.nextInt ();
    List < Integer > numbers = new ArrayList < Integer > ();
    for (int i = 0;
    i < size; i ++) {
        numbers.add (sc.nextInt ());
    }
    System.out.println (" Search value:");
    int n = sc.nextInt ();
    if (n > 0 && n <= size) {
        int nthSmall = select (numbers, 0, size - 1, n);
        System.out.println ("Minimum Value is: " + nthSmall);
    } else {
        System.out.println ("Invalid Entry");
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter size of Array::");
    int sizee = sc.nextInt ();
    TreeSet < Integer > numbers = new TreeSet < Integer > ();
    for (int i = 0;
    i < sizee; i ++) {
        numbers.add (sc.nextInt ());
    }
    System.out.println (" Search value:");
    int num = sc.nextInt ();
    System.out.println ("Minimum Value is:" + numbers.first ());
    System.out.println ("Minimum:" + numbers.ceiling (num));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29813126_29813283_79_116
29813126_29813313_1_29
Title: How to know in which item a button was clicked 
----------------------------------------

public View getView (int position, View convertView, ViewGroup parent) {
    final ViewHolder holder;
    holder = new ViewHolder ();
    convertView = mInflater.inflate (R.layout.seekbar_adapter_layout, null);
    holder.img = (ImageView) convertView.findViewById (R.id.imageView1);
    holder.seekbar = (SeekBar) convertView.findViewById (R.id.seekBar1);
    holder.colorbutton = (ImageView) convertView.findViewById (R.id.colorImage);
    holder.ln_img = (LinearLayout) convertView.findViewById (R.id.ln_colorimg);
    convertView.setTag (holder);
    holder.img.setImageBitmap (itemsList.get (position));
    if (positionProgress.get (position) != null) {
        holder.seekbar.setVisibility (View.VISIBLE);
        holder.ln_img.setVisibility (View.GONE);
        holder.seekbar.setProgress (positionProgress.get (position));
    } else {
        holder.ln_img.setVisibility (View.VISIBLE);
        holder.seekbar.setVisibility (View.GONE);
        holder.colorbutton.setBackgroundColor (Color.rgb (this.colorItem.get (position).getRcolor (), this.colorItem.get (position).getGcolor (), this.colorItem.get (position).getBcolor ()));
    }
    holder.seekbar.setOnSeekBarChangeListener (mSeekListener);
    holder.ln_img.setOnClickListener (mImgClickListener);
    holder.seekbar.setTag (position);
    holder.ln_img.setTag (position);
    return convertView;
}
----------------------------------------

@Override
public View getView (final int position, View convertView, ViewGroup parent) {
    Holder holder = new Holder ();
    View rowView;
    rowView = inflater.inflate (R.layout.rowlayout2, null);
    holder.name = (TextView) rowView.findViewById (R.id.EditTextName);
    holder.address = (TextView) rowView.findViewById (R.id.EditTextAddress);
    holder.ib = (ImageButton) rowView.findViewById (R.id.Delete);
    holder.name.setText (n [position]);
    holder.address.setText (a [position]);
    holder.ib.setTag (convertView);
    holder.ib.setOnClickListener (new OnClickListener () {
    }

    );
    rowView.setOnClickListener (new OnClickListener () {
        @Override
        public void onClick (View v) {
            Toast.makeText (context, "You Clicked " + n [position], Toast.LENGTH_LONG).show ();
        }}

    );
    return rowView;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29813986_29814214_2_21
29813986_29817068_9_37
Title: Process command line arguments 
----------------------------------------

public static void main (String [] args) {
    if (args == null) {
        System.out.println ("No arguments supplied, exiting");
        System.exit (0);
    }
    int numAttr = args [0].split (",").length;
    String [] attr = new String [numAttr];
    for (int i = 0;
    i < args.length; ++ i) {
        String [] parts = args [i].split (",");
        for (int j = 0;
        j < parts.length; ++ j) {
            if (i > 0) {
                attr [j] += ",";
            }
            attr [j] += parts [j];
        }
    }
}
----------------------------------------

public static void main (String [] args) throws IllegalFormatException {
    StringBuilder [] attributes = new StringBuilder [COUNT_COLUMNS];
    for (int i = 0;
    i < COUNT_COLUMNS; i ++) {
        attributes [i] = new StringBuilder ();
    }
    for (int numArgs = 0;
    numArgs < args.length; numArgs ++) {
        String [] values = args [numArgs].split (" *, *");
        if (values.length != COUNT_COLUMNS) {
            throw new IllegalArgumentException ("invalid number of fields, must be " + COUNT_COLUMNS);
        }
        int numVal = 0;
        for (String val : values) {
            attributes [numVal].append (numArgs > 0 ? "," : "").append (val.trim ());
            numVal ++;
        }
    }
    for (StringBuilder att : attributes) {
        System.out.println (att);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29815080_29816044_5_39
29815080_29818412_1_33
Title: Creating XML- input data from HashMap 
----------------------------------------

public static void main (String args []) {
    try {
        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance ();
        DocumentBuilder builder = docFactory.newDocumentBuilder ();
        Document document = builder.newDocument ();
        Map < String, String > data = new HashMap < String, String > ();
        data.put ("A.B.C.C1.C11", "C11");
        data.put ("A.B.C.C1.C12", "C12");
        data.put ("A.B.C.C2.C21", "C21");
        data.put ("A.B.C.C2.C22", "C22");
        data.put ("A.B.C.C3.C31", "C31");
        data.put ("A.B.C.C.D", "D");
        Iterator < Entry < String, String > > it = data.entrySet ().iterator ();
        while (it.hasNext ()) {
            Map.Entry < String, String > pair = (Map.Entry < String, String >) it.next ();
            System.out.println (pair.getKey () + " = " + pair.getValue ());
            appendElement (document, pair.getKey (), pair.getValue ());
            it.remove ();
        }
        TransformerFactory tFactory = TransformerFactory.newInstance ();
        Transformer transformer = tFactory.newTransformer ();
        transformer.setOutputProperty (OutputKeys.INDENT, "yes");
        transformer.setOutputProperty ("{http://xml.apache.org/xslt}indent-amount", "2");
        DOMSource source = new DOMSource (document);
        StreamResult result = new StreamResult (new File ("C:/Users/Desktop/BuddyCode.xml"));
        transformer.transform (source, result);
    } catch (Exception e) {
        System.out.println ("Exception: " + e);
    }
}
----------------------------------------

static void main (String [] args) throws Exception {
    Map < String, String > data = new HashMap < String, String > ();
    data.put ("A.B.C.C1.C11", "C11");
    data.put ("A.B.C.C1.C12", "C12");
    data.put ("A.B.C.C2.C21", "C21");
    data.put ("A.B.C.C2.C22", "C22");
    data.put ("A.B.C.C3.C31", "C31");
    data.put ("A.B.C.C.D", "D");
    DocumentBuilderFactory f = DocumentBuilderFactory.newInstance ();
    DocumentBuilder db = f.newDocumentBuilder ();
    Document d = db.newDocument ();
    for (Map.Entry < String, String > entry : data.entrySet ()) {
        Node n = d;
        String [] keys = entry.getKey ().split ("\\.");
        for (String k : keys) {
            NodeList nodes = d.getElementsByTagName (k);
            if (nodes.getLength () == 0) {
                n.appendChild (n = d.createElement (k));
            } else {
                n = nodes.item (0);
            }
        }
        n.appendChild (d.createTextNode (entry.getValue ()));
    }
    TransformerFactory tf = TransformerFactory.newInstance ();
    Transformer t = tf.newTransformer ();
    t.setOutputProperty (OutputKeys.INDENT, "yes");
    t.setOutputProperty ("{http://xml.apache.org/xslt}indent-amount", "2");
    t.transform (new DOMSource (d), new StreamResult (System.out));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29822628_29822783_1_36
29822628_29823062_7_31
Title: Switch statement loops through 
----------------------------------------

public static void printMenu () throws IOException {
    Scanner scanner = new Scanner (System.in);
    int selection = 0;
    do {
        System.out.println ("Choose option: ");
        System.out.println ("1. Option 1");
        System.out.println ("2. Option 2");
        System.out.println ("3. QUIT");
        System.out.println ("\t\t\t");
        selection = (char) scanner.nextInt ();
        switch (selection) {
            case 1 :
                System.out.printf ("opt1 chosen\n");
                break;
            case 2 :
                System.out.printf ("opt2 chosen\n");
                break;
            case 3 :
                break;
        }
        scanner.nextLine ();
    } while (selection != '3');
}
----------------------------------------

public static void printMenu () throws IOException {
    char selection = '0';
    while (selection != '3') {
        if (selection != '\n') {
            System.out.println ("Choose option: ");
            System.out.println ("1. Option 1");
            System.out.println ("2. Option 2");
            System.out.println ("3. QUIT");
            System.out.println ("\t\t\t");
        }
        selection = (char) System.in.read ();
        switch (selection) {
            case '1' :
                System.out.printf ("opt1 chosen\n");
                break;
            case '2' :
                System.out.printf ("opt2 chosen\n");
                break;
            case '3' :
                break;
            default :
                break;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29823005_29823276_1_18
29823005_29823418_1_17
Title: Compare values in two hashamps and increment counter 
----------------------------------------

public void checkEqualValues (HashMap < Integer, Double > A, HashMap < Integer, Double > B) {
    int correctValuesCounter = 0, incorrectValuesCounter = 0;
    if (A.values ().containsAll (B.values ()) && B.values ().containsAll (A.values ())) {
        for (int key : A.keySet ()) {
            if (A.get (key).equals (B.get (key))) {
                correctValuesCounter ++;
            } else {
                incorrectValuesCounter ++;
            }
        }
        System.out.println ("correctValuesCounter: " + correctValuesCounter);
        System.out.println ("incorrectValuesCounter:" + incorrectValuesCounter);
    } else {
        if (A.size () != B.size ()) System.out.println ("HashMaps are of different sizes");

        System.out.println ("HashMap's keys are different.");
    }
}
----------------------------------------

public void checkEqualValues (HashMap < Integer, Double > A, HashMap < Integer, Double > B) {
    if (A.size () == B.size ()) {
        for (int key : A.keySet ()) {
            if (B.containsKey (key)) {
                if (Objects.equals (A.get (key), B.get (key))) {
                    correctValuesCounter ++;
                }
            } else {
                incorrectValuesCounter ++;
            }
        }
        System.out.println ("correctValuesCounter: " + correctValuesCounter);
        System.out.println ("incorrectValuesCounter:" + incorrectValuesCounter);
    } else {
        System.out.println ("HashMaps are of different sizes");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29826916_29827725_52_68
29826916_29827783_27_35
Title: Display a window to obtain user input 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    String text = textfield.getText ();
    int age = Integer.parseInt (text);
    if (age < 18) {
        label.setText ("Hi youngster!");
    } else {
        label.setText ("Hello mature!");
    }
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    String inputText = input.getText ();
    int age = Integer.parseInt (inputText);
    if (age < 18) {
        output.setText ("Hi youngster!");
    } else {
        output.setText ("Hello mature!");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29826916_29827725_52_68
29826916_29827977_60_75
Title: Display a window to obtain user input 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    String text = textfield.getText ();
    int age = Integer.parseInt (text);
    if (age < 18) {
        label.setText ("Hi youngster!");
    } else {
        label.setText ("Hello mature!");
    }
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    String content = ageField.getText ();
    int age = - 1;
    try {
        age = Integer.parseInt (content);
        if (isValid (age)) {
            res.setText (age < 18 ? YOUNG_RESPONSE : ADULT_RESPONSE);
        } else {
            res.setText (INVALID_AGE);
        }
        if (! res.isVisible ()) res.setVisible (true);

    } catch (NumberFormatException ex) {
        res.setText ("Wrong input");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29826916_29827783_27_35
29826916_29827977_60_75
Title: Display a window to obtain user input 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    String inputText = input.getText ();
    int age = Integer.parseInt (inputText);
    if (age < 18) {
        output.setText ("Hi youngster!");
    } else {
        output.setText ("Hello mature!");
    }
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    String content = ageField.getText ();
    int age = - 1;
    try {
        age = Integer.parseInt (content);
        if (isValid (age)) {
            res.setText (age < 18 ? YOUNG_RESPONSE : ADULT_RESPONSE);
        } else {
            res.setText (INVALID_AGE);
        }
        if (! res.isVisible ()) res.setVisible (true);

    } catch (NumberFormatException ex) {
        res.setText ("Wrong input");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29841820_29842030_1_16
29841820_29844114_3_21
Title: Java Eclipse TestMaxOfDigits 
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    while (input.hasNextInt ()) {
        int n = input.nextInt ();
        long max = 0;
        if (n % 10 > max) {
            max = n % 10;
            System.out.println ("max =" + max);
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner keyboard = new Scanner (System.in);
    System.out.println ("Input number");
    int input = keyboard.nextInt ();
    keyboard.close ();
    int max = 0;
    if (input >= 0) {
        while (input != 0) {
            if (max < input % 10) max = input % 10;

            input = input / 10;
        }
    } else {
        System.out.println ("Invalid Input");
    }
    System.out.println (max);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29844173_29844386_12_20
29844173_29844473_33_41
Title: Java extends generic prototype 
----------------------------------------

public static void main (String [] args) {
    C < ? > c;
    if (isSomethingLoaded) {
        c = new C < > (new A ());
    } else {
        c = new C < > (new B ());
    }
    c.doSomethingElse ();
}
----------------------------------------

public static void main (String [] args) {
    C c;
    if (isSomethingLoaded) {
        c = new C (new A ());
    } else {
        c = new C (new B ());
    }
    c.doSomething ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29845220_29846054_6_49
29845220_52018767_7_41
Title: Not able to generate all the Kaprekar Number in a range 
----------------------------------------

public static void main (String [] args) {
    Scanner scan = new Scanner (System.in);
    int p = scan.nextInt ();
    int q = scan.nextInt ();
    boolean exist = false;
    if (q <= p) {
        System.out.println ("INVALID RANGE");
        return;
    }
    int m = 0, n = 0;
    long sqr = 0;
    String numb = "";
    String [] digits = new String [2];
    for (long i = p;
    i <= q; i ++) {
        if (i == 1) System.out.print (1 + " ");
        else {
            sqr = i * i;
            numb = String.valueOf (sqr);
            if (numb.length () % 2 == 0) {
                digits [0] = numb.substring (0, numb.length () / 2);
                digits [1] = numb.substring (numb.length () / 2);
            } else {
                digits [0] = numb.substring (0, (numb.length () - 1) / 2);
                digits [1] = numb.substring ((numb.length () - 1) / 2);
            }
            if (digits [0] == "") m = 0;

            if (digits [1] == "") n = 0;

            if (! digits [1].equals ("") && ! digits [0].equals ("")) {
                m = Integer.parseInt (digits [0]);
                n = Integer.parseInt (digits [1]);
            }
            if (i == (m + n)) {
                System.out.print (i + " ");
                exist = true;
            }
        }
    }
    if (exist == false) {
        System.out.println ("INVALID RANGE");
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    int p = scanner.nextInt ();
    int q = scanner.nextInt ();
    long i, n, s, a, c, k, d, e = 0;
    for (i = p; i <= q; i ++) {
        k = i;
        d = 0;
        while (k != 0) {
            d ++;
            k = k / 10;
        }
        c = 0;
        s = 0;
        n = i * i;
        while (n != 0) {
            a = n % 10;
            n = n / 10;
            s = s + (int) Math.pow (10, c) * a;
            c ++;
            if (n + s == i && (c == d || c == d - 1) && s != 0) {
                System.out.print (i + " ");
                e ++;
                break;
            }
        }
    }
    if (e == 0) {
        System.out.println ("INVALID RANGE");
    }
    scanner.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2985317_3022314_3_20
2985317_9774655_5_23
Title: Critical Path Method Algorithm 
----------------------------------------

public static void main (String [] args) {
    HashSet < Task > allTasks = new HashSet < Task > ();
    Task end = new Task ("End", 0);
    Task F = new Task ("F", 2, end);
    Task A = new Task ("A", 3, end);
    Task X = new Task ("X", 4, F, A);
    Task Q = new Task ("Q", 2, A, X);
    Task start = new Task ("Start", 0, Q);
    allTasks.add (end);
    allTasks.add (F);
    allTasks.add (A);
    allTasks.add (X);
    allTasks.add (Q);
    allTasks.add (start);
    System.out.println ("Critical Path: " + Arrays.toString (criticalPath (allTasks)));
}
----------------------------------------

public static void main (String [] args) {
    HashSet < Task > allTasks = new HashSet < Task > ();
    Task end = new Task ("End", 0);
    Task F = new Task ("F", 2, end);
    Task A = new Task ("A", 3, end);
    Task X = new Task ("X", 4, F, A);
    Task Q = new Task ("Q", 2, A, X);
    Task start = new Task ("Start", 0, Q);
    allTasks.add (end);
    allTasks.add (F);
    allTasks.add (A);
    allTasks.add (X);
    allTasks.add (Q);
    allTasks.add (start);
    Task [] result = criticalPath (allTasks);
    print (result);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2985317_3022314_43_55
2985317_9774655_65_77
Title: Critical Path Method Algorithm 
----------------------------------------

public boolean isDependent (Task t) {
    if (dependencies.contains (t)) {
        return true;
    }
    for (Task dep : dependencies) {
        if (dep.isDependent (t)) {
            return true;
        }
    }
    return false;
}
----------------------------------------

public boolean isDependent (Task t) {
    if (dependencies.contains (t)) {
        return true;
    }
    for (Task dep : dependencies) {
        if (dep.isDependent (t)) {
            return true;
        }
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2985317_3022314_58_115
2985317_9774655_80_135
Title: Critical Path Method Algorithm 
----------------------------------------

public static Task [] criticalPath (Set < Task > tasks) {
    HashSet < Task > completed = new HashSet < Task > ();
    HashSet < Task > remaining = new HashSet < Task > (tasks);
    while (! remaining.isEmpty ()) {
        boolean progress = false;
        for (Iterator < Task > it = remaining.iterator ();
        it.hasNext ();) {
            Task task = it.next ();
            if (completed.containsAll (task.dependencies)) {
                int critical = 0;
                for (Task t : task.dependencies) {
                    if (t.criticalCost > critical) {
                        critical = t.criticalCost;
                    }
                }
                task.criticalCost = critical + task.cost;
                completed.add (task);
                it.remove ();
                progress = true;
            }
        }
        if (! progress) throw new RuntimeException ("Cyclic dependency, algorithm stopped!");

    }
    Task [] ret = completed.toArray (new Task [0]);
    Arrays.sort (ret, new Comparator < Task > () {
        @Override
        public int compare (Task o1, Task o2) {
            int i = o2.criticalCost - o1.criticalCost;
            if (i != 0) return i;

            if (o1.isDependent (o2)) return - 1;

            if (o2.isDependent (o1)) return 1;

            return 0;
        }}

    );
    return ret;
}
----------------------------------------

public static Task [] criticalPath (Set < Task > tasks) {
    HashSet < Task > completed = new HashSet < Task > ();
    HashSet < Task > remaining = new HashSet < Task > (tasks);
    while (! remaining.isEmpty ()) {
        boolean progress = false;
        for (Iterator < Task > it = remaining.iterator ();
        it.hasNext ();) {
            Task task = it.next ();
            if (completed.containsAll (task.dependencies)) {
                int critical = 0;
                for (Task t : task.dependencies) {
                    if (t.criticalCost > critical) {
                        critical = t.criticalCost;
                    }
                }
                task.criticalCost = critical + task.cost;
                completed.add (task);
                it.remove ();
                progress = true;
            }
        }
        if (! progress) throw new RuntimeException ("Cyclic dependency, algorithm stopped!");

    }
    maxCost (tasks);
    HashSet < Task > initialNodes = initials (tasks);
    calculateEarly (initialNodes);
    Task [] ret = completed.toArray (new Task [0]);
    Arrays.sort (ret, new Comparator < Task > () {
        @Override
        public int compare (Task o1, Task o2) {
            return o1.name.compareTo (o2.name);
        }}

    );
    return ret;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29862577_29862840_1_28
29862577_29863788_4_24
Title: How to check whether a list is a subset of another list 
----------------------------------------

public static void main (String [] args) {
    List < Integer > list1 = new ArrayList < > ();
    list1.add (1);
    list1.add (2);
    list1.add (3);
    list1.add (4);
    list1.add (5);
    List < Integer > list2 = new ArrayList < > ();
    list2.add (1);
    list2.add (2);
    list2.add (3);
    boolean isOrderedSublist = true;
    for (int i = 0;
    i < list2.size (); i ++) {
        if (list1.get (i) != (int) list2.get (i)) {
            isOrderedSublist = false;
            break;
        }
    }
    System.out.println ("Is ordered: " + isOrderedSublist);
}
----------------------------------------

public static void main (String [] args) {
    List listSource = new ArrayList ();
    for (int i = 1;
    i <= 5; i ++) {
        listSource.add (i);
    }
    List target = new ArrayList ();
    target.add (2);
    target.add (3);
    boolean isMatched = true;
    int [] indexArray = new int [target.size ()];
    for (int i = 0;
    i < target.size (); i ++) {
        indexArray [i] = listSource.indexOf (target.get (i));
        if (i != 0) {
            if ((indexArray [i] - indexArray [i - 1]) != 1) {
                isMatched = false;
                break;
            }
        }
    }
    System.out.println ("isMatched:" + isMatched);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29866417_29866500_1_13
29866417_29866884_3_12
Title: please Correct For Loop Design 
----------------------------------------

public static void main (String [] args) {
    for (int i = 0;
    i < 10; i ++) {
        for (int j = 10 - i;
        j > 0; j = j --) {
            System.out.print (j * 10);
            System.out.print (" ");
        }
        System.out.println ();
        System.out.println ("-----------------");
    }
}
----------------------------------------

public static void main (String [] args) {
    for (int i = 0;
    i <= 10; i ++) {
        for (int j = 100 - (10 * i);
        j > 10; j = j - 10) {
            System.out.print (j);
            System.out.print (" ");
        }
        System.out.println ("");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29867318_29870425_7_27
29867318_29877144_8_29
Title: PostMethod HttpPost HttpClient - post xml with url parameters 
----------------------------------------

public static void main (String [] argv) {
    try {
        String XMLData = argv [0];
        URL url = new URL ("http://posttestserver.com/post.php");
        HttpURLConnection httpConn = (HttpURLConnection) url.openConnection ();
        httpConn.setRequestMethod ("POST");
        httpConn.setRequestProperty ("Content-Type", "application/xml; charset=utf-8");
        httpConn.setRequestProperty ("Content-Length", Integer.toString (XMLData.length ()));
        httpConn.setDoOutput (true);
        BufferedWriter writer = new BufferedWriter (new OutputStreamWriter ((httpConn.getOutputStream ())));
        writer.write (XMLData, 0, XMLData.length ());
        writer.flush ();
        writer.close ();
        System.out.println (httpConn.getResponseCode ());
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] argv) {
    try {
        String XMLData = argv [0];
        URL url = new URL ("http://posttestserver.com/post.php");
        String myParam = "myparam=" + URLEncoder.encode (XMLData, "UTF-8");
        HttpURLConnection httpConn = (HttpURLConnection) url.openConnection ();
        httpConn.setRequestMethod ("POST");
        httpConn.setRequestProperty ("Content-Type", "application/x-www-form-urlencoded");
        httpConn.setRequestProperty ("Content-Length", Integer.toString (myParam.length ()));
        httpConn.setDoOutput (true);
        BufferedWriter writer = new BufferedWriter (new OutputStreamWriter ((httpConn.getOutputStream ())));
        writer.write (myParam, 0, myParam.length ());
        writer.flush ();
        writer.close ();
        System.out.println (httpConn.getResponseCode ());
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29869094_29869792_1_17
29869094_29870183_1_45
Title: Bubble Sort Manually a Linked List in Java 
----------------------------------------

public void sort () {
    if (size > 1) {
        for (int i = 0;
        i < size; i ++) {
            Node currentNode = head;
            Node next = head.nextNode;
            for (int j = 0;
            j < size - 1; j ++) {
                if (currentNode.data > next.data) {
                    int temp = currentNode.data;
                    currentNode.data = next.data;
                    next.data = temp;
                }
                currentNode = next;
                next = next.nextNode;
            }
        }
    }
}
----------------------------------------

public void sort () {
    if (size > 1) {
        boolean wasChanged;
        do {
            Node current = head;
            Node previous = null;
            Node next = head.nextNode;
            wasChanged = false;
            while (next != null) {
                if (current.data > next.data) {
                    wasChanged = true;
                    if (previous != null) {
                        Node sig = next.nextNode;
                        previous.nextNode = next;
                        next.nextNode = current;
                        current.nextNode = sig;
                    } else {
                        Node sig = next.nextNode;
                        head = next;
                        next.nextNode = current;
                        current.nextNode = sig;
                    }
                    previous = next;
                    next = current.nextNode;
                } else {
                    previous = current;
                    current = next;
                    next = next.nextNode;
                }
            }
        } while (wasChanged);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29872298_29872429_1_26
29872298_29872473_1_19
Title: Extracting even digits from int 
----------------------------------------

public static int evenDigits (int n) {
    int rev = 0;
    int digitCount = 0;
    if (n < 0) return - evenDigits (- n);

    while (n != 0) {
        if (n % 2 == 0) {
            rev = rev * 10 + n % 10;
            digitCount += 1;
        }
        n /= 10;
    }
    while (digitCount > 0) {
        n = n * 10 + rev % 10;
        rev /= 10;
        digitCount -= 1;
    }
    return n;
}
----------------------------------------

public int evenDigits (int n) {
    int r = 0;
    boolean neg = false;
    String evenDigits = "";
    if (n < 0) {
        neg = true;
        n = abs (n);
    }
    while (n > 0) {
        r = n % 10;
        n = n / 10;
        if (r % 2 == 0) {
            evenDigits = Integer.toString (r) + evenDigits;
        }
    }
    int result = Integer.parseInt (evenDigits);
    if (neg) {
        result -= 2 * result;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29872298_29872429_1_26
29872298_29872506_1_11
Title: Extracting even digits from int 
----------------------------------------

public static int evenDigits (int n) {
    int rev = 0;
    int digitCount = 0;
    if (n < 0) return - evenDigits (- n);

    while (n != 0) {
        if (n % 2 == 0) {
            rev = rev * 10 + n % 10;
            digitCount += 1;
        }
        n /= 10;
    }
    while (digitCount > 0) {
        n = n * 10 + rev % 10;
        rev /= 10;
        digitCount -= 1;
    }
    return n;
}
----------------------------------------

public static int evenDigits (int n) {
    if (n < 0) {
        return - evenDigits (- n);
    } else if (n == 0) {
        return 0;
    } else if (n % 2 == 1) {
        return evenDigits (n / 10);
    } else {
        return 10 * evenDigits (n / 10) + (n % 10);
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29872298_29872429_1_26
29872298_29877903_1_15
Title: Extracting even digits from int 
----------------------------------------

public static int evenDigits (int n) {
    int rev = 0;
    int digitCount = 0;
    if (n < 0) return - evenDigits (- n);

    while (n != 0) {
        if (n % 2 == 0) {
            rev = rev * 10 + n % 10;
            digitCount += 1;
        }
        n /= 10;
    }
    while (digitCount > 0) {
        n = n * 10 + rev % 10;
        rev /= 10;
        digitCount -= 1;
    }
    return n;
}
----------------------------------------

public static int evenDigits (int n) {
    StringBuilder evenDigitsBuffer = new StringBuilder ();
    for (char digitChar : String.valueOf (n).toCharArray ()) {
        int digit = Character.getNumericValue (digitChar);
        if (digit % 2 == 0) {
            evenDigitsBuffer.append (digit);
        }
    }
    return evenDigitsBuffer.length () > 0 ? Integer.signum (n) * Integer.parseInt (evenDigitsBuffer.toString ()) : 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29872298_29872473_1_19
29872298_29872506_1_11
Title: Extracting even digits from int 
----------------------------------------

public int evenDigits (int n) {
    int r = 0;
    boolean neg = false;
    String evenDigits = "";
    if (n < 0) {
        neg = true;
        n = abs (n);
    }
    while (n > 0) {
        r = n % 10;
        n = n / 10;
        if (r % 2 == 0) {
            evenDigits = Integer.toString (r) + evenDigits;
        }
    }
    int result = Integer.parseInt (evenDigits);
    if (neg) {
        result -= 2 * result;
    }
    return result;
}
----------------------------------------

public static int evenDigits (int n) {
    if (n < 0) {
        return - evenDigits (- n);
    } else if (n == 0) {
        return 0;
    } else if (n % 2 == 1) {
        return evenDigits (n / 10);
    } else {
        return 10 * evenDigits (n / 10) + (n % 10);
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29872298_29872473_1_19
29872298_29877903_1_15
Title: Extracting even digits from int 
----------------------------------------

public int evenDigits (int n) {
    int r = 0;
    boolean neg = false;
    String evenDigits = "";
    if (n < 0) {
        neg = true;
        n = abs (n);
    }
    while (n > 0) {
        r = n % 10;
        n = n / 10;
        if (r % 2 == 0) {
            evenDigits = Integer.toString (r) + evenDigits;
        }
    }
    int result = Integer.parseInt (evenDigits);
    if (neg) {
        result -= 2 * result;
    }
    return result;
}
----------------------------------------

public static int evenDigits (int n) {
    StringBuilder evenDigitsBuffer = new StringBuilder ();
    for (char digitChar : String.valueOf (n).toCharArray ()) {
        int digit = Character.getNumericValue (digitChar);
        if (digit % 2 == 0) {
            evenDigitsBuffer.append (digit);
        }
    }
    return evenDigitsBuffer.length () > 0 ? Integer.signum (n) * Integer.parseInt (evenDigitsBuffer.toString ()) : 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29872298_29872506_1_11
29872298_29877903_1_15
Title: Extracting even digits from int 
----------------------------------------

public static int evenDigits (int n) {
    if (n < 0) {
        return - evenDigits (- n);
    } else if (n == 0) {
        return 0;
    } else if (n % 2 == 1) {
        return evenDigits (n / 10);
    } else {
        return 10 * evenDigits (n / 10) + (n % 10);
    }

}
----------------------------------------

public static int evenDigits (int n) {
    StringBuilder evenDigitsBuffer = new StringBuilder ();
    for (char digitChar : String.valueOf (n).toCharArray ()) {
        int digit = Character.getNumericValue (digitChar);
        if (digit % 2 == 0) {
            evenDigitsBuffer.append (digit);
        }
    }
    return evenDigitsBuffer.length () > 0 ? Integer.signum (n) * Integer.parseInt (evenDigitsBuffer.toString ()) : 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29873371_29873418_1_30
29873371_29873503_1_22
Title: What is wrong with my method isReverse 
----------------------------------------

private static boolean isReverse (String a, String b) {
    if (a == null || b == null) return false;

    if (a.length () != b.length ()) {
        return false;
    }
    char [] bArray = b.toCharArray ();
    char [] copy = new char [bArray.length];
    for (int i = bArray.length;
    i < 0; i --) {
        copy [bArray.length - i] = bArray [i];
    }
    String check = String.valueOf (copy);
    if (check.equalsIgnoreCase (a)) {
        return true;
    } else {
        return false;
    }
}
----------------------------------------

public static boolean isReverse (String word1, String word2) {
    if (word1 == null || word2 == null) {
        return false;
    }
    if (word1.length () == 1 && word2.length () == 1) {
        return word1.equals (word2);
    } else if (word1.length () == word2.length ()) {
        if (word1.charAt (0) == word2.charAt (word2.length () - 1)) {
            String firstWord = word1.substring (1, word1.length ());
            String secondWord = word2.substring (0, word2.length () - 1);
            System.out.printf ("Trimmed %s, %s to %s, %s\n", word1, word2, firstWord, secondWord);
            return isReverse (firstWord, secondWord);
        } else {
            return false;
        }
    } else {
        return false;
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29875741_29875780_4_16
29875741_29876041_6_15
Title: distinguishing string based on space between them 
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (new File (args [0]));
    while (sc.hasNextLine ()) {
        String line = sc.nextLine ();
        String [] array = line.split (" ");
        switch (array.length) {
            case 1 :
                oneParamMethod (array [0]);
                break;
            case 2 :
                twoParamMethod (array [0], array [1]);
                break;
            default :
                System.out.println ("Strange line");
        }
    }
    sc.close ();
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc;
    try {
        sc = new Scanner (new File (args [0]));
        parseLines (sc);
        sc.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29882210_29882561_1_14
29882210_29898335_1_19
Title: How to know how many particular days of the week in the month are left from current day (including) 
----------------------------------------

public static void getDaysLeftInMonth () {
    LocalDate endOfMonth = LocalDate.now ().with (TemporalAdjusters.lastDayOfMonth ());
    DayOfWeek [] daysOfWeek = DayOfWeek.values ();
    for (int i = 0;
    i < daysOfWeek.length; i ++) {
        int numberOfWeekDaysLeftInMonth = 0;
        LocalDate now = LocalDate.now ();
        while (now.with (TemporalAdjusters.next (daysOfWeek [i])).isBefore (endOfMonth) || now.with (TemporalAdjusters.next (daysOfWeek [i])).isEqual (endOfMonth)) {
            numberOfWeekDaysLeftInMonth ++;
            now = now.plusWeeks (1);
        }
        System.out.printf ("%d %sS left\n", numberOfWeekDaysLeftInMonth, daysOfWeek [i].name ());
    }
}
----------------------------------------

public static void getDaysLeftInMonth () {
    LocalDate today = new LocalDate ("2015-04-22");
    LocalDate endOfMonth = today.dayOfMonth ().withMaximumValue ();
    for (int i = 1;
    i <= 7; i ++) {
        int numberOfWeekDaysLeftInMonth = 0;
        LocalDate now = today;
        LocalDate checkedDay = null;
        while ((checkedDay = now.withDayOfWeek (i)).isBefore (endOfMonth.plusDays (1))) {
            if (checkedDay.isAfter (today.minusDays (1))) {
                numberOfWeekDaysLeftInMonth ++;
            }
            now = now.plusWeeks (1);
        }
        Log.d ("TIME", String.format ("%d - %d left\n", i, numberOfWeekDaysLeftInMonth));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29895197_29895386_1_10
29895197_29895438_1_12
Title: How to return string without excess 
----------------------------------------

public String toString () {
    String ret = "[";
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret += current.get ();
        if (current.getNext () != null) ret += ", ";

    }
    return ret + "]";
}
----------------------------------------

public String toString () {
    StringBuilder ret = new StringBuilder ('[');
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret.append (current.get ()).append (", ");
    }
    if (ret.length () > 1) {
        ret.delete (ret.length () - 2, ret.length ());
    }
    return ret.append (']').toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29895197_29895386_1_10
29895197_29895457_1_13
Title: How to return string without excess 
----------------------------------------

public String toString () {
    String ret = "[";
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret += current.get ();
        if (current.getNext () != null) ret += ", ";

    }
    return ret + "]";
}
----------------------------------------

@Override
public String toString () {
    String ret = "[";
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret += current.get () + ", ";
    }
    ret = ret.substring (0, ret.length () - 1);
    return ret + "]";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29895197_29895386_1_10
29895197_29895460_11_25
Title: How to return string without excess 
----------------------------------------

public String toString () {
    String ret = "[";
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret += current.get ();
        if (current.getNext () != null) ret += ", ";

    }
    return ret + "]";
}
----------------------------------------

public String toString () {
    Iterator < E > it = iterator ();
    if (! it.hasNext ()) return "[]";

    StringBuilder sb = new StringBuilder ();
    sb.append ('[');
    for (;;) {
        E e = it.next ();
        sb.append (e == this ? "(this Collection)" : e);
        if (! it.hasNext ()) return sb.append (']').toString ();

        sb.append (',').append (' ');
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29895197_29895386_1_10
29895197_29895491_1_11
Title: How to return string without excess 
----------------------------------------

public String toString () {
    String ret = "[";
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret += current.get ();
        if (current.getNext () != null) ret += ", ";

    }
    return ret + "]";
}
----------------------------------------

public String toString () {
    String ret = "[";
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret += current.get () + ", ";
    }
    ret = ret.substring (0, ret.length () - 2);
    return ret + "]";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29895197_29895386_1_10
29895197_29895539_1_10
Title: How to return string without excess 
----------------------------------------

public String toString () {
    String ret = "[";
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret += current.get ();
        if (current.getNext () != null) ret += ", ";

    }
    return ret + "]";
}
----------------------------------------

public String toString () {
    List < String > ret = new ArrayList < String > ();
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret.add (current.get ());
    }
    return "[" + StringUtils.join (ret, ",") + "]";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29895197_29895438_1_12
29895197_29895457_1_13
Title: How to return string without excess 
----------------------------------------

public String toString () {
    StringBuilder ret = new StringBuilder ('[');
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret.append (current.get ()).append (", ");
    }
    if (ret.length () > 1) {
        ret.delete (ret.length () - 2, ret.length ());
    }
    return ret.append (']').toString ();
}
----------------------------------------

@Override
public String toString () {
    String ret = "[";
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret += current.get () + ", ";
    }
    ret = ret.substring (0, ret.length () - 1);
    return ret + "]";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29895197_29895438_1_12
29895197_29895460_11_25
Title: How to return string without excess 
----------------------------------------

public String toString () {
    StringBuilder ret = new StringBuilder ('[');
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret.append (current.get ()).append (", ");
    }
    if (ret.length () > 1) {
        ret.delete (ret.length () - 2, ret.length ());
    }
    return ret.append (']').toString ();
}
----------------------------------------

public String toString () {
    Iterator < E > it = iterator ();
    if (! it.hasNext ()) return "[]";

    StringBuilder sb = new StringBuilder ();
    sb.append ('[');
    for (;;) {
        E e = it.next ();
        sb.append (e == this ? "(this Collection)" : e);
        if (! it.hasNext ()) return sb.append (']').toString ();

        sb.append (',').append (' ');
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29895197_29895438_1_12
29895197_29895491_1_11
Title: How to return string without excess 
----------------------------------------

public String toString () {
    StringBuilder ret = new StringBuilder ('[');
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret.append (current.get ()).append (", ");
    }
    if (ret.length () > 1) {
        ret.delete (ret.length () - 2, ret.length ());
    }
    return ret.append (']').toString ();
}
----------------------------------------

public String toString () {
    String ret = "[";
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret += current.get () + ", ";
    }
    ret = ret.substring (0, ret.length () - 2);
    return ret + "]";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29895197_29895438_1_12
29895197_29895539_1_10
Title: How to return string without excess 
----------------------------------------

public String toString () {
    StringBuilder ret = new StringBuilder ('[');
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret.append (current.get ()).append (", ");
    }
    if (ret.length () > 1) {
        ret.delete (ret.length () - 2, ret.length ());
    }
    return ret.append (']').toString ();
}
----------------------------------------

public String toString () {
    List < String > ret = new ArrayList < String > ();
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret.add (current.get ());
    }
    return "[" + StringUtils.join (ret, ",") + "]";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29895197_29895457_1_13
29895197_29895460_11_25
Title: How to return string without excess 
----------------------------------------

@Override
public String toString () {
    String ret = "[";
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret += current.get () + ", ";
    }
    ret = ret.substring (0, ret.length () - 1);
    return ret + "]";
}
----------------------------------------

public String toString () {
    Iterator < E > it = iterator ();
    if (! it.hasNext ()) return "[]";

    StringBuilder sb = new StringBuilder ();
    sb.append ('[');
    for (;;) {
        E e = it.next ();
        sb.append (e == this ? "(this Collection)" : e);
        if (! it.hasNext ()) return sb.append (']').toString ();

        sb.append (',').append (' ');
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29895197_29895457_1_13
29895197_29895491_1_11
Title: How to return string without excess 
----------------------------------------

@Override
public String toString () {
    String ret = "[";
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret += current.get () + ", ";
    }
    ret = ret.substring (0, ret.length () - 1);
    return ret + "]";
}
----------------------------------------

public String toString () {
    String ret = "[";
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret += current.get () + ", ";
    }
    ret = ret.substring (0, ret.length () - 2);
    return ret + "]";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29895197_29895457_1_13
29895197_29895539_1_10
Title: How to return string without excess 
----------------------------------------

@Override
public String toString () {
    String ret = "[";
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret += current.get () + ", ";
    }
    ret = ret.substring (0, ret.length () - 1);
    return ret + "]";
}
----------------------------------------

public String toString () {
    List < String > ret = new ArrayList < String > ();
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret.add (current.get ());
    }
    return "[" + StringUtils.join (ret, ",") + "]";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29895197_29895460_11_25
29895197_29895491_1_11
Title: How to return string without excess 
----------------------------------------

public String toString () {
    Iterator < E > it = iterator ();
    if (! it.hasNext ()) return "[]";

    StringBuilder sb = new StringBuilder ();
    sb.append ('[');
    for (;;) {
        E e = it.next ();
        sb.append (e == this ? "(this Collection)" : e);
        if (! it.hasNext ()) return sb.append (']').toString ();

        sb.append (',').append (' ');
    }
}
----------------------------------------

public String toString () {
    String ret = "[";
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret += current.get () + ", ";
    }
    ret = ret.substring (0, ret.length () - 2);
    return ret + "]";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29895197_29895460_11_25
29895197_29895539_1_10
Title: How to return string without excess 
----------------------------------------

public String toString () {
    Iterator < E > it = iterator ();
    if (! it.hasNext ()) return "[]";

    StringBuilder sb = new StringBuilder ();
    sb.append ('[');
    for (;;) {
        E e = it.next ();
        sb.append (e == this ? "(this Collection)" : e);
        if (! it.hasNext ()) return sb.append (']').toString ();

        sb.append (',').append (' ');
    }
}
----------------------------------------

public String toString () {
    List < String > ret = new ArrayList < String > ();
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret.add (current.get ());
    }
    return "[" + StringUtils.join (ret, ",") + "]";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29895197_29895491_1_11
29895197_29895539_1_10
Title: How to return string without excess 
----------------------------------------

public String toString () {
    String ret = "[";
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret += current.get () + ", ";
    }
    ret = ret.substring (0, ret.length () - 2);
    return ret + "]";
}
----------------------------------------

public String toString () {
    List < String > ret = new ArrayList < String > ();
    Node current = head;
    while (current.getNext () != null) {
        current = current.getNext ();
        ret.add (current.get ());
    }
    return "[" + StringUtils.join (ret, ",") + "]";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29899648_29900976_1_16
29899648_29905742_22_32
Title: Turn a recursive method into an iterative method 
----------------------------------------

public static long iter (long x) {
    long result = 0;
    long [] history = new long [2];
    for (int i = 0;
    i <= x; i ++) {
        if (i < 2) {
            result = 1;
        } else {
            result = history [0] + history [1] + 1;
        }
        history [0] = history [1];
        history [1] = result;
    }
    return result;
}
----------------------------------------

public static void iter (long [] n) {
    for (int i = 0;
    i < n.length; i ++) {
        if (i == 0 || i == 1) {
            n [i] = 1;
        } else {
            n [i] = n [i - 1] + n [i - 2] + 1;
        }
        System.out.println (n [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29910320_29910619_8_26
29910320_29910800_6_62
Title: counting the alphabets from input 
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter a string");
    String str = sc.nextLine ();
    Map < Character, Integer > map = new HashMap < Character, Integer > ();
    char [] chArray = str.toCharArray ();
    for (char c : chArray) {
        if (map.containsKey (c)) {
            map.put (c, map.get (c) + 1);
        } else {
            map.put (c, 1);
        }
    }
    for (Entry < Character, Integer > entry : map.entrySet ()) {
        System.out.print (entry.getKey () + "" + entry.getValue () + " ");
    }
}
----------------------------------------

public static void main (String [] args) {
    System.out.println ("Hello");
    System.out.println ("ENTER ANY STRING");
    Scanner sc = new Scanner (System.in);
    String [] arr = new String [5];
    for (int i = 0;
    i < 5; i ++) {
        arr [i] = sc.next ();
    }
    for (int i = 0;
    i < 5; i ++) {
        System.out.print ("" + arr [i]);
    }
    int count = 1;
    int rep = 0;
    int i = 0;
    for (i = 0; i < 5; i ++) {
        for (int k = i + 1;
        k < 5; k ++) {
            if (arr [i].equals (arr [k])) {
                count ++;
                System.out.println ("got the match" + count);
            }
        }
        System.out.println (arr [i] + count + ",");
        count = 1;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29924478_29929253_25_39
29924478_29929523_28_41
Title: How can I make my Panel wrap text and increase in height instead of width when contained in a GridBagLayout? 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    JTextArea textArea = new JTextArea (enterTextField.getText ());
    textArea.setLineWrap (true);
    textArea.setWrapStyleWord (true);
    JScrollPane scrollPane = new JScrollPane (textArea);
    scrollPane.setBorder (BorderFactory.createLineBorder (Color.RED, 5));
    scrollPane.setPreferredSize (textArea.getPreferredSize ());
    historyPanel.add (scrollPane);
    historyPanel.add (Box.createRigidArea (new Dimension (0, 10)));
    historyPanel.revalidate ();
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    JPanel p = new JPanel (new BorderLayout ());
    p.setBorder (new EmptyBorder (10, 10, 10, 10));
    p.setBackground (Color.GRAY);
    JTextArea text = new JTextArea ();
    text.append ("ABCABCABCABCABCABCABCABC ABCABCABCABCABCABCABCABCABCABCABCABCABCABC ABCABCABCABCABCABCABCABCABCABCABCABCABCA BCABCABCABCABCABCABCAB CABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABCABC");
    text.setLineWrap (true);
    p.add (text);
    gbc.gridy = row ++;
    content.add (p, gbc);
    content.revalidate ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29927313_29930346_34_41
29927313_29957629_49_62
Title: Java Tournament Schedule recursion 
----------------------------------------

void printA (int n) {
    for (int i = 0;
    i < n; ++ i) {
        for (int j = 0;
        j < n; ++ j) {
            System.out.print (A [i] [j] + "\t");
        }
        System.out.println ();
    }
}
----------------------------------------

void printA (int n) {
    if (n >= 0) {
        printA (n - 1);
        if (n == 0) System.out.printf ("%4s", "");

        if (n >= 1) System.out.printf ("%4s", "D" + n);

        for (int c = 0;
        c < max; c ++) System.out.printf ("%3d", (A [n] [c]));

        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29927313_29957629_22_39
29927313_29967553_1_15
Title: Java Tournament Schedule recursion 
----------------------------------------

void schedule (int n) {
    if (n >= 1) {
        schedule (n / 2);
        int col = 0;
        for (int i = 0;
        i < max; i += (2 * n)) {
            for (int j = 0;
            j < n; j ++) A [row] [col + j] = A [row - n] [col + j + n];

            for (int j = n;
            j < n * 2; j ++) A [row] [col + j] = A [row - n] [col + j - n];

            col += 2 * n;
        }
        row ++;
        if (n > 1) schedule (n / 2);

    }
}
----------------------------------------

void schedule (int n) {
    if (n > 0) {
        schedule (n / 2);
        if (n == 1) A [0] [0] = 1;
        else {
            for (int r = 0;
            r < n / 2; r ++) for (int c = 0;
            c < n / 2; c ++) {
                A [r] [c + (n / 2)] = A [r] [c] + (n / 2);
                A [r + (n / 2)] [c] = A [r] [c] + (n / 2);
                A [r + (n / 2)] [c + (n / 2)] = A [r] [c];
            }

        }
    }
}
----------------------------------------
