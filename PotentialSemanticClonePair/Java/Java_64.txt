$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28939068_28939213_1_15
28939068_28940082_1_42
Title: How to print specified pattern in Java 
----------------------------------------

public static void main (String [] args) throws java.lang.Exception {
    System.out.println ("The Pattern is");
    for (int i = 0;
    i < 4; i ++) {
        for (int j = 0;
        j <= 4 - i; j ++) System.out.print (" ");

        for (int k = 0;
        k <= i - 2; k ++) System.out.print ("V ");

        System.out.println ();
    }
}
----------------------------------------

public static void main (String [] args) {
    System.out.println ("The Pattern is");
    final int rowSize = 4;
    final int startPos = 2;
    int leftPos = startPos;
    int rightPos = startPos;
    for (int row = 0;
    row < rowSize; row ++) {
        for (int col = 0;
        col < rightPos + 1; col ++) {
            if (col == leftPos) {
                System.out.print ("v");
                if (leftPos == rightPos) {
                    break;
                }
            }
            if (col == rightPos) {
                System.out.print ("v");
                break;
            }
            System.out.print (" ");
        }
        System.out.println ();
        if (leftPos != 0) leftPos --;

        rightPos ++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28939068_28939213_1_15
28939068_39385624_2_16
Title: How to print specified pattern in Java 
----------------------------------------

public static void main (String [] args) throws java.lang.Exception {
    System.out.println ("The Pattern is");
    for (int i = 0;
    i < 4; i ++) {
        for (int j = 0;
        j <= 4 - i; j ++) System.out.print (" ");

        for (int k = 0;
        k <= i - 2; k ++) System.out.print ("V ");

        System.out.println ();
    }
}
----------------------------------------

public static void main (String [] args) {
    int i, j;
    int num = 7;
    for (i = 0; i < num; i ++) {
        for (j = 0; j < num; j ++) {
            if (isConditionMatch (num, i, j)) {
                System.out.print ("V");
            } else {
                System.out.print (" ");
            }
        }
        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28939068_28939402_1_15
28939068_28940082_1_42
Title: How to print specified pattern in Java 
----------------------------------------

public static void main (String [] args) {
    final int numRows = 4;
    for (int row = 0;
    row < numRows; row ++) {
        for (int preSpace = numRows - row;
        preSpace >= 0; preSpace --) {
            System.out.print (" ");
        }
        if (row > 0) {
            System.out.print ("v");
            for (int postSpace = 1;
            postSpace < row * 2; postSpace ++) {
                System.out.print (" ");
            }
        }
        System.out.println ("v");
    }
}
----------------------------------------

public static void main (String [] args) {
    System.out.println ("The Pattern is");
    final int rowSize = 4;
    final int startPos = 2;
    int leftPos = startPos;
    int rightPos = startPos;
    for (int row = 0;
    row < rowSize; row ++) {
        for (int col = 0;
        col < rightPos + 1; col ++) {
            if (col == leftPos) {
                System.out.print ("v");
                if (leftPos == rightPos) {
                    break;
                }
            }
            if (col == rightPos) {
                System.out.print ("v");
                break;
            }
            System.out.print (" ");
        }
        System.out.println ();
        if (leftPos != 0) leftPos --;

        rightPos ++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28939068_28939402_1_15
28939068_39385624_2_16
Title: How to print specified pattern in Java 
----------------------------------------

public static void main (String [] args) {
    final int numRows = 4;
    for (int row = 0;
    row < numRows; row ++) {
        for (int preSpace = numRows - row;
        preSpace >= 0; preSpace --) {
            System.out.print (" ");
        }
        if (row > 0) {
            System.out.print ("v");
            for (int postSpace = 1;
            postSpace < row * 2; postSpace ++) {
                System.out.print (" ");
            }
        }
        System.out.println ("v");
    }
}
----------------------------------------

public static void main (String [] args) {
    int i, j;
    int num = 7;
    for (i = 0; i < num; i ++) {
        for (j = 0; j < num; j ++) {
            if (isConditionMatch (num, i, j)) {
                System.out.print ("V");
            } else {
                System.out.print (" ");
            }
        }
        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28939068_28940082_1_42
28939068_39385624_2_16
Title: How to print specified pattern in Java 
----------------------------------------

public static void main (String [] args) {
    System.out.println ("The Pattern is");
    final int rowSize = 4;
    final int startPos = 2;
    int leftPos = startPos;
    int rightPos = startPos;
    for (int row = 0;
    row < rowSize; row ++) {
        for (int col = 0;
        col < rightPos + 1; col ++) {
            if (col == leftPos) {
                System.out.print ("v");
                if (leftPos == rightPos) {
                    break;
                }
            }
            if (col == rightPos) {
                System.out.print ("v");
                break;
            }
            System.out.print (" ");
        }
        System.out.println ();
        if (leftPos != 0) leftPos --;

        rightPos ++;
    }
}
----------------------------------------

public static void main (String [] args) {
    int i, j;
    int num = 7;
    for (i = 0; i < num; i ++) {
        for (j = 0; j < num; j ++) {
            if (isConditionMatch (num, i, j)) {
                System.out.print ("V");
            } else {
                System.out.print (" ");
            }
        }
        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28942406_28942560_5_17
28942406_28942674_3_18
Title: how to print 20 random number between 5 and 25 in java? 
----------------------------------------

public static void main (String [] args) {
    Random random = new Random ();
    Scanner in = new Scanner (System.in);
    System.out.println ("Enter the number");
    int inputNumber = in.nextInt ();
    for (int i = 0;
    i < inputNumber; i ++) {
        int generatedNumber = random.nextInt (inputNumber) + 5;
        System.out.println ("Generating number " + i + ": " + generatedNumber);
    }
}
----------------------------------------

public static final void main (String...aArgs) {
    int max = 10;
    int min = 5;
    int userInput = 6;
    int diff = max - min;
    Random randomGenerator = new Random ();
    for (int idx = 1;
    idx <= userInput; ++ idx) {
        Random rn = new Random ();
        int i = rn.nextInt (diff + 1);
        i += min;
        System.out.print ("The Random Number is " + i);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_28954414_8_56
28951336_31992531_9_34
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public int solution (String s) {
    if (s.length () % 2 != 0) {
        return 0;
    }
    Character openingBrace = new Character ('{');
    Character openingBracket = new Character ('[');
    Character openingParen = new Character ('(');
    Stack < Character > openingStack = new Stack < Character > ();
    for (int i = 0;
    i < s.length (); i ++) {
        char c = s.charAt (i);
        if (c == openingBrace || c == openingBracket || c == openingParen) {
            openingStack.push (c);
        } else {
            if (openingStack.isEmpty ()) {
                return 0;
            }
            Character openingCharacter = openingStack.pop ();
            switch (c) {
                case '}' :
                    if (! openingCharacter.equals (openingBrace)) {
                        return 0;
                    }
                    break;
                case ']' :
                    if (! openingCharacter.equals (openingBracket)) {
                        return 0;
                    }
                    break;
                case ')' :
                    if (! openingCharacter.equals (openingParen)) {
                        return 0;
                    }
                    break;
                default :
                    break;
            }
        }
    }
    if (! openingStack.isEmpty ()) {
        return 0;
    }
    return 1;
}
----------------------------------------

public int solution (String S) {
    if (S.isEmpty ()) return BALANCED;

    Stack < Character > stack = new Stack < > (S.length ());
    NestedValidatorUtil util = new NestedValidatorUtil ();
    for (char c : S.toCharArray ()) {
        if (stack.isEmpty ()) {
            if (util.isOpener (c)) {
                stack.push (c);
            } else {
                return UNBALANCED;
            }
        } else {
            if (util.isOpener (c)) {
                stack.push (c);
            } else if (util.getOpenerForGivenCloser (c) == stack.peek ()) {
                stack.pop ();
            } else {
                return UNBALANCED;
            }

        }
    }
    return stack.isEmpty () ? BALANCED : UNBALANCED;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_28954414_8_56
28951336_33754847_1_28
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public int solution (String s) {
    if (s.length () % 2 != 0) {
        return 0;
    }
    Character openingBrace = new Character ('{');
    Character openingBracket = new Character ('[');
    Character openingParen = new Character ('(');
    Stack < Character > openingStack = new Stack < Character > ();
    for (int i = 0;
    i < s.length (); i ++) {
        char c = s.charAt (i);
        if (c == openingBrace || c == openingBracket || c == openingParen) {
            openingStack.push (c);
        } else {
            if (openingStack.isEmpty ()) {
                return 0;
            }
            Character openingCharacter = openingStack.pop ();
            switch (c) {
                case '}' :
                    if (! openingCharacter.equals (openingBrace)) {
                        return 0;
                    }
                    break;
                case ']' :
                    if (! openingCharacter.equals (openingBracket)) {
                        return 0;
                    }
                    break;
                case ')' :
                    if (! openingCharacter.equals (openingParen)) {
                        return 0;
                    }
                    break;
                default :
                    break;
            }
        }
    }
    if (! openingStack.isEmpty ()) {
        return 0;
    }
    return 1;
}
----------------------------------------

public static int solution (String S) {
    Stack < Character > stack = new Stack < Character > ();
    if (null == S) {
        return 0;
    } else if (S.isEmpty ()) {
        return 1;
    }

    for (Character C : S.toCharArray ()) {
        switch (C) {
            case ')' :
                pops (stack, '(');
                break;
            case '}' :
                pops (stack, '{');
                break;
            case ']' :
                pops (stack, '[');
                break;
            default :
                stack.push (C);
                break;
        }
    }
    return stack.isEmpty () ? 1 : 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_28954414_8_56
28951336_35513755_31_64
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public int solution (String s) {
    if (s.length () % 2 != 0) {
        return 0;
    }
    Character openingBrace = new Character ('{');
    Character openingBracket = new Character ('[');
    Character openingParen = new Character ('(');
    Stack < Character > openingStack = new Stack < Character > ();
    for (int i = 0;
    i < s.length (); i ++) {
        char c = s.charAt (i);
        if (c == openingBrace || c == openingBracket || c == openingParen) {
            openingStack.push (c);
        } else {
            if (openingStack.isEmpty ()) {
                return 0;
            }
            Character openingCharacter = openingStack.pop ();
            switch (c) {
                case '}' :
                    if (! openingCharacter.equals (openingBrace)) {
                        return 0;
                    }
                    break;
                case ']' :
                    if (! openingCharacter.equals (openingBracket)) {
                        return 0;
                    }
                    break;
                case ')' :
                    if (! openingCharacter.equals (openingParen)) {
                        return 0;
                    }
                    break;
                default :
                    break;
            }
        }
    }
    if (! openingStack.isEmpty ()) {
        return 0;
    }
    return 1;
}
----------------------------------------

public static int solution (String S) {
    if (S.isEmpty ()) return 1;

    if (S.length () == 1) return 0;

    Stack < Character > stack = new Stack < > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char current = S.charAt (i);
        switch (current) {
            case '}' :
                if (! stack.isEmpty () && stack.peek () == '{') {
                    stack.pop ();
                } else return 0;

                break;
            case ']' :
                if (! stack.isEmpty () && stack.peek () == '[') {
                    stack.pop ();
                } else return 0;

                break;
            case ')' :
                if (! stack.isEmpty () && stack.peek () == '(') {
                    stack.pop ();
                } else return 0;

                break;
            default :
                stack.push (current);
                break;
        }
    }
    return stack.size () == 0 ? 1 : 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_28954414_8_56
28951336_40672395_1_21
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public int solution (String s) {
    if (s.length () % 2 != 0) {
        return 0;
    }
    Character openingBrace = new Character ('{');
    Character openingBracket = new Character ('[');
    Character openingParen = new Character ('(');
    Stack < Character > openingStack = new Stack < Character > ();
    for (int i = 0;
    i < s.length (); i ++) {
        char c = s.charAt (i);
        if (c == openingBrace || c == openingBracket || c == openingParen) {
            openingStack.push (c);
        } else {
            if (openingStack.isEmpty ()) {
                return 0;
            }
            Character openingCharacter = openingStack.pop ();
            switch (c) {
                case '}' :
                    if (! openingCharacter.equals (openingBrace)) {
                        return 0;
                    }
                    break;
                case ']' :
                    if (! openingCharacter.equals (openingBracket)) {
                        return 0;
                    }
                    break;
                case ')' :
                    if (! openingCharacter.equals (openingParen)) {
                        return 0;
                    }
                    break;
                default :
                    break;
            }
        }
    }
    if (! openingStack.isEmpty ()) {
        return 0;
    }
    return 1;
}
----------------------------------------

public int solution (String S) {
    Stack < Character > stack = new Stack < > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char c = S.charAt (i);
        if (c == '[' || c == '{' || c == '(' || c == 'V') {
            stack.push (c);
        } else if (c == ']' || c == '}' || c == ')' || c == 'W') {
            if (checkBracket (stack, c)) {
                stack.pop ();
            } else {
                return 0;
            }
        } else {
            return 0;
        }

    }
    if (stack.empty ()) {
        return 1;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_28954414_8_56
28951336_50420886_1_27
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public int solution (String s) {
    if (s.length () % 2 != 0) {
        return 0;
    }
    Character openingBrace = new Character ('{');
    Character openingBracket = new Character ('[');
    Character openingParen = new Character ('(');
    Stack < Character > openingStack = new Stack < Character > ();
    for (int i = 0;
    i < s.length (); i ++) {
        char c = s.charAt (i);
        if (c == openingBrace || c == openingBracket || c == openingParen) {
            openingStack.push (c);
        } else {
            if (openingStack.isEmpty ()) {
                return 0;
            }
            Character openingCharacter = openingStack.pop ();
            switch (c) {
                case '}' :
                    if (! openingCharacter.equals (openingBrace)) {
                        return 0;
                    }
                    break;
                case ']' :
                    if (! openingCharacter.equals (openingBracket)) {
                        return 0;
                    }
                    break;
                case ')' :
                    if (! openingCharacter.equals (openingParen)) {
                        return 0;
                    }
                    break;
                default :
                    break;
            }
        }
    }
    if (! openingStack.isEmpty ()) {
        return 0;
    }
    return 1;
}
----------------------------------------

public int solution (String S) {
    Deque < Character > stack = new ArrayDeque < Character > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char c = S.charAt (i);
        switch (c) {
            case ')' :
                if (stack.isEmpty () || stack.pop () != '(') return 0;

                break;
            case ']' :
                if (stack.isEmpty () || stack.pop () != '[') return 0;

                break;
            case '}' :
                if (stack.isEmpty () || stack.pop () != '{') return 0;

                break;
            default :
                stack.push (c);
                break;
        }
    }
    return stack.isEmpty () ? 1 : 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_28954414_8_56
28951336_51573594_1_22
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public int solution (String s) {
    if (s.length () % 2 != 0) {
        return 0;
    }
    Character openingBrace = new Character ('{');
    Character openingBracket = new Character ('[');
    Character openingParen = new Character ('(');
    Stack < Character > openingStack = new Stack < Character > ();
    for (int i = 0;
    i < s.length (); i ++) {
        char c = s.charAt (i);
        if (c == openingBrace || c == openingBracket || c == openingParen) {
            openingStack.push (c);
        } else {
            if (openingStack.isEmpty ()) {
                return 0;
            }
            Character openingCharacter = openingStack.pop ();
            switch (c) {
                case '}' :
                    if (! openingCharacter.equals (openingBrace)) {
                        return 0;
                    }
                    break;
                case ']' :
                    if (! openingCharacter.equals (openingBracket)) {
                        return 0;
                    }
                    break;
                case ')' :
                    if (! openingCharacter.equals (openingParen)) {
                        return 0;
                    }
                    break;
                default :
                    break;
            }
        }
    }
    if (! openingStack.isEmpty ()) {
        return 0;
    }
    return 1;
}
----------------------------------------

int solution (string S) {
    int N = S.size ();
    if (N == 0) return 1;

    if (S [0] == ')' || S [0] == ']' || S [0] == '}') return 0;

    if (S [N - 1] == '(' || S [N - 1] == '[' || S [N - 1] == '{') return 0;

    int paren_open = 0;
    int brac_open = 0;
    int curl_open = 0;
    for (int i = 0;
    i < N; ++ i) {
        if (S [i] == ')' && (paren_open == 0 || S [i - 1] == '[' || S [i - 1] == '{')) return 0;

        if (S [i] == ']' && (brac_open == 0 || S [i - 1] == '(' || S [i - 1] == '{')) return 0;

        if (S [i] == '}' && (curl_open == 0 || S [i - 1] == '[' || S [i - 1] == '(')) return 0;

        if (S [i] == '(') paren_open ++;
        else if (S [i] == ')') paren_open --;
        else if (S [i] == '[') brac_open ++;
        else if (S [i] == ']') brac_open --;
        else if (S [i] == '{') curl_open ++;
        else if (S [i] == '}') curl_open --;

    }
    if (paren_open == 0 && brac_open == 0 && curl_open == 0) return 1;

    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_31992531_9_34
28951336_33754847_1_28
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public int solution (String S) {
    if (S.isEmpty ()) return BALANCED;

    Stack < Character > stack = new Stack < > (S.length ());
    NestedValidatorUtil util = new NestedValidatorUtil ();
    for (char c : S.toCharArray ()) {
        if (stack.isEmpty ()) {
            if (util.isOpener (c)) {
                stack.push (c);
            } else {
                return UNBALANCED;
            }
        } else {
            if (util.isOpener (c)) {
                stack.push (c);
            } else if (util.getOpenerForGivenCloser (c) == stack.peek ()) {
                stack.pop ();
            } else {
                return UNBALANCED;
            }

        }
    }
    return stack.isEmpty () ? BALANCED : UNBALANCED;
}
----------------------------------------

public static int solution (String S) {
    Stack < Character > stack = new Stack < Character > ();
    if (null == S) {
        return 0;
    } else if (S.isEmpty ()) {
        return 1;
    }

    for (Character C : S.toCharArray ()) {
        switch (C) {
            case ')' :
                pops (stack, '(');
                break;
            case '}' :
                pops (stack, '{');
                break;
            case ']' :
                pops (stack, '[');
                break;
            default :
                stack.push (C);
                break;
        }
    }
    return stack.isEmpty () ? 1 : 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_31992531_9_34
28951336_35513755_31_64
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public int solution (String S) {
    if (S.isEmpty ()) return BALANCED;

    Stack < Character > stack = new Stack < > (S.length ());
    NestedValidatorUtil util = new NestedValidatorUtil ();
    for (char c : S.toCharArray ()) {
        if (stack.isEmpty ()) {
            if (util.isOpener (c)) {
                stack.push (c);
            } else {
                return UNBALANCED;
            }
        } else {
            if (util.isOpener (c)) {
                stack.push (c);
            } else if (util.getOpenerForGivenCloser (c) == stack.peek ()) {
                stack.pop ();
            } else {
                return UNBALANCED;
            }

        }
    }
    return stack.isEmpty () ? BALANCED : UNBALANCED;
}
----------------------------------------

public static int solution (String S) {
    if (S.isEmpty ()) return 1;

    if (S.length () == 1) return 0;

    Stack < Character > stack = new Stack < > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char current = S.charAt (i);
        switch (current) {
            case '}' :
                if (! stack.isEmpty () && stack.peek () == '{') {
                    stack.pop ();
                } else return 0;

                break;
            case ']' :
                if (! stack.isEmpty () && stack.peek () == '[') {
                    stack.pop ();
                } else return 0;

                break;
            case ')' :
                if (! stack.isEmpty () && stack.peek () == '(') {
                    stack.pop ();
                } else return 0;

                break;
            default :
                stack.push (current);
                break;
        }
    }
    return stack.size () == 0 ? 1 : 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_31992531_9_34
28951336_40672395_1_21
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public int solution (String S) {
    if (S.isEmpty ()) return BALANCED;

    Stack < Character > stack = new Stack < > (S.length ());
    NestedValidatorUtil util = new NestedValidatorUtil ();
    for (char c : S.toCharArray ()) {
        if (stack.isEmpty ()) {
            if (util.isOpener (c)) {
                stack.push (c);
            } else {
                return UNBALANCED;
            }
        } else {
            if (util.isOpener (c)) {
                stack.push (c);
            } else if (util.getOpenerForGivenCloser (c) == stack.peek ()) {
                stack.pop ();
            } else {
                return UNBALANCED;
            }

        }
    }
    return stack.isEmpty () ? BALANCED : UNBALANCED;
}
----------------------------------------

public int solution (String S) {
    Stack < Character > stack = new Stack < > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char c = S.charAt (i);
        if (c == '[' || c == '{' || c == '(' || c == 'V') {
            stack.push (c);
        } else if (c == ']' || c == '}' || c == ')' || c == 'W') {
            if (checkBracket (stack, c)) {
                stack.pop ();
            } else {
                return 0;
            }
        } else {
            return 0;
        }

    }
    if (stack.empty ()) {
        return 1;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_31992531_9_34
28951336_50420886_1_27
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public int solution (String S) {
    if (S.isEmpty ()) return BALANCED;

    Stack < Character > stack = new Stack < > (S.length ());
    NestedValidatorUtil util = new NestedValidatorUtil ();
    for (char c : S.toCharArray ()) {
        if (stack.isEmpty ()) {
            if (util.isOpener (c)) {
                stack.push (c);
            } else {
                return UNBALANCED;
            }
        } else {
            if (util.isOpener (c)) {
                stack.push (c);
            } else if (util.getOpenerForGivenCloser (c) == stack.peek ()) {
                stack.pop ();
            } else {
                return UNBALANCED;
            }

        }
    }
    return stack.isEmpty () ? BALANCED : UNBALANCED;
}
----------------------------------------

public int solution (String S) {
    Deque < Character > stack = new ArrayDeque < Character > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char c = S.charAt (i);
        switch (c) {
            case ')' :
                if (stack.isEmpty () || stack.pop () != '(') return 0;

                break;
            case ']' :
                if (stack.isEmpty () || stack.pop () != '[') return 0;

                break;
            case '}' :
                if (stack.isEmpty () || stack.pop () != '{') return 0;

                break;
            default :
                stack.push (c);
                break;
        }
    }
    return stack.isEmpty () ? 1 : 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_31992531_9_34
28951336_51573594_1_22
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public int solution (String S) {
    if (S.isEmpty ()) return BALANCED;

    Stack < Character > stack = new Stack < > (S.length ());
    NestedValidatorUtil util = new NestedValidatorUtil ();
    for (char c : S.toCharArray ()) {
        if (stack.isEmpty ()) {
            if (util.isOpener (c)) {
                stack.push (c);
            } else {
                return UNBALANCED;
            }
        } else {
            if (util.isOpener (c)) {
                stack.push (c);
            } else if (util.getOpenerForGivenCloser (c) == stack.peek ()) {
                stack.pop ();
            } else {
                return UNBALANCED;
            }

        }
    }
    return stack.isEmpty () ? BALANCED : UNBALANCED;
}
----------------------------------------

int solution (string S) {
    int N = S.size ();
    if (N == 0) return 1;

    if (S [0] == ')' || S [0] == ']' || S [0] == '}') return 0;

    if (S [N - 1] == '(' || S [N - 1] == '[' || S [N - 1] == '{') return 0;

    int paren_open = 0;
    int brac_open = 0;
    int curl_open = 0;
    for (int i = 0;
    i < N; ++ i) {
        if (S [i] == ')' && (paren_open == 0 || S [i - 1] == '[' || S [i - 1] == '{')) return 0;

        if (S [i] == ']' && (brac_open == 0 || S [i - 1] == '(' || S [i - 1] == '{')) return 0;

        if (S [i] == '}' && (curl_open == 0 || S [i - 1] == '[' || S [i - 1] == '(')) return 0;

        if (S [i] == '(') paren_open ++;
        else if (S [i] == ')') paren_open --;
        else if (S [i] == '[') brac_open ++;
        else if (S [i] == ']') brac_open --;
        else if (S [i] == '{') curl_open ++;
        else if (S [i] == '}') curl_open --;

    }
    if (paren_open == 0 && brac_open == 0 && curl_open == 0) return 1;

    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_33754847_1_28
28951336_35513755_31_64
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public static int solution (String S) {
    Stack < Character > stack = new Stack < Character > ();
    if (null == S) {
        return 0;
    } else if (S.isEmpty ()) {
        return 1;
    }

    for (Character C : S.toCharArray ()) {
        switch (C) {
            case ')' :
                pops (stack, '(');
                break;
            case '}' :
                pops (stack, '{');
                break;
            case ']' :
                pops (stack, '[');
                break;
            default :
                stack.push (C);
                break;
        }
    }
    return stack.isEmpty () ? 1 : 0;
}
----------------------------------------

public static int solution (String S) {
    if (S.isEmpty ()) return 1;

    if (S.length () == 1) return 0;

    Stack < Character > stack = new Stack < > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char current = S.charAt (i);
        switch (current) {
            case '}' :
                if (! stack.isEmpty () && stack.peek () == '{') {
                    stack.pop ();
                } else return 0;

                break;
            case ']' :
                if (! stack.isEmpty () && stack.peek () == '[') {
                    stack.pop ();
                } else return 0;

                break;
            case ')' :
                if (! stack.isEmpty () && stack.peek () == '(') {
                    stack.pop ();
                } else return 0;

                break;
            default :
                stack.push (current);
                break;
        }
    }
    return stack.size () == 0 ? 1 : 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_33754847_1_28
28951336_40672395_1_21
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public static int solution (String S) {
    Stack < Character > stack = new Stack < Character > ();
    if (null == S) {
        return 0;
    } else if (S.isEmpty ()) {
        return 1;
    }

    for (Character C : S.toCharArray ()) {
        switch (C) {
            case ')' :
                pops (stack, '(');
                break;
            case '}' :
                pops (stack, '{');
                break;
            case ']' :
                pops (stack, '[');
                break;
            default :
                stack.push (C);
                break;
        }
    }
    return stack.isEmpty () ? 1 : 0;
}
----------------------------------------

public int solution (String S) {
    Stack < Character > stack = new Stack < > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char c = S.charAt (i);
        if (c == '[' || c == '{' || c == '(' || c == 'V') {
            stack.push (c);
        } else if (c == ']' || c == '}' || c == ')' || c == 'W') {
            if (checkBracket (stack, c)) {
                stack.pop ();
            } else {
                return 0;
            }
        } else {
            return 0;
        }

    }
    if (stack.empty ()) {
        return 1;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_33754847_1_28
28951336_50420886_1_27
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public static int solution (String S) {
    Stack < Character > stack = new Stack < Character > ();
    if (null == S) {
        return 0;
    } else if (S.isEmpty ()) {
        return 1;
    }

    for (Character C : S.toCharArray ()) {
        switch (C) {
            case ')' :
                pops (stack, '(');
                break;
            case '}' :
                pops (stack, '{');
                break;
            case ']' :
                pops (stack, '[');
                break;
            default :
                stack.push (C);
                break;
        }
    }
    return stack.isEmpty () ? 1 : 0;
}
----------------------------------------

public int solution (String S) {
    Deque < Character > stack = new ArrayDeque < Character > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char c = S.charAt (i);
        switch (c) {
            case ')' :
                if (stack.isEmpty () || stack.pop () != '(') return 0;

                break;
            case ']' :
                if (stack.isEmpty () || stack.pop () != '[') return 0;

                break;
            case '}' :
                if (stack.isEmpty () || stack.pop () != '{') return 0;

                break;
            default :
                stack.push (c);
                break;
        }
    }
    return stack.isEmpty () ? 1 : 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_33754847_1_28
28951336_51573594_1_22
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public static int solution (String S) {
    Stack < Character > stack = new Stack < Character > ();
    if (null == S) {
        return 0;
    } else if (S.isEmpty ()) {
        return 1;
    }

    for (Character C : S.toCharArray ()) {
        switch (C) {
            case ')' :
                pops (stack, '(');
                break;
            case '}' :
                pops (stack, '{');
                break;
            case ']' :
                pops (stack, '[');
                break;
            default :
                stack.push (C);
                break;
        }
    }
    return stack.isEmpty () ? 1 : 0;
}
----------------------------------------

int solution (string S) {
    int N = S.size ();
    if (N == 0) return 1;

    if (S [0] == ')' || S [0] == ']' || S [0] == '}') return 0;

    if (S [N - 1] == '(' || S [N - 1] == '[' || S [N - 1] == '{') return 0;

    int paren_open = 0;
    int brac_open = 0;
    int curl_open = 0;
    for (int i = 0;
    i < N; ++ i) {
        if (S [i] == ')' && (paren_open == 0 || S [i - 1] == '[' || S [i - 1] == '{')) return 0;

        if (S [i] == ']' && (brac_open == 0 || S [i - 1] == '(' || S [i - 1] == '{')) return 0;

        if (S [i] == '}' && (curl_open == 0 || S [i - 1] == '[' || S [i - 1] == '(')) return 0;

        if (S [i] == '(') paren_open ++;
        else if (S [i] == ')') paren_open --;
        else if (S [i] == '[') brac_open ++;
        else if (S [i] == ']') brac_open --;
        else if (S [i] == '{') curl_open ++;
        else if (S [i] == '}') curl_open --;

    }
    if (paren_open == 0 && brac_open == 0 && curl_open == 0) return 1;

    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_35513755_31_64
28951336_40672395_1_21
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public static int solution (String S) {
    if (S.isEmpty ()) return 1;

    if (S.length () == 1) return 0;

    Stack < Character > stack = new Stack < > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char current = S.charAt (i);
        switch (current) {
            case '}' :
                if (! stack.isEmpty () && stack.peek () == '{') {
                    stack.pop ();
                } else return 0;

                break;
            case ']' :
                if (! stack.isEmpty () && stack.peek () == '[') {
                    stack.pop ();
                } else return 0;

                break;
            case ')' :
                if (! stack.isEmpty () && stack.peek () == '(') {
                    stack.pop ();
                } else return 0;

                break;
            default :
                stack.push (current);
                break;
        }
    }
    return stack.size () == 0 ? 1 : 0;
}
----------------------------------------

public int solution (String S) {
    Stack < Character > stack = new Stack < > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char c = S.charAt (i);
        if (c == '[' || c == '{' || c == '(' || c == 'V') {
            stack.push (c);
        } else if (c == ']' || c == '}' || c == ')' || c == 'W') {
            if (checkBracket (stack, c)) {
                stack.pop ();
            } else {
                return 0;
            }
        } else {
            return 0;
        }

    }
    if (stack.empty ()) {
        return 1;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_35513755_31_64
28951336_50420886_1_27
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public static int solution (String S) {
    if (S.isEmpty ()) return 1;

    if (S.length () == 1) return 0;

    Stack < Character > stack = new Stack < > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char current = S.charAt (i);
        switch (current) {
            case '}' :
                if (! stack.isEmpty () && stack.peek () == '{') {
                    stack.pop ();
                } else return 0;

                break;
            case ']' :
                if (! stack.isEmpty () && stack.peek () == '[') {
                    stack.pop ();
                } else return 0;

                break;
            case ')' :
                if (! stack.isEmpty () && stack.peek () == '(') {
                    stack.pop ();
                } else return 0;

                break;
            default :
                stack.push (current);
                break;
        }
    }
    return stack.size () == 0 ? 1 : 0;
}
----------------------------------------

public int solution (String S) {
    Deque < Character > stack = new ArrayDeque < Character > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char c = S.charAt (i);
        switch (c) {
            case ')' :
                if (stack.isEmpty () || stack.pop () != '(') return 0;

                break;
            case ']' :
                if (stack.isEmpty () || stack.pop () != '[') return 0;

                break;
            case '}' :
                if (stack.isEmpty () || stack.pop () != '{') return 0;

                break;
            default :
                stack.push (c);
                break;
        }
    }
    return stack.isEmpty () ? 1 : 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_35513755_31_64
28951336_51573594_1_22
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public static int solution (String S) {
    if (S.isEmpty ()) return 1;

    if (S.length () == 1) return 0;

    Stack < Character > stack = new Stack < > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char current = S.charAt (i);
        switch (current) {
            case '}' :
                if (! stack.isEmpty () && stack.peek () == '{') {
                    stack.pop ();
                } else return 0;

                break;
            case ']' :
                if (! stack.isEmpty () && stack.peek () == '[') {
                    stack.pop ();
                } else return 0;

                break;
            case ')' :
                if (! stack.isEmpty () && stack.peek () == '(') {
                    stack.pop ();
                } else return 0;

                break;
            default :
                stack.push (current);
                break;
        }
    }
    return stack.size () == 0 ? 1 : 0;
}
----------------------------------------

int solution (string S) {
    int N = S.size ();
    if (N == 0) return 1;

    if (S [0] == ')' || S [0] == ']' || S [0] == '}') return 0;

    if (S [N - 1] == '(' || S [N - 1] == '[' || S [N - 1] == '{') return 0;

    int paren_open = 0;
    int brac_open = 0;
    int curl_open = 0;
    for (int i = 0;
    i < N; ++ i) {
        if (S [i] == ')' && (paren_open == 0 || S [i - 1] == '[' || S [i - 1] == '{')) return 0;

        if (S [i] == ']' && (brac_open == 0 || S [i - 1] == '(' || S [i - 1] == '{')) return 0;

        if (S [i] == '}' && (curl_open == 0 || S [i - 1] == '[' || S [i - 1] == '(')) return 0;

        if (S [i] == '(') paren_open ++;
        else if (S [i] == ')') paren_open --;
        else if (S [i] == '[') brac_open ++;
        else if (S [i] == ']') brac_open --;
        else if (S [i] == '{') curl_open ++;
        else if (S [i] == '}') curl_open --;

    }
    if (paren_open == 0 && brac_open == 0 && curl_open == 0) return 1;

    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_40672395_1_21
28951336_50420886_1_27
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public int solution (String S) {
    Stack < Character > stack = new Stack < > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char c = S.charAt (i);
        if (c == '[' || c == '{' || c == '(' || c == 'V') {
            stack.push (c);
        } else if (c == ']' || c == '}' || c == ')' || c == 'W') {
            if (checkBracket (stack, c)) {
                stack.pop ();
            } else {
                return 0;
            }
        } else {
            return 0;
        }

    }
    if (stack.empty ()) {
        return 1;
    }
    return 0;
}
----------------------------------------

public int solution (String S) {
    Deque < Character > stack = new ArrayDeque < Character > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char c = S.charAt (i);
        switch (c) {
            case ')' :
                if (stack.isEmpty () || stack.pop () != '(') return 0;

                break;
            case ']' :
                if (stack.isEmpty () || stack.pop () != '[') return 0;

                break;
            case '}' :
                if (stack.isEmpty () || stack.pop () != '{') return 0;

                break;
            default :
                stack.push (c);
                break;
        }
    }
    return stack.isEmpty () ? 1 : 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_40672395_1_21
28951336_51573594_1_22
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public int solution (String S) {
    Stack < Character > stack = new Stack < > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char c = S.charAt (i);
        if (c == '[' || c == '{' || c == '(' || c == 'V') {
            stack.push (c);
        } else if (c == ']' || c == '}' || c == ')' || c == 'W') {
            if (checkBracket (stack, c)) {
                stack.pop ();
            } else {
                return 0;
            }
        } else {
            return 0;
        }

    }
    if (stack.empty ()) {
        return 1;
    }
    return 0;
}
----------------------------------------

int solution (string S) {
    int N = S.size ();
    if (N == 0) return 1;

    if (S [0] == ')' || S [0] == ']' || S [0] == '}') return 0;

    if (S [N - 1] == '(' || S [N - 1] == '[' || S [N - 1] == '{') return 0;

    int paren_open = 0;
    int brac_open = 0;
    int curl_open = 0;
    for (int i = 0;
    i < N; ++ i) {
        if (S [i] == ')' && (paren_open == 0 || S [i - 1] == '[' || S [i - 1] == '{')) return 0;

        if (S [i] == ']' && (brac_open == 0 || S [i - 1] == '(' || S [i - 1] == '{')) return 0;

        if (S [i] == '}' && (curl_open == 0 || S [i - 1] == '[' || S [i - 1] == '(')) return 0;

        if (S [i] == '(') paren_open ++;
        else if (S [i] == ')') paren_open --;
        else if (S [i] == '[') brac_open ++;
        else if (S [i] == ']') brac_open --;
        else if (S [i] == '{') curl_open ++;
        else if (S [i] == '}') curl_open --;

    }
    if (paren_open == 0 && brac_open == 0 && curl_open == 0) return 1;

    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28951336_50420886_1_27
28951336_51573594_1_22
Title: Codility : Brackets Determine whether a given string of parentheses is properly nested 
----------------------------------------

public int solution (String S) {
    Deque < Character > stack = new ArrayDeque < Character > ();
    for (int i = 0;
    i < S.length (); i ++) {
        char c = S.charAt (i);
        switch (c) {
            case ')' :
                if (stack.isEmpty () || stack.pop () != '(') return 0;

                break;
            case ']' :
                if (stack.isEmpty () || stack.pop () != '[') return 0;

                break;
            case '}' :
                if (stack.isEmpty () || stack.pop () != '{') return 0;

                break;
            default :
                stack.push (c);
                break;
        }
    }
    return stack.isEmpty () ? 1 : 0;
}
----------------------------------------

int solution (string S) {
    int N = S.size ();
    if (N == 0) return 1;

    if (S [0] == ')' || S [0] == ']' || S [0] == '}') return 0;

    if (S [N - 1] == '(' || S [N - 1] == '[' || S [N - 1] == '{') return 0;

    int paren_open = 0;
    int brac_open = 0;
    int curl_open = 0;
    for (int i = 0;
    i < N; ++ i) {
        if (S [i] == ')' && (paren_open == 0 || S [i - 1] == '[' || S [i - 1] == '{')) return 0;

        if (S [i] == ']' && (brac_open == 0 || S [i - 1] == '(' || S [i - 1] == '{')) return 0;

        if (S [i] == '}' && (curl_open == 0 || S [i - 1] == '[' || S [i - 1] == '(')) return 0;

        if (S [i] == '(') paren_open ++;
        else if (S [i] == ')') paren_open --;
        else if (S [i] == '[') brac_open ++;
        else if (S [i] == ']') brac_open --;
        else if (S [i] == '{') curl_open ++;
        else if (S [i] == '}') curl_open --;

    }
    if (paren_open == 0 && brac_open == 0 && curl_open == 0) return 1;

    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28959327_28959380_1_14
28959327_29079384_63_85
Title: Java Programming String Array Trouble 
----------------------------------------

public static void main (String [] args) {
    Scanner peace = new Scanner (System.in);
    System.out.print ("How many subjects do you want to enter?: ");
    int a = peace.nextInt ();
    String [] b = new String [a];
    for (int i = 0;
    i < a; i ++) {
        System.out.print ("Enter Subject No " + (i + 1) + " ");
        b [i] = peace.next ();
    }
    for (i = 0; i < b.length; i ++) {
        System.out.print (b [i] + " ");
    }
}
----------------------------------------

public static void main (String [] args) {
    double Ave = 0;
    Scanner peace = new Scanner (System.in);
    System.out.print ("How many subjects do you want to enter?: ");
    int SubjectsNumber = peace.nextInt ();
    int [] SubjectGrades = new int [SubjectsNumber];
    String [] Subjects = new String [SubjectsNumber];
    for (int i = 0;
    i < SubjectsNumber; i ++) {
        Subjects [i] = "";
        System.out.print ("Enter Subject No " + (i + 1) + ": ");
        Subjects [i] = peace.next ();
        System.out.println ("What is your grade in " + Subjects [i] + ": ");
        SubjectGrades [i] = peace.nextInt ();
    }
    int Numeral;
    Ave = processAverage (SubjectGrades, SubjectsNumber);
    System.out.println ("Your General Average is: " + Ave);
    Numeral = processNumericalValue (Ave);
    System.out.println ("Numerical Value is: " + Numeral);
    processLetterGrade (Numeral);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28959327_28959388_6_23
28959327_29079384_63_85
Title: Java Programming String Array Trouble 
----------------------------------------

public static void main (String [] args) {
    int i;
    Scanner peace = new Scanner (System.in);
    System.out.print ("How many subjects do you want to enter?: ");
    int a = peace.nextInt ();
    String [] b = new String [a];
    for (i = 0; i < a; i ++) {
        System.out.print ("Enter Subject No " + (i + 1) + " ");
        b [i] = peace.next ();
    }
    for (i = 0; i < b.length; i ++) {
        System.out.print (b [i]);
    }
}
----------------------------------------

public static void main (String [] args) {
    double Ave = 0;
    Scanner peace = new Scanner (System.in);
    System.out.print ("How many subjects do you want to enter?: ");
    int SubjectsNumber = peace.nextInt ();
    int [] SubjectGrades = new int [SubjectsNumber];
    String [] Subjects = new String [SubjectsNumber];
    for (int i = 0;
    i < SubjectsNumber; i ++) {
        Subjects [i] = "";
        System.out.print ("Enter Subject No " + (i + 1) + ": ");
        Subjects [i] = peace.next ();
        System.out.println ("What is your grade in " + Subjects [i] + ": ");
        SubjectGrades [i] = peace.nextInt ();
    }
    int Numeral;
    Ave = processAverage (SubjectGrades, SubjectsNumber);
    System.out.println ("Your General Average is: " + Ave);
    Numeral = processNumericalValue (Ave);
    System.out.println ("Numerical Value is: " + Numeral);
    processLetterGrade (Numeral);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28972234_28972515_1_13
28972234_28974831_1_19
Title: how to use intent in Android 
----------------------------------------

protected void onCreate (Bundle savedInstanceState) {
    super.onCreate (savedInstanceState);
    setContentView (R.layout.activity_result);
    Bundle extras = getIntent ().getExtras ();
    String myString = extras.getString ("MyStringValue");
    double amount = Double.parseDouble (myString);
    double res = (amount / 100.0f) * 15;
    TextView t = (TextView) findViewById (R.id.my_text);
    t.setText (res);
}
----------------------------------------

@Override
protected void onCreate (Bundle savedInstanceState) {
    super.onCreate (savedInstanceState);
    setContentView (R.layout.activity_result);
    Intent i = getIntent ();
    String myString = i.getStringExtra ("MyString");
    double amount = Double.parseDouble (myString);
    double res = (amount / 100.0f) * 10;
    String result = String.valueOf (res);
    TextView t = (TextView) findViewById (R.id.my_text);
    t.setText (result);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28974703_28985763_1_14
28974703_43923822_1_37
Title: Fragment Backstack 
----------------------------------------

@Override
public void onBackPressed () {
    Fragment fr = getFragmentManager ().findFragmentById (R.id.authentication_parent0_linear);
    if (fr == mLoginFragment) {
        super.onBackPressed ();
    } else {
        FragmentTransaction fragmentTransaction = getFragmentManager ().beginTransaction ();
        fragmentTransaction.replace (R.id.authentication_parent0_linear, mLoginFragment, LOGINTAG);
        fragmentTransaction.commit ();
    }
}
----------------------------------------

public void onBackPressed () {
    int backStackEntryCount = fm.getBackStackEntryCount ();
    if (backStackEntryCount == 0) {
        new AlertDialog.Builder (this).setIcon (android.R.drawable.ic_dialog_alert).setTitle ("Closing Activity").setMessage ("Are you sure you want to close this Application?").setPositiveButton ("Yes", new DialogInterface.OnClickListener () {
            @Override
            public void onClick (DialogInterface dialog, int which) {
                finish ();
                System.exit (0);
            }}

        ).setNegativeButton ("No", null).setOnCancelListener (new DialogInterface.OnCancelListener () {
            @Override
            public void onCancel (DialogInterface dialogInterface) {
                finish ();
                System.exit (0);
            }}

        ).show ();
    } else {
        super.onBackPressed ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28975333_28975449_5_71
28975333_28975664_7_107
Title: How to deny switch-case running unless variable initialized 
----------------------------------------

public static void main (String [] args) {
    in = new Scanner (System.in);
    int userChoice;
    boolean quit = false;
    String firstName = null;
    String secondName = null;
    String email = null;
    String username = null;
    String password = null;
    do {
        System.out.println ("1. Create Account");
        System.out.println ("2. Login");
        System.out.println ("3. Quit");
        userChoice = Integer.parseInt (in.nextLine ());
        switch (userChoice) {
            case 1 :
                System.out.print ("Enter your first name: ");
                firstName = in.nextLine ();
                System.out.println ("Enter your second name:");
                secondName = in.nextLine ();
                System.out.println ("Enter your email address:");
                email = in.nextLine ();
                System.out.println ("Enter chosen username:");
                username = in.nextLine ();
                System.out.println ("Enter chosen password:");
                password = in.nextLine ();
                break;
            case 2 :
                String enteredUsername;
                String enteredPassword;
                System.out.print ("Enter Username:");
                enteredUsername = in.nextLine ();
                System.out.print ("Enter Password:");
                enteredPassword = in.nextLine ();
                if (username != null && password != null && enteredUsername.equals (username) && enteredPassword.equals (password)) System.out.println ("Login Successfull!");
                else System.out.println ("Login Failed!");

                break;
            case 3 :
                quit = true;
                break;
            default :
                System.out.println ("Wrong choice.");
                break;
        }
        System.out.println ();
    } while (! quit);
    System.out.println ("Bye!");
}
----------------------------------------

public static void main (String [] args) {
    in = new Scanner (System.in);
    int userChoice;
    boolean quit = false;
    String firstName = null;
    String secondName = null;
    String email = null;
    String username = null;
    String password = null;
    String enteredUsername = null;
    String enteredPassword = null;
    do {
        System.out.println ("1. Create Account");
        System.out.println ("2. Login");
        System.out.print ("3. Quit");
        userChoice = in.nextInt ();
        switch (userChoice) {
            case 1 :
                System.out.print ("Enter your first name: ");
                do {
                    firstName = in.nextLine ();
                } while (firstName == null || firstName.equals (""));
                System.out.println ("Enter your second name:");
                secondName = in.nextLine ();
                System.out.println ("Enter your email address:");
                email = in.nextLine ();
                System.out.println ("Enter chosen username:");
                username = in.nextLine ();
                System.out.println ("Enter chosen password:");
                password = in.nextLine ();
                break;
            case 2 :
                System.out.print ("Enter Username:");
                do {
                    enteredUsername = in.nextLine ();
                } while (enteredUsername == null || enteredUsername.equals (""));
                System.out.print ("Enter Password:");
                enteredPassword = in.nextLine ();
                if (enteredUsername.equals (username) && enteredPassword.equals (password)) {
                    System.out.println ("Login Successfull!");
                } else System.out.println ("Login Failed!");

                break;
            case 3 :
                quit = true;
                break;
            default :
                System.out.println ("Wrong choice.");
                break;
        }
        System.out.println ();
    } while (! quit);
    System.out.println ("Bye!");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28975427_28975680_1_11
28975427_28976028_1_17
Title: Efficient sort-by function 
----------------------------------------

static < D, R extends Comparable < ? super R > > void sortBy (List < D > list, Function < D, R > function) {
    Map < D, R > memo = new HashMap < > ();
    Collections.sort (list, new Comparator < D > () {
        @Override
        public int compare (D d1, D d2) {
            R r1 = memo.computeIfAbsent (d1, function);
            R r2 = memo.computeIfAbsent (d2, function);
            return r1.compareTo (r2);
        }}

    );
}
----------------------------------------

static < D, R extends Comparable > List < D > sortBy (List < D > list, Function < D, R > function) {
    List < Pair < D, R > > newList = list.stream ().map (d -> new Pair < > (d, function.apply (d))).collect (Collectors.toList ());
    Collections.sort (newList, new Comparator < Pair < D, R > > () {
        @Override
        public int compare (Pair < D, R > p1, Pair < D, R > p2) {
            return p1.second.compareTo (p2.second);
        }}

    );
    return newList.stream ().map (p -> p.first).collect (Collectors.toList ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28975995_28976079_69_78
28975995_28976079_84_95
Title: Generating random number appearing one number at a time 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    StringBuilder sb = new StringBuilder (field.getText ());
    sb.append (values [index]);
    field.setText (sb.toString ());
    index ++;
    if (index >= values.length) {
        ((Timer) e.getSource ()).stop ();
    }
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    if (timer.isRunning ()) {
        timer.stop ();
    }
    field.setText ("");
    index = 0;
    int number = rnd.nextInt (999);
    String text = Integer.toString (number);
    label.setText (text);
    values = text.toCharArray ();
    timer.start ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28980108_28982533_15_23
28980108_28982533_25_33
Title: "Used Multikey(123) to store entries in Map. Now only have (1) . Can I retrieve all the entries that have (1) in the Multikeys?" 
----------------------------------------

public Set < V > getIncludingSubsets (K...keys) {
    HashSet < V > all = new HashSet < > ();
    for (Entry < KeySet < K >, V > entry : model.entrySet ()) {
        if (entry.getKey ().containsPartially (keys)) {
            all.add (entry.getValue ());
        }
    }
    return all;
}
----------------------------------------

public Set < V > getIncludingSubsets (Set < K > keys) {
    HashSet < V > all = new HashSet < > ();
    for (Entry < KeySet < K >, V > entry : model.entrySet ()) {
        if (entry.getKey ().containsPartially (keys)) {
            all.add (entry.getValue ());
        }
    }
    return all;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28984607_28985906_1_18
28984607_28990276_2_21
Title: Choosing an arrays size and populate it with user input 
----------------------------------------

public static void main (String [] args) {
    Scanner s = new Scanner (System.in);
    System.out.println ("Hur mnga nummer ska din lista best av?");
    int ListaLength = s.nextInt ();
    Integer array [] = new Integer [ListaLength];
    for (int i = 0;
    i < ListaLength; i ++) {
        array [i] = s.nextInt ();
    }
    for (int i : array) {
        System.out.print (i + " ");
    }
    System.out.println ("Skriv in numret du letar efter.");
    int num = s.nextInt ();
    int index = Arrays.asList (array).indexOf (num);
    System.out.println (index);
}
----------------------------------------

public static void main (String args []) {
    Scanner s = new Scanner (System.in);
    System.out.print ("Enter Size : ");
    int Size = Integer.parseInt (s.nextLine ());
    int array [] = new int [Size];
    for (int i = 0;
    i < array.length; i ++) {
        System.out.print ("Enter Number : ");
        array [i] = Integer.parseInt (s.nextLine ());
    }
    System.out.print ("\narray : ");
    for (int x : array) System.out.print (x + " ");

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28984789_34151893_13_22
28984789_52822811_10_27
Title: Convert JSON to Android Bundle 
----------------------------------------

public static Bundle jsonToBundle (JSONObject jsonObject) throws JSONException {
    Bundle bundle = new Bundle ();
    Iterator iter = jsonObject.keys ();
    while (iter.hasNext ()) {
        String key = (String) iter.next ();
        String value = jsonObject.getString (key);
        bundle.putString (key, value);
    }
    return bundle;
}
----------------------------------------

private static Bundle jsonToBundle (JSONObject jsonObject) throws JSONException {
    Bundle bundle = new Bundle ();
    Iterator iter = jsonObject.keys ();
    while (iter.hasNext ()) {
        String key = (String) iter.next ();
        String value = jsonObject.getString (key);
        Bundle bundleVal = jsonStringToBundle (value);
        if (bundleVal != null) {
            bundle.putBundle (key, bundleVal);
        } else {
            bundle.putString (key, value);
        }
    }
    return bundle;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28986673_28987003_2_39
28986673_28987384_5_21
Title: Sum of two arrays in java 
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    System.out.println ("Enter the size of the arrays : ");
    int size = input.nextInt ();
    int arrayOne [] = new int [size];
    int arrayTwo [] = new int [size];
    for (int i = 0;
    i < size; i ++) {
        System.out.println ("Enter the " + i + "th elements of the 1st array");
        arrayOne [i] = input.nextInt ();
        System.out.println ("Enter the " + i + "th elements of the 2st array");
        arrayTwo [i] = input.nextInt ();
    }
    ArrayMath arrayMath = new ArrayMath (arrayOne);
    int [] additionArray = arrayMath.sum (arrayTwo);
    int [] subtractionArray = arrayMath.subtract (arrayTwo);
    if (additionArray == null) {
        System.out.println ("Both array are not of same size hence cannot add");
    } else {
        System.out.println ("Addition of array is");
        Arrays.sort (additionArray);
        for (int i = 0;
        i < additionArray.length; i ++) {
            System.out.println (additionArray [i] + " ");
        }
    }
    if (subtractionArray == null) {
        System.out.println ("Both array are not of same size hence cannot subtract");
    } else {
        System.out.println ("Subtraction of array is");
        Arrays.sort (subtractionArray);
        for (int i = 0;
        i < subtractionArray.length; i ++) {
            System.out.println (subtractionArray [i] + " ");
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    System.out.println ("Enter the two array size..");
    Scanner input = new Scanner (System.in);
    int size = input.nextInt ();
    int [] one = new int [size], two = new int [size];
    System.out.println ("Enter the array elements of Array-One");
    for (int i = 0;
    i < size; i ++) {
        one [i] = input.nextInt ();
    }
    System.out.println ("Enter the array elements of Array-Two");
    for (int i = 0;
    i < size; i ++) {
        two [i] = input.nextInt ();
    }
    Addition (one, two);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28986673_28987003_2_39
28986673_28987471_4_18
Title: Sum of two arrays in java 
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    System.out.println ("Enter the size of the arrays : ");
    int size = input.nextInt ();
    int arrayOne [] = new int [size];
    int arrayTwo [] = new int [size];
    for (int i = 0;
    i < size; i ++) {
        System.out.println ("Enter the " + i + "th elements of the 1st array");
        arrayOne [i] = input.nextInt ();
        System.out.println ("Enter the " + i + "th elements of the 2st array");
        arrayTwo [i] = input.nextInt ();
    }
    ArrayMath arrayMath = new ArrayMath (arrayOne);
    int [] additionArray = arrayMath.sum (arrayTwo);
    int [] subtractionArray = arrayMath.subtract (arrayTwo);
    if (additionArray == null) {
        System.out.println ("Both array are not of same size hence cannot add");
    } else {
        System.out.println ("Addition of array is");
        Arrays.sort (additionArray);
        for (int i = 0;
        i < additionArray.length; i ++) {
            System.out.println (additionArray [i] + " ");
        }
    }
    if (subtractionArray == null) {
        System.out.println ("Both array are not of same size hence cannot subtract");
    } else {
        System.out.println ("Subtraction of array is");
        Arrays.sort (subtractionArray);
        for (int i = 0;
        i < subtractionArray.length; i ++) {
            System.out.println (subtractionArray [i] + " ");
        }
    }
}
----------------------------------------

public static void main (String...args) {
    int [] ar1 = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int [] ar2 = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int [] arSum = new int [ar1.length + ar2.length];
    int i = 0;
    for (int val : ar1) {
        arSum [i ++] = val;
    }
    for (int val : ar2) {
        arSum [i ++] = val;
    }
    System.out.println (Arrays.toString (arSum));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28986673_28987003_2_39
28986673_28987773_1_24
Title: Sum of two arrays in java 
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    System.out.println ("Enter the size of the arrays : ");
    int size = input.nextInt ();
    int arrayOne [] = new int [size];
    int arrayTwo [] = new int [size];
    for (int i = 0;
    i < size; i ++) {
        System.out.println ("Enter the " + i + "th elements of the 1st array");
        arrayOne [i] = input.nextInt ();
        System.out.println ("Enter the " + i + "th elements of the 2st array");
        arrayTwo [i] = input.nextInt ();
    }
    ArrayMath arrayMath = new ArrayMath (arrayOne);
    int [] additionArray = arrayMath.sum (arrayTwo);
    int [] subtractionArray = arrayMath.subtract (arrayTwo);
    if (additionArray == null) {
        System.out.println ("Both array are not of same size hence cannot add");
    } else {
        System.out.println ("Addition of array is");
        Arrays.sort (additionArray);
        for (int i = 0;
        i < additionArray.length; i ++) {
            System.out.println (additionArray [i] + " ");
        }
    }
    if (subtractionArray == null) {
        System.out.println ("Both array are not of same size hence cannot subtract");
    } else {
        System.out.println ("Subtraction of array is");
        Arrays.sort (subtractionArray);
        for (int i = 0;
        i < subtractionArray.length; i ++) {
            System.out.println (subtractionArray [i] + " ");
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    int arr1 [] = new int [10];
    int result [] = new int [10];
    System.out.println ("Enter the elements of the 1st array");
    for (int x = 0;
    x < arr1.length; x ++) {
        arr1 [x] = input.nextInt ();
    }
    int arr2 [] = new int [10];
    System.out.println ("Enter the elements of the 2nd array");
    for (int x = 0;
    x < arr2.length; x ++) {
        arr2 [x] = input.nextInt ();
    }
    for (int i = 0;
    i < arr1.length; i ++) {
        result [i] = arr1 [i] + arr2 [i];
    }
    Arrays.sort (result);
    for (int i = 0;
    i < result.length; i ++) {
        System.out.println (result [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28986673_28987384_5_21
28986673_28987471_4_18
Title: Sum of two arrays in java 
----------------------------------------

public static void main (String [] args) {
    System.out.println ("Enter the two array size..");
    Scanner input = new Scanner (System.in);
    int size = input.nextInt ();
    int [] one = new int [size], two = new int [size];
    System.out.println ("Enter the array elements of Array-One");
    for (int i = 0;
    i < size; i ++) {
        one [i] = input.nextInt ();
    }
    System.out.println ("Enter the array elements of Array-Two");
    for (int i = 0;
    i < size; i ++) {
        two [i] = input.nextInt ();
    }
    Addition (one, two);
}
----------------------------------------

public static void main (String...args) {
    int [] ar1 = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int [] ar2 = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int [] arSum = new int [ar1.length + ar2.length];
    int i = 0;
    for (int val : ar1) {
        arSum [i ++] = val;
    }
    for (int val : ar2) {
        arSum [i ++] = val;
    }
    System.out.println (Arrays.toString (arSum));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28986673_28987384_5_21
28986673_28987773_1_24
Title: Sum of two arrays in java 
----------------------------------------

public static void main (String [] args) {
    System.out.println ("Enter the two array size..");
    Scanner input = new Scanner (System.in);
    int size = input.nextInt ();
    int [] one = new int [size], two = new int [size];
    System.out.println ("Enter the array elements of Array-One");
    for (int i = 0;
    i < size; i ++) {
        one [i] = input.nextInt ();
    }
    System.out.println ("Enter the array elements of Array-Two");
    for (int i = 0;
    i < size; i ++) {
        two [i] = input.nextInt ();
    }
    Addition (one, two);
}
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    int arr1 [] = new int [10];
    int result [] = new int [10];
    System.out.println ("Enter the elements of the 1st array");
    for (int x = 0;
    x < arr1.length; x ++) {
        arr1 [x] = input.nextInt ();
    }
    int arr2 [] = new int [10];
    System.out.println ("Enter the elements of the 2nd array");
    for (int x = 0;
    x < arr2.length; x ++) {
        arr2 [x] = input.nextInt ();
    }
    for (int i = 0;
    i < arr1.length; i ++) {
        result [i] = arr1 [i] + arr2 [i];
    }
    Arrays.sort (result);
    for (int i = 0;
    i < result.length; i ++) {
        System.out.println (result [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28986673_28987471_4_18
28986673_28987773_1_24
Title: Sum of two arrays in java 
----------------------------------------

public static void main (String...args) {
    int [] ar1 = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int [] ar2 = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int [] arSum = new int [ar1.length + ar2.length];
    int i = 0;
    for (int val : ar1) {
        arSum [i ++] = val;
    }
    for (int val : ar2) {
        arSum [i ++] = val;
    }
    System.out.println (Arrays.toString (arSum));
}
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    int arr1 [] = new int [10];
    int result [] = new int [10];
    System.out.println ("Enter the elements of the 1st array");
    for (int x = 0;
    x < arr1.length; x ++) {
        arr1 [x] = input.nextInt ();
    }
    int arr2 [] = new int [10];
    System.out.println ("Enter the elements of the 2nd array");
    for (int x = 0;
    x < arr2.length; x ++) {
        arr2 [x] = input.nextInt ();
    }
    for (int i = 0;
    i < arr1.length; i ++) {
        result [i] = arr1 [i] + arr2 [i];
    }
    Arrays.sort (result);
    for (int i = 0;
    i < result.length; i ++) {
        System.out.println (result [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29001777_29012593_6_29
29001777_42532775_1_35
Title: Creating a Hollow Rectangle Using Asterisks in Java 
----------------------------------------

public static void main (String [] args) {
    System.out.print ("Enter the height of the rectangle: ");
    int h = sc.nextInt ();
    System.out.print ("Enter the width of the rectangle: ");
    int w = sc.nextInt ();
    for (int j = 1;
    j <= h; j ++) {
        for (int i = 1;
        i <= w; i ++) {
            if (j == 1 || j == h || i == 1 || i == w) {
                System.out.print ("*");
            } else {
                System.out.print (" ");
            }
        }
        System.out.println ();
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    int sides;
    System.out.print ("Enter the length of the side of the square: ");
    sides = input.nextInt ();
    int count = 0;
    int counter = 1;
    while (count < sides) {
        System.out.print ("*");
        count ++;
    }
    System.out.println ();
    count = 0;
    while (counter < sides - 1) {
        System.out.print ("*");
        while (count < sides - 2) {
            System.out.print (" ");
            count ++;
        }
        System.out.println ("*");
        count = 0;
        counter ++;
    }
    while (count < sides) {
        System.out.print ("*");
        count ++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29021676_29021938_16_33
29021676_29022233_3_27
Title: java- difference between 2 different times in 2 different days 
----------------------------------------

public static void main (String [] args) throws ParseException {
    Calendar calendar1 = Calendar.getInstance ();
    DateFormat df = new SimpleDateFormat ("yyyy/MM/dd HH:mm:ss");
    Date date1 = calendar1.getTime ();
    Date date2 = df.parse ("2015/03/20 10:30:00");
    Duration duration = new Duration (date1.getTime (), date2.getTime ());
    long millis = duration.getMillis ();
    long days = duration.getStandardDays ();
    long mins = duration.getStandardMinutes ();
    long hrs = duration.getStandardHours ();
    long secs = duration.getStandardSeconds ();
    System.out.println (days + ":" + (hrs % 24) + ":" + (mins % 60) + ":" + (secs % (mins)) + " remaining");
}
----------------------------------------

public static void main () {
    Instant then = Instant.EPOCH;
    Instant now = Instant.now ();
    Duration duration = Duration.between (then, now);
    System.out.println (duration.getDays ());
    System.out.println (duration.getHours ());
    System.out.println (duration.getMinutes ());
    System.out.println (duration.getSeconds ());
    System.out.println (duration.getDays ());
    duration = duration.minusDays (duration.getDays ());
    System.out.println (duration.getHours ());
    duration = duration.minusHours (duration.getHours ());
    System.out.println (duration.getMinutes ());
    duration = duration.minusMinutes (duration.getMinutes ());
    System.out.println (duration.getSeconds ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29034205_29037875_19_42
29034205_29037875_66_77
Title: JavaFX more Scenes 
----------------------------------------

public void start (Stage primaryStage) throws Exception {
    gui2.getButtonShowGUI1 ().setOnAction (gui2ButtonEvent -> {
        if (primaryStage.isShowing ()) primaryStage.toFront ();
        else primaryStage.show ();

    });
    buttonShowGUI2.setOnAction (actionEvent -> {
        try {
            if (gui2.getPrimaryStage () == null) gui2.start (new Stage ());
            else gui2.getPrimaryStage ().toFront ();

        } catch (Exception ex) {
            logger.log (Level.SEVERE, null, ex);
        }
    });
    Pane root = new StackPane (buttonShowGUI2);
    Scene stageScene = new Scene (root, 400, 250);
    primaryStage.setScene (stageScene);
    primaryStage.centerOnScreen ();
    primaryStage.setTitle ("GUI 1");
    primaryStage.show ();
}
----------------------------------------

public void start (Stage primaryStage) throws Exception {
    this.primaryStage = primaryStage;
    Pane root = new StackPane (buttonShowGUI1);
    Scene stageScene = new Scene (root, 400, 250);
    primaryStage.setScene (stageScene);
    primaryStage.centerOnScreen ();
    primaryStage.setTitle ("GUI 2");
    primaryStage.show ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29039741_29048044_7_16
29039741_29067127_11_22
Title: Get list of all subfolders 
----------------------------------------

public void getFolders (String directoryName, List < String > folders) {
    File directory = new File (directoryName);
    File [] fList = directory.listFiles ();
    for (File file : fList) {
        if (file.isDirectory ()) {
            folders.add (file.getAbsolutePath ());
            getFolders (file.getAbsolutePath (), folders);
        }
    }
}
----------------------------------------

public void getFolders (String directoryName, List < String > folders) throws IOException, CmdClientException {
    CmdReplyFile cmdfiles = client.execLs (directoryName);
    File [] fileObjects = cmdfiles.getFileList ();
    String dirStructure = folders.get (folders.size () - 1).toString ();
    for (File file : fileObjects) {
        if (file.isDirectory ()) {
            String folderPath = dirStructure + file.getName () + "/";
            folders.add (folderPath);
            getFolders (folderPath, folders);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29040618_29040657_1_19
29040618_29041521_1_10
Title: Sorting algorithm without using compareTo 
----------------------------------------

public static int compare (String a, String b) {
    int len = Math.min (a.length (), b.length ());
    for (int i = 0;
    i < len; i ++) {
        char cha = a.charAt (i);
        char chb = b.charAt (i);
        if (cha < chb) {
            return - 1;
        } else if (cha > chb) {
            return 1;
        }

    }
    if (a.length () < b.length ()) return - 1;
    else if (a.length () > b.length ()) return 1;
    else return 0;

}
----------------------------------------

public static int compare (char cha, char chb) {
    if (cha - chb < 0) {
        return - 1;
    } else if (chb - cha > 0) {
        return 1;
    } else if (chb - cha == 0) {
        return 0;
    }

    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29043081_29046085_4_43
29043081_29047941_8_53
Title: JavaFX mouse transparent is not working 
----------------------------------------

public void start (Stage primaryStage) {
    Group root = new Group ();
    Rectangle outerRect = new Rectangle (100, 100, 200, 200);
    outerRect.setStroke (Color.BLUE);
    outerRect.setFill (Color.BLUE.deriveColor (1, 1, 1, 0.2));
    Rectangle innerRect = new Rectangle (150, 150, 50, 50);
    innerRect.setStroke (Color.RED);
    innerRect.setFill (Color.RED.deriveColor (1, 1, 1, 0.2));
    Circle circle = new Circle (250, 250, 50);
    circle.setStroke (Color.GREEN);
    circle.setFill (Color.GREEN.deriveColor (1, 1, 1, 0.2));
    CheckBox checkBox = new CheckBox ("Enable Mouse Transparency");
    innerRect.mouseTransparentProperty ().bind (checkBox.selectedProperty ());
    Label label = new Label ("You clicked: ");
    outerRect.addEventFilter (MouseEvent.MOUSE_PRESSED, e -> label.setText ("You clicked: Outer Rectangle"));
    innerRect.addEventFilter (MouseEvent.MOUSE_PRESSED, e -> label.setText ("You clicked: Inner Rectangle"));
    circle.addEventFilter (MouseEvent.MOUSE_PRESSED, e -> label.setText ("You clicked: Circle"));
    VBox vBox = new VBox ();
    vBox.getChildren ().addAll (checkBox, label);
    root.getChildren ().addAll (vBox, outerRect, innerRect, circle);
    Scene scene = new Scene (root, 500, 500);
    primaryStage.setScene (scene);
    primaryStage.show ();
}
----------------------------------------

public void start (Stage stage) throws Exception {
    StackPane stackPane = new StackPane ();
    Button bigButton = new Button ("I'm not clickable");
    bigButton.setOnAction (e -> System.out.println (e));
    bigButton.setMaxHeight (Double.MAX_VALUE);
    bigButton.setMaxWidth (Double.MAX_VALUE);
    stackPane.getChildren ().add (bigButton);
    VBox vbox = new VBox ();
    vbox.setAlignment (Pos.CENTER);
    vbox.setSpacing (20);
    vbox.setPrefHeight (Double.MAX_VALUE);
    vbox.setPrefWidth (400);
    ObservableList < Node > vChildren = vbox.getChildren ();
    Button button1 = new Button ("This");
    button1.setOnAction (e -> {
        System.out.println (e);
        e.consume ();
    });
    Button button2 = new Button ("Button");
    button2.setOnAction (e -> {
        System.out.println (e);
        e.consume ();
    });
    Button button3 = new Button ("Are clickable");
    button3.setOnAction (e -> {
        System.out.println (e);
        e.consume ();
    });
    vChildren.addAll (button1, button2, button3);
    BorderPane borderPane = new BorderPane ();
    borderPane.setCenter (vbox);
    vbox.prefWidthProperty ().bind (bigButton.widthProperty ());
    vbox.prefHeightProperty ().bind (bigButton.heightProperty ());
    bigButton.setGraphic (borderPane);
    stage.setScene (new Scene (stackPane, 800, 600));
    stage.show ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29045487_29048613_1_34
29045487_29081114_1_16
Title: Saving Image on Parse.com 
----------------------------------------

protected void onActivityResult (int requestCode, int resultCode, Intent data) {
    super.onActivityResult (requestCode, resultCode, data);
    if (requestCode == RESULT_LOAD_IMAGE && resultCode == RESULT_OK && null != data) {
        Uri selectedImage = data.getData ();
        String [] filePathColumn = {MediaStore.Images.Media.DATA};
        Cursor cursor = getContentResolver ().query (selectedImage, filePathColumn, null, null, null);
        cursor.moveToFirst ();
        int columnIndex = cursor.getColumnIndex (filePathColumn [0]);
        String filePath = cursor.getString (columnIndex);
        cursor.close ();
        Bitmap yourSelectedImage = BitmapFactory.decodeFile (filePath);
        ByteArrayOutputStream stream = new ByteArrayOutputStream ();
        yourSelectedImage.compress (Bitmap.CompressFormat.PNG, 100, stream);
        byte [] image = stream.toByteArray ();
        ParseUser currentUser = ParseUser.getCurrentUser ();
        ParseFile photoFile = new ParseFile ("fotoperfil" + currentUser.getUsername () + ".png", image);
        currentUser.put ("Imagen", photoFile);
        currentUser.saveInBackground ();
    }
}
----------------------------------------

@Override
protected void onActivityResult (int requestCode, int resultCode, Intent data) {
    byte [] image_byte_array;
    if (requestCode == REQUEST_IMAGE_CAPTURE && resultCode == RESULT_OK) {
        post_object = new Post ();
        Bundle extras = data.getExtras ();
        image = (Bitmap) extras.get ("data");
        ByteArrayOutputStream stream = new ByteArrayOutputStream ();
        image.compress (Bitmap.CompressFormat.PNG, 100, stream);
        image_byte_array = stream.toByteArray ();
        picture_file = new ParseFile ("Picture", image_byte_array);
        picture_file.saveInBackground ();
        post_object.put ("Image", picture_file);
        post_object.saveInBackground ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29047793_29052070_131_145
29047793_29052070_61_68
Title: Java socket file transfer - Files don't transfer completely 
----------------------------------------

public static void toStream (OutputStream os, File file) throws java.io.FileNotFoundException, java.io.IOException {
    toStream (os, (int) file.length ());
    byte b [] = new byte [1024];
    InputStream is = new FileInputStream (file);
    int numRead = 0;
    while ((numRead = is.read (b)) > 0) {
        os.write (b, 0, numRead);
    }
    os.flush ();
}
----------------------------------------

public static void toStream (OutputStream os, String s) throws java.io.IOException {
    int len_s = s.length ();
    toStream (os, len_s);
    for (int i = 0;
    i < len_s; i ++) {
        os.write ((byte) s.charAt (i));
    }
    os.flush ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29047793_29052070_70_92
29047793_29052070_8_18
Title: Java socket file transfer - Files don't transfer completely 
----------------------------------------

private static byte [] toByteArray (InputStream ins, int an_int) throws java.io.IOException, Exception {
    byte [] ret = new byte [an_int];
    int offset = 0;
    int numRead = 0;
    int outstanding = an_int;
    while ((offset < an_int) && ((numRead = ins.read (ret, offset, outstanding)) > 0)) {
        offset += numRead;
        outstanding = an_int - offset;
    }
    if (offset < ret.length) {
        throw new Exception ("Could not completely read from stream, numRead=" + numRead + ", ret.length=" + ret.length);
    }
    return ret;
}
----------------------------------------

private static byte [] toByteArray (int in_int) {
    byte a [] = new byte [4];
    for (int i = 0;
    i < 4; i ++) {
        int b_int = (in_int>> (i * 8)) & 255;
        byte b = (byte) (b_int);
        a [i] = b;
    }
    return a;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29051746_52323036_3_14
29051746_53048568_10_24
Title: Finding the missing integer (Codility tests) 
----------------------------------------

public int solution (int [] A) {
    Arrays.sort (A);
    int min = 1;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == min) {
            min ++;
        }
    }
    return min;
}
----------------------------------------

public int solution (int [] A) {
    int smallest = 1;
    Arrays.sort (A);
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == smallest) {
            smallest ++;
        }
    }
    return smallest;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29053710_29053760_5_16
29053710_29053880_1_15
Title: Java nested while loops 
----------------------------------------

public static void Display () {
    while (k > 0) {
        i = 0;
        while (i <= 10) {
            System.out.println ("K = " + k + " I = " + i);
            i += 2;
        }
        k --;
    }
}
----------------------------------------

public static void Display () {
    while (k > 1) {
        i = 0;
        while (i <= 10) {
            i = i + 2;
            System.out.println ("K = " + k + " I = " + i);
        }
        k --;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29054272_29054522_1_29
29054272_29058631_1_22
Title: Drawing a recursive snow flake 
----------------------------------------

public void drawFlake (int level, float angleDegrees, Graphics g) {
    if (level >= MAX_LEVEL || maxLength == 0) {
        return;
    }
    if (angleDegrees >= 360) {
        maxLength *= .9;
        drawFlake (level + 1, 0, g);
        return;
    }
    g.drawLine (centerX, centerY, centerX + (int) (maxLength * Math.sin (Math.toRadians (angleDegrees))), centerY + (int) (maxLength * Math.cos (Math.toRadians (angleDegrees))));
    int currentLevelAngleIncrement = 60 / (level + 1);
    drawFlake (level, angleDegrees + currentLevelAngleIncrement, g);
}
----------------------------------------

public void drawFlake (int x1, int y1, int length, Graphics g) {
    g.drawLine (x1, y1, x1 + length, y1);
    g.drawLine (x1, y1, x1 + (length / 2), y1 - ((int) ((length / 2) * Math.sqrt (3))));
    g.drawLine (x1, y1, x1 - (length / 2), y1 - ((int) ((length / 2) * Math.sqrt (3))));
    g.drawLine (x1, y1, x1 - length, y1);
    g.drawLine (x1, y1, x1 - (length / 2), y1 + ((int) ((length / 2) * Math.sqrt (3))));
    g.drawLine (x1, y1, x1 + (length / 2), y1 + ((int) ((length / 2) * Math.sqrt (3))));
    int newLength = length / 2;
    if (newLength >= MIN_LENGTH) {
        drawFlake (x1 + length, y1, newLength, g);
        drawFlake (x1 + (length / 2), y1 - ((int) ((length / 2) * Math.sqrt (3))), newLength, g);
        drawFlake (x1 - (length / 2), y1 - ((int) ((length / 2) * Math.sqrt (3))), newLength, g);
        drawFlake (x1 - length, y1, newLength, g);
        drawFlake (x1 - (length / 2), y1 + ((int) ((length / 2) * Math.sqrt (3))), newLength, g);
        drawFlake (x1 + (length / 2), y1 + ((int) ((length / 2) * Math.sqrt (3))), newLength, g);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
290545_291993_29_57
290545_298148_77_96
Title: How to automatically copy data to new RMI threads? 
----------------------------------------

public void checkRead (String file) {
    super.checkRead (file);
    if (UNIX) {
        if (file == null) {
            throw new SecurityException ("file = NULL !!!");
        }
        String str_user = NativeRMISecurityManager.user.get ();
        if (str_user != null) {
            int ret = c_checkRead (file, str_user);
            if (ret != 0) {
                throw new SecurityException ("Access error: " + file);
            }
        }
    }
}
----------------------------------------

public void checkRead (String file) {
    super.checkRead (file);
    String str_user = (String) this.user.get ();
    if (unix && str_user != null) {
        if (file == null) {
            throw new SecurityException ("file = NULL !!!");
        }
        int ret = c_checkRead (file, str_user);
        if (ret != 0) {
            throw new SecurityException ("Erreur d'acces au fichier : " + file);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29058730_29058903_2_22
29058730_29058999_1_22
Title: Why does my bubble sort method not work? 
----------------------------------------

public static int [] sortlowhigh (int a []) {
    int i = 0;
    int j = 0;
    int temp = 0;
    while (j < (a.length - 1)) {
        i = 0;
        while (i < a.length - j - 1) {
            if (a [i] > a [i + 1]) {
                temp = a [i];
                a [i] = a [i + 1];
                a [i + 1] = temp;
            }
            i ++;
        }
        j ++;
    }
    return a;
}
----------------------------------------

public static int [] sortlowhigh (int a []) {
    int i = 0;
    int j = 0;
    int temp;
    while (j < (a.length - 1)) {
        i = 0;
        while (i < (a.length - j - 1)) {
            if (a [i] > a [i + 1]) {
                temp = a [i];
                a [i] = a [i + 1];
                a [i + 1] = temp;
            }
            i ++;
        }
        j ++;
    }
    return a;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29076439_29801090_1_35
29076439_29819001_1_47
Title: Java 8: Copy directory recursively? 
----------------------------------------

static private void copyFolder (File src, File dest) {
    if (src == null || dest == null) return;

    if (! src.isDirectory ()) return;

    if (dest.exists ()) {
        if (! dest.isDirectory ()) {
            return;
        }
    } else {
        dest.mkdir ();
    }
    if (src.listFiles () == null || src.listFiles ().length == 0) return;

    for (File file : src.listFiles ()) {
        File fileDest = new File (dest, file.getName ());
        if (file.isDirectory ()) {
            copyFolder (file, fileDest);
        } else {
            if (fileDest.exists ()) continue;

            try {
                Files.copy (file.toPath (), fileDest.toPath ());
            } catch (IOException e) {
            }
        }
    }
}
----------------------------------------

static void copyFolder (File src, File dest) {
    if (src == null || dest == null) return;

    if (! src.isDirectory ()) return;

    if (dest.exists ()) {
        if (! dest.isDirectory ()) {
            return;
        }
    } else {
        dest.mkdir ();
    }
    if (src.listFiles () == null || src.listFiles ().length == 0) return;

    String strAbsPathSrc = src.getAbsolutePath ();
    String strAbsPathDest = dest.getAbsolutePath ();
    try {
        Files.walkFileTree (src.toPath (), new SimpleFileVisitor < Path > () {
            @Override
            public FileVisitResult visitFile (Path file, BasicFileAttributes attrs) throws IOException {
                File dstFile = new File (strAbsPathDest + file.toAbsolutePath ().toString ().substring (strAbsPathSrc.length ()));
                if (dstFile.exists ()) return FileVisitResult.CONTINUE;

                if (! dstFile.getParentFile ().exists ()) dstFile.getParentFile ().mkdirs ();

                Files.copy (file, dstFile.toPath ());
                return FileVisitResult.CONTINUE;
            }}

        );
    } catch (IOException e) {
        return;
    }
    return;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29076439_29801090_1_35
29076439_34254130_1_17
Title: Java 8: Copy directory recursively? 
----------------------------------------

static private void copyFolder (File src, File dest) {
    if (src == null || dest == null) return;

    if (! src.isDirectory ()) return;

    if (dest.exists ()) {
        if (! dest.isDirectory ()) {
            return;
        }
    } else {
        dest.mkdir ();
    }
    if (src.listFiles () == null || src.listFiles ().length == 0) return;

    for (File file : src.listFiles ()) {
        File fileDest = new File (dest, file.getName ());
        if (file.isDirectory ()) {
            copyFolder (file, fileDest);
        } else {
            if (fileDest.exists ()) continue;

            try {
                Files.copy (file.toPath (), fileDest.toPath ());
            } catch (IOException e) {
            }
        }
    }
}
----------------------------------------

public void copyFolder (File src, File dest) throws IOException {
    try (Stream < Path > stream = Files.walk (src.toPath ())) {
        stream.forEach (sourcePath -> {
            try {
                Files.copy (sourcePath, src.toPath ().resolve (dest.toPath ().relativize (sourcePath)));
            } catch (Exception e) {
                e.printStackTrace ();
            }
        });
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29076439_29801090_1_35
29076439_46030326_1_19
Title: Java 8: Copy directory recursively? 
----------------------------------------

static private void copyFolder (File src, File dest) {
    if (src == null || dest == null) return;

    if (! src.isDirectory ()) return;

    if (dest.exists ()) {
        if (! dest.isDirectory ()) {
            return;
        }
    } else {
        dest.mkdir ();
    }
    if (src.listFiles () == null || src.listFiles ().length == 0) return;

    for (File file : src.listFiles ()) {
        File fileDest = new File (dest, file.getName ());
        if (file.isDirectory ()) {
            copyFolder (file, fileDest);
        } else {
            if (fileDest.exists ()) continue;

            try {
                Files.copy (file.toPath (), fileDest.toPath ());
            } catch (IOException e) {
            }
        }
    }
}
----------------------------------------

public static void copyFolder (Path src, Path dest) {
    try {
        Files.walk (src).forEach (s -> {
            try {
                Path d = dest.resolve (src.relativize (s));
                if (Files.isDirectory (s)) {
                    if (! Files.exists (d)) Files.createDirectory (d);

                    return;
                }
                Files.copy (s, d);
            } catch (Exception e) {
                e.printStackTrace ();
            }
        });
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29076439_29819001_1_47
29076439_34254130_1_17
Title: Java 8: Copy directory recursively? 
----------------------------------------

static void copyFolder (File src, File dest) {
    if (src == null || dest == null) return;

    if (! src.isDirectory ()) return;

    if (dest.exists ()) {
        if (! dest.isDirectory ()) {
            return;
        }
    } else {
        dest.mkdir ();
    }
    if (src.listFiles () == null || src.listFiles ().length == 0) return;

    String strAbsPathSrc = src.getAbsolutePath ();
    String strAbsPathDest = dest.getAbsolutePath ();
    try {
        Files.walkFileTree (src.toPath (), new SimpleFileVisitor < Path > () {
            @Override
            public FileVisitResult visitFile (Path file, BasicFileAttributes attrs) throws IOException {
                File dstFile = new File (strAbsPathDest + file.toAbsolutePath ().toString ().substring (strAbsPathSrc.length ()));
                if (dstFile.exists ()) return FileVisitResult.CONTINUE;

                if (! dstFile.getParentFile ().exists ()) dstFile.getParentFile ().mkdirs ();

                Files.copy (file, dstFile.toPath ());
                return FileVisitResult.CONTINUE;
            }}

        );
    } catch (IOException e) {
        return;
    }
    return;
}
----------------------------------------

public void copyFolder (File src, File dest) throws IOException {
    try (Stream < Path > stream = Files.walk (src.toPath ())) {
        stream.forEach (sourcePath -> {
            try {
                Files.copy (sourcePath, src.toPath ().resolve (dest.toPath ().relativize (sourcePath)));
            } catch (Exception e) {
                e.printStackTrace ();
            }
        });
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29076439_29819001_1_47
29076439_46030326_1_19
Title: Java 8: Copy directory recursively? 
----------------------------------------

static void copyFolder (File src, File dest) {
    if (src == null || dest == null) return;

    if (! src.isDirectory ()) return;

    if (dest.exists ()) {
        if (! dest.isDirectory ()) {
            return;
        }
    } else {
        dest.mkdir ();
    }
    if (src.listFiles () == null || src.listFiles ().length == 0) return;

    String strAbsPathSrc = src.getAbsolutePath ();
    String strAbsPathDest = dest.getAbsolutePath ();
    try {
        Files.walkFileTree (src.toPath (), new SimpleFileVisitor < Path > () {
            @Override
            public FileVisitResult visitFile (Path file, BasicFileAttributes attrs) throws IOException {
                File dstFile = new File (strAbsPathDest + file.toAbsolutePath ().toString ().substring (strAbsPathSrc.length ()));
                if (dstFile.exists ()) return FileVisitResult.CONTINUE;

                if (! dstFile.getParentFile ().exists ()) dstFile.getParentFile ().mkdirs ();

                Files.copy (file, dstFile.toPath ());
                return FileVisitResult.CONTINUE;
            }}

        );
    } catch (IOException e) {
        return;
    }
    return;
}
----------------------------------------

public static void copyFolder (Path src, Path dest) {
    try {
        Files.walk (src).forEach (s -> {
            try {
                Path d = dest.resolve (src.relativize (s));
                if (Files.isDirectory (s)) {
                    if (! Files.exists (d)) Files.createDirectory (d);

                    return;
                }
                Files.copy (s, d);
            } catch (Exception e) {
                e.printStackTrace ();
            }
        });
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29076439_34254130_1_17
29076439_46030326_1_19
Title: Java 8: Copy directory recursively? 
----------------------------------------

public void copyFolder (File src, File dest) throws IOException {
    try (Stream < Path > stream = Files.walk (src.toPath ())) {
        stream.forEach (sourcePath -> {
            try {
                Files.copy (sourcePath, src.toPath ().resolve (dest.toPath ().relativize (sourcePath)));
            } catch (Exception e) {
                e.printStackTrace ();
            }
        });
    }
}
----------------------------------------

public static void copyFolder (Path src, Path dest) {
    try {
        Files.walk (src).forEach (s -> {
            try {
                Path d = dest.resolve (src.relativize (s));
                if (Files.isDirectory (s)) {
                    if (! Files.exists (d)) Files.createDirectory (d);

                    return;
                }
                Files.copy (s, d);
            } catch (Exception e) {
                e.printStackTrace ();
            }
        });
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29078983_29079885_8_27
29078983_29081448_13_28
Title: How would I match a jumbled word from one array to it's correct spelling word in another array in Java? 
----------------------------------------

public static void main (String [] args) {
    List < Word > messed = new ArrayList < Word > ();
    messed.add (new Word ("aabann"));
    messed.add (new Word ("mosue"));
    messed.add (new Word ("atomich"));
    List < Word > correct = new ArrayList < Word > ();
    correct.add (new Word ("mouse"));
    messed.add (new Word ("athomic"));
    correct.add (new Word ("banana"));
    for (Word messedWord : messed) {
        System.out.println (messedWord.getOriginalWord ());
        for (Word correctWord : correct) {
            if (correctWord.compareTo (messedWord) == 0) {
                System.out.println (correctWord.getOriginalWord ());
            }
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    String [] correct = {"apple", "banana", "kiwi", "Abba"};
    String [] mixedup = {"aabann", "wiki", "plepa", "Baba"};
    Map < String, String > lookup = new HashMap < > (correct.length);
    for (String str : correct) {
        lookup.put (getKey (str), str);
    }
    for (String mix : mixedup) {
        String key = getKey (mix);
        String match = lookup.get (key);
        System.out.format ("%s = %s\n", mix, match);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29081538_29085522_149_157
29081538_29085522_55_75
Title: Java help. Slideshow with irregular intervals 
----------------------------------------

public void run () {
    while (running) {
        SSImage ssimage = imageArray [counter];
        ssviewer.setImage (ssimage.getImage ());
        repaint ();
        sleep (ssimage.getDelay ());
        counter = ++ counter % imageArray.length;
    }
}
----------------------------------------

public void run () {
    frame = new JFrame ("Check Box Test");
    frame.setDefaultCloseOperation (JFrame.DO_NOTHING_ON_CLOSE);
    frame.addWindowListener (new WindowAdapter () {
        @Override
        public void windowClosing (WindowEvent event) {
            exitProcedure ();
        }}

    );
    imageViewer = new SSViewer (700, 700);
    frame.add (imageViewer);
    frame.pack ();
    frame.setLocationByPlatform (true);
    frame.setVisible (true);
    showImages = new SSShower (imageArray, imageViewer);
    new Thread (showImages).start ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29081567_29084510_111_120
29081567_29084510_126_148
Title: How can I get this code for a GUI Countdown Timer to work properly? 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    String bname = e.getActionCommand ();
    if (bname.equals ("START")) {
        updateDisplay ();
    } else {
        jltime.setText (" ");
        timer.stop ();
        remaining = convertTime ();
    }
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    remaining = convertTime ();
    long current = System.currentTimeMillis ();
    long elapsed = current - initial;
    remaining -= elapsed;
    format = NumberFormat.getNumberInstance ();
    format.setMinimumIntegerDigits (2);
    if (remaining < 0) remaining = (long) 0;

    int minutes = (int) (remaining / 60000);
    int seconds = (int) ((remaining % 60000) / 1000);
    jltime.setText (format.format (minutes) + ":" + format.format (seconds));
    if (remaining == 0) {
        jltime.setText ("Stop");
        timer.stop ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2908307_2908442_1_15
2908307_2909643_1_13
Title: Is there a faster method then StringBuilder for a max 9-10 step string concatenation? 
----------------------------------------

private RatedMessage joinMessage (int step, boolean isresult) {
    sb.delete (0, sb.length ());
    for (int i = 0;
    i <= step; i ++) {
        if (mStack [i] == null) continue;

        rm = mStack [i].getCurrentMsg ();
        if (rm == null || rm.msg.length () == 0) continue;

        sb.append (rm.msg).append (", ");
    }
    if (sb.length () > 2) {
        sb.delete (sb.length () - 2, 2);
    }
    return sb.toString ();
}
----------------------------------------

private RatedMessage joinMessage (int step, boolean isresult) {
    StringBuilder builder = new StringBuilder ();
    for (int i = 0;
    i <= step; i ++) {
        WhateverTypeIsFromMStackVariable stackVariable = mStack [i];
        String message = getMessage (stackVariable);
        if (StringUtils.isNotEmpty (message)) {
            builder.append (message).append (", ");
        }
    }
    RatedMessage rm = new RatedMessage ();
    rm.msg = StringUtils.chomp (builder.toString (), ", ");
    return rm;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29084943_29085216_17_28
29084943_29085245_19_31
Title: Trouble with Swing components 
----------------------------------------

public DebugFourteen2 () {
    setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    setLayout (flow);
    payMethod.addItemListener (this);
    add (payList);
    add (payMethod);
    payMethod.addItem ("Credit card");
    payMethod.addItem ("Check");
    payMethod.addItem ("Cash");
    add (totFees);
}
----------------------------------------

public DebugFourteen2 () {
    setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    setLayout (flow);
    payMethod.addItemListener (this);
    add (payList);
    add (payMethod);
    payMethod.addItem ("Credit card");
    payMethod.addItem ("Check");
    payMethod.addItem ("Cash");
    add (totFees);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29085666_29085919_1_14
29085666_29086077_1_22
Title: Index 0 Requested with a size of 0 Error in SQLITE DB 
----------------------------------------

public String getDevName (String devid) {
    db = this.getWritableDatabase ();
    String name;
    String where = KEY_DEVID + " like '%" + devid + "%'";
    Cursor c = db.query (true, DATABASE_TABLE, ALL_KEYS, where, null, null, null, null, null);
    c.moveToFirst ();
    name = c.getString (COL_DEVICE);
    db.close ();
    return name;
}
----------------------------------------

public String getDevName (String devid) {
    db = myDBHelper.getWritableDatabase ();
    String name = null;
    String where = KEY_DEVID + " like ?";
    String [] selectionArgs = new String [] {"%" + devid + "%"};
    Cursor c = db.query (true, DATABASE_TABLE, ALL_KEYS, where, selectionArgs, null, null, null, null);
    if (c.moveToFirst ()) {
        name = c.getString (COL_DEVICE);
    }
    c.close ();
    db.close ();
    return name;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29089030_29089071_3_20
29089030_29089203_4_21
Title: "Java Object Array asking for two different inputs?" 
----------------------------------------

public static void main (String [] args) {
    Film [] f = new Film [10];
    Scanner input = new Scanner (System.in);
    for (int i = 0;
    i < 10; i ++) {
        f [i] = new Film ();
        System.out.println ("Enter Title:");
        f [i].setTitle (input.nextLine ());
        System.out.println ("Enter Film Length:");
        f [i].setLength (input.nextDouble ());
    }
    for (Film currentFilm : f) {
        System.out.println (currentFilm);
    }
}
----------------------------------------

public static void main (String [] args) {
    Film [] f = new Film [10];
    Scanner input = new Scanner (System.in);
    for (int i = 0;
    i < 10; i ++) {
        f [i] = new Film ();
        System.out.println ("Enter Title:");
        f [i].setTitle (input.next ());
        System.out.println ("Enter Film Length:");
        f [i].setLength (input.nextDouble ());
    }
    input.close ();
    for (int i = 0;
    i < 10; i ++) {
        System.out.println (f [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29091859_29092041_52_63
29091859_29099394_71_96
Title: Java - How to show an input dialog having a dropdown list with an icon for each item? 
----------------------------------------

public Component getListCellRendererComponent (JList < ? > list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
    System.out.println (value);
    super.getListCellRendererComponent (list, value, index, isSelected, cellHasFocus);
    if (value instanceof Car) {
        Car car = (Car) value;
        setIcon (car.getIcon ());
        setText (car.getText ());
    } else {
        setIcon (null);
    }
    return this;
}
----------------------------------------

public Component getListCellRendererComponent (JList list, Object selectedCarModel, int selectedModelIndex, boolean isSelected, boolean cellHasFocus) {
    String carModel = (String) selectedCarModel;
    String iconPath = "/images/" + carModel.toLowerCase () + ".png";
    URL iconURL = getClass ().getResource (iconPath);
    setText (carModel);
    setIcon (new ImageIcon (iconURL));
    setPreferredSize (new Dimension (list.getWidth (), 30));
    if (isSelected) {
        setBackground (list.getSelectionBackground ());
        setForeground (list.getSelectionForeground ());
    } else {
        setBackground (list.getBackground ());
        setForeground (list.getForeground ());
    }
    return this;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29095677_29098239_70_78
29095677_29098239_88_96
Title: Java - Improving Consumer Producer with MultiThreading using ConcurrentHashMap 
----------------------------------------

public void run () {
    try {
        while (true) {
            dataStore.putMessage ();
        }
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public void run () {
    try {
        while (true) {
            dataStore.removeMessage ();
        }
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29105410_29106081_1_49
29105410_29106090_2_19
Title: "Java reading from a text file (text file has a strange format)" 
----------------------------------------

public static void main (String [] args) {
    try {
        InputStreamReader in = new InputStreamReader (new FileInputStream ("D:/productData.txt"));
        BufferedReader buffer = new BufferedReader (in);
        String readline;
        int line_count = 0;
        int num_of_prod = 0;
        float [] prod_price = null;
        String [] prod_code = null;
        while ((readline = buffer.readLine ()) != null) {
            line_count ++;
            if (line_count == 1) {
                num_of_prod = Integer.parseInt (readline);
                prod_code = new String [num_of_prod];
                prod_price = new float [num_of_prod];
            } else if (line_count == 2) {
                prod_code = readline.split ("#");
            } else if (line_count == 3) {
                String [] string_price_arr = readline.split ("#");
                for (int i = 0;
                i < num_of_prod; i ++) prod_price [i] = Integer.parseInt (string_price_arr [i]);

            }

        }
        buffer.close ();
        System.out.println ("Product code");
        for (int i = 0;
        i < num_of_prod; i ++) {
            System.out.println (prod_code [i]);
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static final void main (String [] args) {
    String str = "10\n" + "PA/1234#PV/5732#Au/9271#DT/9489#HY/7195#ZR/7413#bT/4674#LR/4992#Xk/8536#kD/9767#\n" + "153#25#172#95#235#159#725#629#112#559#";
    String [] arr = str.split ("\n");
    ArrayList < Object [] > al = new ArrayList < > ();
    String [] product = arr [1].split ("#");
    String [] price = arr [2].split ("#");
    for (int i = 0;
    i < product.length; i ++) {
        al.add (new Object [] {product [i], Integer.parseInt (price [2])});
    }
    System.out.println (Arrays.deepToString (al.toArray ()));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29107210_29116763_12_21
29107210_29116763_26_35
Title: Handling Exception in java Piped Streams 
----------------------------------------

public Void call () {
    try {
        XML.toJson (bufferedXmlStream, jsonStream, true);
    } catch (Exception e) {
        e.printStackTrace ();
        throw e;
    }
    return null;
}
----------------------------------------

public Void call () {
    try {
        parseJsonStream (reader);
    } finally {
        reader.close ();
        jsonStream.close ();
    }
    return null;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29124723_29312556_27_109
29124723_29326127_13_44
Title: JavaFX Chart Auto-Scaling Wrong with Low Numbers 
----------------------------------------

public void start (final Stage stage) {
    stage.setTitle ("Bar Chart Sample");
    sbc.setAnimated (true);
    final Button updateButton = new Button ("update");
    updateButton.setOnAction (new EventHandler < ActionEvent > () {
        @Override
        public void handle (final ActionEvent arg0) {
            updateChart ();
        }}

    );
    final Button clearButton = new Button ("Clear");
    clearButton.setOnAction (new EventHandler < ActionEvent > () {
        @Override
        public void handle (final ActionEvent arg0) {
            clearChart (true);
        }}

    );
    final Button clearAndUpdateButton = new Button ("Clear & Update");
    clearAndUpdateButton.setOnAction (new EventHandler < ActionEvent > () {
        @Override
        public void handle (final ActionEvent evt) {
            clearChart (true);
            updateChart ();
        }}

    );
    final Button clearAndUpdateLaterButton = new Button ("Clear & Update Later");
    clearAndUpdateLaterButton.setOnAction (new EventHandler < ActionEvent > () {
        @Override
        public void handle (final ActionEvent evt) {
            clearChart (true);
            new Timer (true).schedule (new TimerTask () {
                @Override
                public void run () {
                    Platform.runLater (() -> updateChart ());
                }}

            , 1000);
        }}

    );
    final Button clearNoAnimAndUpdateButton = new Button ("Clear (no anim) & Update");
    clearNoAnimAndUpdateButton.setOnAction (new EventHandler < ActionEvent > () {
        @Override
        public void handle (final ActionEvent evt) {
            clearChart (false);
            updateChart ();
        }}

    );
    final VBox contentPane = new VBox ();
    contentPane.getChildren ().addAll (sbc, clearButton, updateButton, clearAndUpdateButton, clearAndUpdateLaterButton, clearNoAnimAndUpdateButton);
    final Scene scene = new Scene (contentPane, 800, 600);
    stage.setScene (scene);
    stage.show ();
    xAxis.setCategories (FXCollections.< String > observableArrayList (Arrays.asList ("one", "two", "three")));
}
----------------------------------------

public void start (Stage stage) {
    stage.setTitle ("Bar Chart Sample");
    sbc.setAnimated (true);
    Button createButton = new Button ("Create");
    createButton.setOnAction (new EventHandler < ActionEvent > () {
        @Override
        public void handle (ActionEvent arg0) {
            createChartData ();
        }}

    );
    Button modifyButton = new Button ("Modify");
    modifyButton.setOnAction (new EventHandler < ActionEvent > () {
        @Override
        public void handle (ActionEvent arg0) {
            modifyChartData ();
        }}

    );
    VBox contentPane = new VBox ();
    contentPane.getChildren ().addAll (sbc, createButton, modifyButton);
    Scene scene = new Scene (contentPane, 800, 600);
    stage.setScene (scene);
    stage.show ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29127884_41505914_6_20
29127884_47635502_4_13
Title: how to calculate the length of a string without spaces in java 
----------------------------------------

public static void main (String arg []) {
    int sum = 0;
    Scanner s = new Scanner (System.in);
    System.out.println ("please enter string");
    String val = s.nextLine ();
    int len = val.length ();
    for (int i = 0;
    i < len; i ++) {
        if (val.charAt (i) == ' ') {
            continue;
        }
        sum ++;
    }
    System.out.println (sum);
}
----------------------------------------

public static void main (String [] args) {
    System.out.println ("Entered a string ");
    Scanner sc = new Scanner (System.in);
    String originalString = sc.nextLine ();
    System.out.println ("Entered string is " + originalString);
    String newString = originalString.replaceAll (" ", "");
    System.out.println ("New string after removing spaces is " + newString);
    System.out.println ("Number of characters in string are " + newString.length ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29134838_29138768_39_53
29134838_29138768_55_71
Title: JavaFX memory leak in TableView with dynamic TableColumns 
----------------------------------------

private void addData (TableView table, int iterations) {
    for (int i = 0;
    i < iterations; i ++) {
        final int index = i;
        addData (table);
        System.gc ();
        System.out.println (index + ": free: " + Runtime.getRuntime ().freeMemory () / 1024 + " kb, max: " + Runtime.getRuntime ().maxMemory () / 1024 + " kb");
    }
}
----------------------------------------

private void addData (TableView table) {
    table.getItems ().clear ();
    table.getColumns ().clear ();
    for (int col = 0;
    col < columns; col ++) {
        table.getColumns ().add (createColumn (col));
    }
    for (int row = 0;
    row < rows; row ++) {
        ObservableList < StringProperty > data = FXCollections.observableArrayList ();
        for (int col = 0;
        col < columns; col ++) {
            data.add (new SimpleStringProperty (String.valueOf (row + " / " + col)));
        }
        table.getItems ().add (data);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29149945_29150103_4_17
29149945_29150118_5_29
Title: Fibonacci using array 
----------------------------------------

public static void main (String args []) {
    long array [] = new long [100];
    array [0] = 0;
    array [1] = 1;
    for (int i = 2;
    i < 100; i ++) {
        array [i] = array [i - 1] + array [i - 2];
    }
    for (int i = 0;
    i < 100; ++ i) {
        System.out.print (array [i] + " ");
    }
}
----------------------------------------

public static void main (String [] args) {
    int element = 0;
    String result;
    do {
        result = JOptionPane.showInputDialog ("Insert a number.\n " + "Exit = -1");
        element = Integer.parseInt (result);
    } while (element < - 1 && element != - 1);
    int before = 0;
    int now = 1;
    int next = 1;
    System.out.print ("0, ");
    for (int i = 0;
    i < element - 1; i ++) {
        System.out.print (next + ", ");
        next = now + before;
        before = now;
        now = next;
    }
    System.out.println ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29162796_29163469_159_175
29162796_29163469_163_173
Title: For Loop looping through all 
----------------------------------------

public void run () {
    handler.post (new Runnable () {
        public void run () {
            v = lstView.getChildAt (position - lstView.getFirstVisiblePosition ());
            holder = (ViewHolder) v.getTag ();
            synchronized (this) {
                ImageList.get (position).setStatusEnable (false);
                mAdapter.notifyDataSetChanged ();
            }
            new UploadFileAsync ().execute (String.valueOf (position));
        }}

    );
}
----------------------------------------

public void run () {
    v = lstView.getChildAt (position - lstView.getFirstVisiblePosition ());
    holder = (ViewHolder) v.getTag ();
    synchronized (this) {
        ImageList.get (position).setStatusEnable (false);
        mAdapter.notifyDataSetChanged ();
    }
    new UploadFileAsync ().execute (String.valueOf (position));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29171643_31518996_107_123
29171643_31518996_63_77
Title: Java Tor Lib : How to setup Orchid Tor Lib with Java? 
----------------------------------------

public void run () {
    try {
        Socket socket = client.getSocketFactory ().createSocket ("www.google.com", 80);
        PrintWriter writer = new PrintWriter (socket.getOutputStream (), true);
        BufferedReader reader = new BufferedReader (new InputStreamReader (socket.getInputStream ()));
        writer.println ("GET /");
        String line;
        System.out.println ("testOrchidUsingSocket: ");
        while ((line = reader.readLine ()) != null) {
            System.out.println (line);
        }
        socket.close ();
    } catch (Exception ex) {
        Logger.getLogger (OrchidDemo.class.getName ()).log (Level.SEVERE, null, ex);
    }
}
----------------------------------------

public void run () {
    try {
        URL url = new URL ("https://wtfismyip.com/");
        Proxy proxy = new Proxy (Proxy.Type.SOCKS, new InetSocketAddress ("localhost", 9150));
        HttpURLConnection uc = (HttpURLConnection) url.openConnection (proxy);
        uc.setConnectTimeout (10000);
        Document document = Jsoup.parse (IOUtils.toString (uc.getInputStream ()));
        String result = document.select ("div[id=tor").text ();
        System.out.println ("testOrchidUsingProxyObject: " + result);
    } catch (Exception ex) {
        Logger.getLogger (OrchidDemo.class.getName ()).log (Level.SEVERE, null, ex);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29171643_31518996_107_123
29171643_31518996_85_99
Title: Java Tor Lib : How to setup Orchid Tor Lib with Java? 
----------------------------------------

public void run () {
    try {
        Socket socket = client.getSocketFactory ().createSocket ("www.google.com", 80);
        PrintWriter writer = new PrintWriter (socket.getOutputStream (), true);
        BufferedReader reader = new BufferedReader (new InputStreamReader (socket.getInputStream ()));
        writer.println ("GET /");
        String line;
        System.out.println ("testOrchidUsingSocket: ");
        while ((line = reader.readLine ()) != null) {
            System.out.println (line);
        }
        socket.close ();
    } catch (Exception ex) {
        Logger.getLogger (OrchidDemo.class.getName ()).log (Level.SEVERE, null, ex);
    }
}
----------------------------------------

public void run () {
    try {
        System.setProperty ("socksProxyHost", "127.0.0.1");
        System.setProperty ("socksProxyPort", "9150");
        Document document = Jsoup.connect ("https://wtfismyip.com/").get ();
        String result = document.select ("div[id=tor").text ();
        System.out.println ("testOrchidUsingSystemPropsProxy: " + result);
        System.setProperty ("socksProxyHost", "");
        System.setProperty ("socksProxyPort", "");
    } catch (Exception ex) {
        Logger.getLogger (OrchidDemo.class.getName ()).log (Level.SEVERE, null, ex);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29171643_31518996_63_77
29171643_31518996_85_99
Title: Java Tor Lib : How to setup Orchid Tor Lib with Java? 
----------------------------------------

public void run () {
    try {
        URL url = new URL ("https://wtfismyip.com/");
        Proxy proxy = new Proxy (Proxy.Type.SOCKS, new InetSocketAddress ("localhost", 9150));
        HttpURLConnection uc = (HttpURLConnection) url.openConnection (proxy);
        uc.setConnectTimeout (10000);
        Document document = Jsoup.parse (IOUtils.toString (uc.getInputStream ()));
        String result = document.select ("div[id=tor").text ();
        System.out.println ("testOrchidUsingProxyObject: " + result);
    } catch (Exception ex) {
        Logger.getLogger (OrchidDemo.class.getName ()).log (Level.SEVERE, null, ex);
    }
}
----------------------------------------

public void run () {
    try {
        System.setProperty ("socksProxyHost", "127.0.0.1");
        System.setProperty ("socksProxyPort", "9150");
        Document document = Jsoup.connect ("https://wtfismyip.com/").get ();
        String result = document.select ("div[id=tor").text ();
        System.out.println ("testOrchidUsingSystemPropsProxy: " + result);
        System.setProperty ("socksProxyHost", "");
        System.setProperty ("socksProxyPort", "");
    } catch (Exception ex) {
        Logger.getLogger (OrchidDemo.class.getName ()).log (Level.SEVERE, null, ex);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29179453_29180448_5_42
29179453_29181216_1_23
Title: How to extract noun phrases from the parsed text 
----------------------------------------

public static void main (String [] args) throws IOException {
    ArrayList < String > npList = new ArrayList < String > ();
    String line = "";
    String line1 = "";
    String Input = "/local/Input/Temp/Temp.txt";
    String Output = "/local/Output/Temp/Temp-out.txt";
    FileInputStream fis = new FileInputStream (Input);
    BufferedReader br = new BufferedReader (new InputStreamReader (fis, "UTF-8"));
    while ((line = br.readLine ()) != null) {
        char [] lineArray = line.toCharArray ();
        int temp;
        for (int i = 0;
        i + 2 < lineArray.length; i ++) {
            if (lineArray [i] == '(' && lineArray [i + 1] == 'N' && lineArray [i + 2] == 'P') {
                temp = i;
                while (lineArray [i] != ')') {
                    i ++;
                }
                i += 2;
                line1 = line.substring (temp, i);
                npList.add (line1);
            }
        }
        npList.add ("*");
    }
    for (int i = 0;
    i < npList.size (); i ++) {
        if (! (npList.get (i).equals ("*"))) {
            System.out.print (npList.get (i));
            if (i < npList.size () - 1 && npList.get (i + 1).equals ("*")) {
                System.out.println ();
            }
        }
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    ArrayList < String > npList = new ArrayList < String > ();
    String line;
    String Input = "/local/Input/Temp/Temp.txt";
    String Output = "/local/Output/Temp/Temp-out.txt";
    FileInputStream fis = new FileInputStream (Input);
    BufferedReader br = new BufferedReader (new InputStreamReader (fis, "UTF-8"));
    while ((line = br.readLine ()) != null) {
        int indexOfNP = line.indexOf ("(NP");
        if (indexOfNP >= 0) extractNPs (npList, line, indexOfNP);

    }
    for (String npString : npList) {
        System.out.println (npString);
    }
    br.close ();
    fis.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29199379_29199432_1_13
29199379_29199457_1_10
Title: Boolean method is not checking if statment 
----------------------------------------

public boolean addPresent (Present present) {
    boolean r = false;
    if (totWeight + present.getWeight () <= maxWeight) {
        presents.add (present);
        presents1.add (present);
        r = true;
    }
    totWeight = 0;
    for (Present pres : presents1) {
        totWeight += pres.getWeight ();
    }
    return r;
}
----------------------------------------

public boolean addPresent (Present present) {
    if (totWeight + present.getWeight () <= maxWeight) {
        presents.add (present);
        presents1.add (present);
        totWeight += present.getWeight ();
        return true;
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29201739_29201971_1_11
29201739_29202065_1_11
Title: Using recursion in java to find the next double in an array? 
----------------------------------------

private int doubleFinder (int data [], int low, int high, int count) {
    if (low == high) {
        return count;
    } else {
        if (data [high - 1] * 2 == data [high]) {
            count ++;
        }
        return doubleFinder (data, low, high - 1, count);
    }
}
----------------------------------------

private int doubleFinder (int data [], int index) {
    if (index <= 0) {
        return 0;
    } else {
        if (data [index] == 2 * data [index - 1]) return doubleFinder (data, index - 1) + 1;
        else {
            doubleFinder (data, index - 1)
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29202044_29202068_1_12
29202044_29205593_1_26
Title: Sorting numbers with user input in an array Java 
----------------------------------------

public static void main (String [] args) {
    System.out.print ("How many numbers: ");
    int num = IO.readInt ();
    double array [] = new double [num];
    for (int j = 0;
    j < num; j ++) {
        System.out.printf ("Please enter double %d:%n", j + 1);
        array [j] = IO.readDouble ();
    }
    System.out.println ("unsorted array: " + Arrays.toString (array));
    Arrays.sort (array);
    System.out.println ("sorted array: " + Arrays.toString (array));
}
----------------------------------------

public static void main (String [] args) {
    System.out.print ("How many numbers: ");
    int num = IO.readInt ();
    double array [] = new double [num];
    for (int i = 0;
    i < num; i ++) {
        System.out.print ("[" + i + "]Please enter your double");
        array [i] = IO.readDouble ();
    }
    double temp = 0;
    for (int i = 0;
    i < num - 1; i ++) {
        for (int j = i + 1;
        j < num; j ++) {
            if (array [j] > array [j]) {
                temp = array [i];
                array [i] = array [j];
                array [j] = temp;
            }
        }
    }
    for (int i = 0;
    i < array.length; i ++) {
        System.out.print (array [i] + " ");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29203382_29203486_1_25
29203382_29203552_1_28
Title: Java Array moving elements 
----------------------------------------

public static void main (String [] args) {
    int numbers [] = new int [] {32, 43, 53, 54, 32, 65, 63, 98, 43, 23};
    int tmp = 0;
    int largetst = numbers [0];
    for (int i = 1;
    i < numbers.length; i ++) {
        if (numbers [i] > largetst) {
            largetst = numbers [i];
        }
    }
    for (int i = 1;
    i < numbers.length; i ++) {
        if (largetst == numbers [i]) {
            tmp = numbers [0];
            numbers [0] = largetst;
            numbers [i] = tmp;
        }
    }
    System.out.println ("Numbers : " + numbers [0]);
}
----------------------------------------

public static void main (String [] args) {
    int numbers [] = new int [] {32, 43, 53, 54, 32, 65, 663, 98, 43, 23};
    int smallest = numbers [0];
    int largest = numbers [0];
    int indexOfLargestNumber = 0;
    for (int i = 1;
    i < numbers.length; i ++) {
        if (numbers [i] > largest) {
            indexOfLargestNumber = i;
            largest = numbers [i];
        }
    }
    int temp = numbers [0];
    numbers [0] = largest;
    numbers [indexOfLargestNumber] = temp;
    for (int i = 0;
    i < numbers.length; i ++) {
        System.out.print (numbers [i] + "  ");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29203382_29203486_1_25
29203382_29203574_1_20
Title: Java Array moving elements 
----------------------------------------

public static void main (String [] args) {
    int numbers [] = new int [] {32, 43, 53, 54, 32, 65, 63, 98, 43, 23};
    int tmp = 0;
    int largetst = numbers [0];
    for (int i = 1;
    i < numbers.length; i ++) {
        if (numbers [i] > largetst) {
            largetst = numbers [i];
        }
    }
    for (int i = 1;
    i < numbers.length; i ++) {
        if (largetst == numbers [i]) {
            tmp = numbers [0];
            numbers [0] = largetst;
            numbers [i] = tmp;
        }
    }
    System.out.println ("Numbers : " + numbers [0]);
}
----------------------------------------

public static void main (String [] args) {
    int numbers [] = new int [] {32, 43, 53, 54, 32, 65, 63, 98, 43, 23};
    int tmp;
    for (int i = 1;
    i < numbers.length; i ++) {
        if (numbers [i] > numbers [0]) {
            tmp = numbers [0];
            numbers [0] = numbers [i];
            numbers [i] = tmp;
        }
    }
    System.out.println ("Largest number : " + numbers [0]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29203382_29203552_1_28
29203382_29203574_1_20
Title: Java Array moving elements 
----------------------------------------

public static void main (String [] args) {
    int numbers [] = new int [] {32, 43, 53, 54, 32, 65, 663, 98, 43, 23};
    int smallest = numbers [0];
    int largest = numbers [0];
    int indexOfLargestNumber = 0;
    for (int i = 1;
    i < numbers.length; i ++) {
        if (numbers [i] > largest) {
            indexOfLargestNumber = i;
            largest = numbers [i];
        }
    }
    int temp = numbers [0];
    numbers [0] = largest;
    numbers [indexOfLargestNumber] = temp;
    for (int i = 0;
    i < numbers.length; i ++) {
        System.out.print (numbers [i] + "  ");
    }
}
----------------------------------------

public static void main (String [] args) {
    int numbers [] = new int [] {32, 43, 53, 54, 32, 65, 63, 98, 43, 23};
    int tmp;
    for (int i = 1;
    i < numbers.length; i ++) {
        if (numbers [i] > numbers [0]) {
            tmp = numbers [0];
            numbers [0] = numbers [i];
            numbers [i] = tmp;
        }
    }
    System.out.println ("Largest number : " + numbers [0]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29211523_29211689_62_99
29211523_29212130_80_99
Title: getcontentresolver() is undefined for the type 
----------------------------------------

public void onActivityResult (int requestCode, int resultCode, Intent data) {
    super.onActivityResult (requestCode, resultCode, data);
    if (resultCode == Activity.RESULT_OK) {
        if (requestCode == REQUEST_CAMERA) {
            File f = new File (Environment.getExternalStorageDirectory ().toString ());
            for (File temp : f.listFiles ()) {
                if (temp.getName ().equals ("temp.jpg")) {
                    f = temp;
                    break;
                }
            }
            try {
                Bitmap bm;
                BitmapFactory.Options btmapOptions = new BitmapFactory.Options ();
                bm = BitmapFactory.decodeFile (f.getAbsolutePath (), btmapOptions);
                bm = Bitmap.createScaledBitmap (bm, 70, 70, true);
                iv_photo.setImageBitmap (bm);
                uploadImagePath = f.getAbsolutePath ();
            } catch (Exception e) {
                e.printStackTrace ();
            }
        } else if (requestCode == SELECT_FILE) {
            Uri selectedImageUri = data.getData ();
            String tempPath = getPath (selectedImageUri, getActivity ());
            Bitmap bm;
            BitmapFactory.Options btmapOptions = new BitmapFactory.Options ();
            bm = BitmapFactory.decodeFile (tempPath, btmapOptions);
            iv_photo.setImageBitmap (bm);
            uploadImagePath = tempPath;
        }

    }
}
----------------------------------------

public void onActivityResult (int requestCode, int resultCode, Intent data) {
    super.onActivityResult (requestCode, resultCode, data);
    switch (requestCode) {
        case 1 :
            if (resultCode == RESULT_OK) {
                Uri uri = data.getData ();
                String [] projection = {MediaStore.Images.Media.DATA};
                Cursor cursor = getActivity ().getApplicationContext ().getContentResolver ().query (uri, projection, null, null, null);
                cursor.moveToFirst ();
                int columnIndex = cursor.getColumnIndex (projection [0]);
                String filePath = cursor.getString (columnIndex);
                cursor.close ();
                Bitmap yourSelectedImage = BitmapFactory.decodeFile (filePath);
                Drawable d = new BitmapDrawable (yourSelectedImage);
                imageview.setBackground (d);
            }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29211523_29211689_7_28
29211523_29212130_64_77
Title: getcontentresolver() is undefined for the type 
----------------------------------------

public View onCreateView (LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View rootView = inflater.inflate (R.layout.edit_profile_fragment, container, false);
    bt_browse = (Button) rootView.findViewById (R.id.bt_browse);
    bt_browse.setOnClickListener (new OnClickListener () {
        @Override
        public void onClick (View v) {
            selectImage ();
        }}

    );
    return rootView;
}
----------------------------------------

public View onCreateView (LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    setHasOptionsMenu (true);
    View rootView = inflater.inflate (R.layout.fragment_action_bar_icon_update, container, false);
    imageview = (ImageView) rootView.findViewById (R.id.imageview);
    buttonclick = (Button) rootView.findViewById (R.id.buttonclick);
    buttonclick.setOnClickListener (new View.OnClickListener () {
        @Override
        public void onClick (View view) {
            btnClick ();
        }}

    );
    return rootView;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29218769_29226345_12_25
29218769_29226345_1_10
Title: JAVA:Catching exception when unit testing and parameter parsing 
----------------------------------------

@Test
public void testToString () {
    System.out.println ("toString");
    try {
        Address add = new Address ("Blackthorn", "Kings Lynn", "PE30");
        BusinessOrganisationDetails instance = new BusinessOrganisationDetails ("PEA-1234", "Smith", add, 10, "EA", 12);
        String expResult = "";
        String result = instance.toString ();
        assertEquals (expResult, result);
    } catch (BusinessOrganisationDetails e) {
        fail (e.getMessage);
    }
}
----------------------------------------

@Test
public void testToString () throws IllegalCustomerIDException {
    System.out.println ("toString");
    Address add = new Address ("Blackthorn", "Kings Lynn", "PE30");
    BusinessOrganisationDetails instance = new BusinessOrganisationDetails ("PEA-1234", "Smith", add, 10, "EA", 12);
    String expResult = "";
    String result = instance.toString ();
    assertEquals (expResult, result);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29237503_29237759_35_51
29237503_29237759_62_93
Title: "In java is there any way to connect to other host by TCP/IP without ""while(true)""" 
----------------------------------------

public void completed (AsynchronousSocketChannel client, Attachment attach) {
    try {
        SocketAddress clientAddr = client.getRemoteAddress ();
        System.out.format ("Accepted a  connection from  %s%n", clientAddr);
        attach.server.accept (attach, this);
        ReadWriteHandler rwHandler = new ReadWriteHandler ();
        Attachment newAttach = new Attachment ();
        newAttach.server = attach.server;
        newAttach.client = client;
        newAttach.buffer = ByteBuffer.allocate (2048);
        newAttach.isRead = true;
        newAttach.clientAddr = clientAddr;
        client.read (newAttach.buffer, newAttach, rwHandler);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public void completed (Integer result, Attachment attach) {
    if (result == - 1) {
        try {
            attach.client.close ();
            System.out.format ("Stopped   listening to the   client %s%n", attach.clientAddr);
        } catch (IOException ex) {
            ex.printStackTrace ();
        }
        return;
    }
    if (attach.isRead) {
        attach.buffer.flip ();
        int limits = attach.buffer.limit ();
        byte bytes [] = new byte [limits];
        attach.buffer.get (bytes, 0, limits);
        Charset cs = Charset.forName ("UTF-8");
        String msg = new String (bytes, cs);
        System.out.format ("Client at  %s  says: %s%n", attach.clientAddr, msg);
        attach.isRead = false;
        attach.buffer.rewind ();
    } else {
        attach.client.write (attach.buffer, attach, this);
        attach.isRead = true;
        attach.buffer.clear ();
        attach.client.read (attach.buffer, attach, this);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29239719_29240067_1_61
29239719_29240792_1_15
Title: Trying to make an encryption method with if-statements 
----------------------------------------

static String encrypt (String data) {
    String returned = new String ("");
    for (char h : data.toCharArray ()) {
        if (h == 'a') returned += " a', 'c";

        if (h == 'b') returned += "d";

        if (h == 'c') returned += "e";

        if (h == 'd') returned += "f";

        if (h == 'e') returned += "g";

        if (h == 'f') returned += "h";

        if (h == 'g') returned += "i";

        if (h == 'h') returned += "j";

        if (h == 'i') returned += "k";

        if (h == 'j') returned += "l";

        if (h == 'k') returned += "m";

        if (h == 'l') returned += "n";

        if (h == 'm') returned += "o";

        if (h == 'n') returned += "p";

        if (h == 'o') returned += "q";

        if (h == 'p') returned += "r";

        if (h == 'q') returned += "s";

        if (h == 'r') returned += "t";

        if (h == 's') returned += "u";

        if (h == 't') returned += "v";

        if (h == 'u') returned += "w";

        if (h == 'v') returned += "x";

        if (h == 'w') returned += "y";

        if (h == 'x') returned += "z";

        if (h == 'y') returned += "a";

        if (h == 'z') returned += "b";

    }
    return returned;
}
----------------------------------------

static String encrypt (String data) {
    String encrypted = new String ("");
    for (char c : data.toCharArray ()) {
        char newC = c + 2;
        if (newC > 'z') newC -= 26;

        encrypted += newC;
    }
    return encrpyted;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29252702_29253115_1_24
29252702_31181543_10_20
Title: Turning a text file into a 2d array in Java 
----------------------------------------

public static void main (String [] args) throws IOException {
    URL source = new File ("src/EnglishResults06-12Citywide.csv").toPath ().toUri ().toURL ();
    Scanner in = new Scanner (source.openStream ());
    if (! in.hasNextLine ()) {
        System.err.println ("Missing headline!");
        System.exit (1);
    }
    String headLine = in.nextLine ();
    String [] fieldNames = headLine.split (",");
    List < String [] > data = new ArrayList < > ();
    while (in.hasNextLine ()) {
        String line = in.nextLine ();
        String [] frags = line.split (",");
        data.add (frags);
    }
    in.close ();
    String [] [] dataArray = data.toArray (new String [data.size ()] []);
    System.out.println ("Field names: " + Arrays.toString (fieldNames));
    System.out.println ("Data array: " + Arrays.deepToString (dataArray));
}
----------------------------------------

public static void main (String args []) throws Exception {
    Reader r = new FileReader ("input.csv");
    MultiLevelCSVParser parser = new MultiLevelCSVParser ();
    JSONObject jso = (JSONObject) parser.parse ("jso", r, false);
    String ex_str = parser.ex.get_all_exceptions ();
    if (ex_str.equals ("")) {
        JSONArray rows = (JSONArray) jso.get ("n1");
        System.out.println (((JSONObject) rows.get (0)).get ("c1"));
    } else System.out.println (ex_str);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29255865_29256170_1_10
29255865_36017178_1_13
Title: How to insert multiple strings into a sqlite table using dbadapter 
----------------------------------------

public void insertTxData (String inputparticulars, String inputamount) {
    SQLiteDatabase db = helper.getWritableDatabase ();
    ContentValues contentvalues = new ContentValues ();
    contentvalues.put (VivzHelper.TX_PARTICULARS, inputparticulars);
    contentvalues.put (VivzHelper.TX_AMOUNT, inputamount);
    contentvalues.put (VivzHelper.TX_DATE, Calendar.DATE);
    db.insert (VivzHelper.TX_TABLE, null, contentvalues);
    db.insert (VivzHelper.TX_AMOUNT, null, inputamount);
}
----------------------------------------

public long insertTxData (String [] inputs) {
    SQLiteDatabase db = helper.getWritableDatabase ();
    ContentValues contentvalues = new ContentValues ();
    contentvalues.put (VivzHelper.TX_PARTICULARS, inputs [0]);
    contentvalues.put (VivzHelper.TX_AMOUNT, inputs [1]);
    contentvalues.put (VivzHelper.TX_DATE, Calendar.DATE);
    long id = db.insert (VivzHelper.TX_TABLE, null, contentvalues);
    return id;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29264182_29264355_1_16
29264182_29264511_1_20
Title: Deleting specific elements from an array 
----------------------------------------

static int [] greaterThan (int [] list, int v) {
    int [] greaterThanV = new int [list.length];
    int numGreater = 0;
    for (int i = 0;
    i < list.length; i ++) {
        int value = list [i];
        if (value > v) {
            greaterThanV [numGreater ++] = value;
        }
    }
    return Arrays.copyOf (greaterThanV, numGreater);
}
----------------------------------------

public static int [] greaterThan (int [] list, int v) {
    int n = list.length;
    int [] x = new int [n];
    int counter = 0;
    for (int i = 0;
    i < n; i ++) {
        int value = list [i];
        if (value > v) {
            x [counter] = value;
            counter ++;
        }
    }
    return x;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29272724_29272761_1_22
29272724_29272769_1_23
Title: How do I correct errors on my 'save to file' button in netbeans? 
----------------------------------------

private void btnFileSaveActionPerformed (java.awt.event.ActionEvent evt) {
    try {
        BufferedWriter bfw = new BufferedWriter (new FileWriter ("D:\\CedulaList.txt"));
        for (int i = 0;
        i < tableCedula.getRowCount (); i ++) {
            for (int j = 0;
            j < tableCedula.getColumnCount (); j ++) {
                bfw.newLine ();
                bfw.write ((String) (tableCedula.getValueAt (i, j)));
                bfw.write ("\t");
            }
        }
        bfw.close ();
    } catch (IOException e) {
    }
}
----------------------------------------

private void btnFileSaveActionPerformed (java.awt.event.ActionEvent evt) {
    try {
        BufferedWriter bfw = new BufferedWriter (new FileWriter ("D:\\CedulaList.txt"));
        for (int i = 0;
        i < tableCedula.getRowCount (); i ++) {
            for (int j = 0;
            j < tableCedula.getColumnCount (); j ++) {
                bfw.newLine ();
                bfw.write ((String) (tableCedula.getValueAt (i, j)));
                bfw.write ("\t");
            }
        }
    } catch (Exception ex) {
    } finally {
        if (bfw != null) {
            bfw.close ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29280857_29281389_1_18
29280857_29282150_1_10
Title: Java synchronisation: atomically moving money across account pairs? 
----------------------------------------

public boolean transfer (Account from, Account to, BigDecimal amount) {
    boolean success = false;
    boolean withdrawn = false;
    try {
        if (from.withdraw (amount)) {
            withdrawn = true;
            if (to.deposit (amount)) {
                success = true;
            }
        }
    } finally {
        if (withdrawn && ! success) {
            from.deposit (amount);
        }
    }
    return success;
}
----------------------------------------

public void transfer (Account acc1, Account acc2, BigDecimal value) {
    Object lock1 = acc1.ID < acc2.ID ? acc1.LOCK : acc2.LOCK;
    Object lock2 = acc1.ID < acc2.ID ? acc2.LOCK : acc1.LOCK;
    synchronized (lock1) {
        synchronized (lock2) {
            acc1.widrawal (value);
            acc2.send (value);
        }
    }
}
----------------------------------------
