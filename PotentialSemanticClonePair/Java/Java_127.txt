$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
539567_539629_12_32
539567_546195_5_61
Title: java swing - layout oddness when using different layout managers 
----------------------------------------

public static void main (String [] args) {
    JFrame frame = new JFrame ();
    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    JPanel panel = new JPanel (new FlowLayout (FlowLayout.CENTER, 0, 5));
    panel.add (createButton ("F I R S T"));
    panel.add (createButton ("S E C O N D"));
    panel.add (createButton ("T H I R D "));
    frame.add (panel, BorderLayout.NORTH);
    frame.pack ();
    frame.setVisible (true);
}
----------------------------------------

public static void main (String [] args) {
    try {
        UIManager.setLookAndFeel (UIManager.getSystemLookAndFeelClassName ());
    } catch (Exception e) {
    }
    JFrame frame = new JFrame ("x");
    Container y = frame.getContentPane ();
    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    y.setLayout (new FlowLayout ());
    JPanel uberButton = new JPanel ();
    uberButton.setLayout (null);
    uberButton.setSize (98, 32);
    uberButton.setPreferredSize (new Dimension (98, 32));
    JButton record = new JButton (new ImageIcon ("img/record.png"));
    record.setBounds (0, 0, 40, 32);
    record.setEnabled (true);
    record.setFocusPainted (false);
    JPanel _record = new JPanel ();
    _record.setLayout (null);
    _record.setBounds (0, 0, 33, 32);
    JButton pause = new JButton (new ImageIcon ("img/pause.png"));
    pause.setBounds (- 4, 0, 44, 32);
    pause.setEnabled (true);
    pause.setFocusPainted (false);
    JPanel _pause = new JPanel ();
    _pause.setLayout (null);
    _pause.setBounds (33, 0, 33, 32);
    JButton stop = new JButton (new ImageIcon ("img/stop.png"));
    stop.setBounds (- 4, 0, 36, 32);
    stop.setEnabled (true);
    stop.setFocusPainted (false);
    JPanel _stop = new JPanel ();
    _stop.setLayout (null);
    _stop.setBounds (66, 0, 32, 32);
    _record.add (record);
    _pause.add (pause);
    _stop.add (stop);
    uberButton.add (_record);
    uberButton.add (_pause);
    uberButton.add (_stop);
    y.add (uberButton);
    frame.pack ();
    frame.setVisible (true);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5399100_48714383_13_22
5399100_5401475_17_41
Title: how to read lists in yaml? 
----------------------------------------

public static void main (String [] args) throws IOException {
    ObjectMapper mapper = new ObjectMapper (new YAMLFactory ());
    try {
        List < Contact > contactList = mapper.readValue (new File (yamlLocation), new TypeReference < List < Contact > > () {
        }

        );
        contactList.forEach (System.out :: println);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    Yaml yaml = new Yaml (new Constructor (Collection.class));
    InputStream in = null;
    Collection < Contact > contacts;
    try {
        in = new FileInputStream (new File (yamlLocation));
        contacts = (Collection < Contact >) yaml.load (in);
    } catch (IOException e) {
        final DefaultResourceLoader loader = new DefaultResourceLoader ();
        final Resource resource = loader.getResource (yamlLocation);
        in = resource.getInputStream ();
        contacts = (Collection < Contact >) yaml.load (in);
    } finally {
        if (in != null) {
            try {
                in.close ();
            } catch (Exception e) {
            }
        }
    }
    for (Contact contact : contacts) {
        System.out.println (contact.name + ":" + contact.address + ":" + contact.age);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5426316_30481193_11_26
5426316_5426446_13_27
Title: Generic binary search Java 
----------------------------------------

public < T > int search (List < T > list, T Key, int iMin, int iMax, Comparator < T > comparator) {
    if (list == null || list.size () == 0) {
        return - 1;
    }
    int iMid = midPoint (iMin, iMax);
    if (iMid > iMax || iMid < iMin) {
        return - 1;
    }
    if (comparator.compare (list.get (iMid), Key) > 0) {
        return search (list, Key, iMin, iMid - 1, comparator);
    } else if (comparator.compare (list.get (iMid), Key) < 0) {
        return search (list, Key, iMid + 1, iMax, comparator);
    } else {
        return iMid;
    }

}
----------------------------------------

public int search (T v) {
    int low = 0;
    int high = a.length - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        T midVal = a [mid];
        if (c.compare (v, midVal) < 0) {
            low = mid - 1;
        } else if (c.compare (v, midVal) > 0) {
            high = mid + 1;
        }

    }
    return - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5426316_30481193_11_26
5426316_5426685_8_31
Title: Generic binary search Java 
----------------------------------------

public < T > int search (List < T > list, T Key, int iMin, int iMax, Comparator < T > comparator) {
    if (list == null || list.size () == 0) {
        return - 1;
    }
    int iMid = midPoint (iMin, iMax);
    if (iMid > iMax || iMid < iMin) {
        return - 1;
    }
    if (comparator.compare (list.get (iMid), Key) > 0) {
        return search (list, Key, iMin, iMid - 1, comparator);
    } else if (comparator.compare (list.get (iMid), Key) < 0) {
        return search (list, Key, iMid + 1, iMax, comparator);
    } else {
        return iMid;
    }

}
----------------------------------------

public int search (Comparable < T > v) {
    int low = 0;
    int high = a.length - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        T midVal = a [mid];
        int result = v.compareTo (midVal);
        if (result < 0) {
            high = mid - 1;
        } else if (result > 0) {
            low = mid + 1;
        } else {
            return mid;
        }

    }
    return - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5426316_5426446_13_27
5426316_5426685_8_31
Title: Generic binary search Java 
----------------------------------------

public int search (T v) {
    int low = 0;
    int high = a.length - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        T midVal = a [mid];
        if (c.compare (v, midVal) < 0) {
            low = mid - 1;
        } else if (c.compare (v, midVal) > 0) {
            high = mid + 1;
        }

    }
    return - 1;
}
----------------------------------------

public int search (Comparable < T > v) {
    int low = 0;
    int high = a.length - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        T midVal = a [mid];
        int result = v.compareTo (midVal);
        if (result < 0) {
            high = mid - 1;
        } else if (result > 0) {
            low = mid + 1;
        } else {
            return mid;
        }

    }
    return - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5428381_5428430_3_18
5428381_5428443_2_15
Title: Wrong output with for loop in Java 
----------------------------------------

public static void main (String [] args) {
    int high = 10;
    for (int low = 0;
    low <= high; low ++) {
        for (int mid = low;
        mid <= high; mid ++) {
            System.out.print (mid + " ");
        }
        System.out.println ();
    }
}
----------------------------------------

public static void main (String [] args) {
    int high = 10;
    for (int low = 0;
    low <= high; low ++) {
        for (int mid = low;
        mid <= high; mid ++) {
            System.out.print (mid + " ");
        }
        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5443056_5443082_3_22
5443056_5443192_7_20
Title: how to add internal frame inside a jdialog 
----------------------------------------

public static void main (String [] args) {
    JDialog d = new JDialog ();
    JDesktopPane desktoppane = new JDesktopPane ();
    desktoppane.setPreferredSize (new Dimension (100, 100));
    JInternalFrame i = new JInternalFrame ("HI", false, false, false, false);
    i.setBounds (0, 0, 100, 100);
    desktoppane.add (i);
    i.setVisible (true);
    d.setDefaultCloseOperation (JDialog.DISPOSE_ON_CLOSE);
    d.setTitle ("Wait dialog");
    d.add (desktoppane);
    d.pack ();
    d.setLocation (300, 300);
    d.setAlwaysOnTop (true);
    d.setVisible (true);
}
----------------------------------------

public static void main (String [] args) {
    JDialog d = new JDialog ();
    JInternalFrame i = new JInternalFrame ("HI", false, false, false, false);
    i.setPreferredSize (new Dimension (100, 100));
    d.setDefaultCloseOperation (JDialog.DISPOSE_ON_CLOSE);
    d.setTitle ("Wait dialog");
    d.add (i);
    d.pack ();
    d.setPreferredSize (new Dimension (100, 100));
    d.setLocation (300, 300);
    d.setAlwaysOnTop (true);
    d.setVisible (true);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5447136_5447271_10_25
5447136_5447775_4_17
Title: Strange pointer issue when trying to strongly connect objects 
----------------------------------------

public void setGlassPiece (GlassPiece newGlassPiece, boolean reentrant) {
    GlassPiece oldGlassPiece = linkedGlassPiece;
    linkedGlassPiece = newGlassPiece;
    if (reentrant && oldGlassPiece != null) {
        oldGlassPiece.setTrackerChip (null, false);
    }
    if (linkedGlassPiece != null && linkedGlassPiece.getTrackerChip () != this) {
        linkedGlassPiece.setTrackerChip (this);
    }
}
----------------------------------------

public void setGlassPiece (GlassPiece newGlassPiece) {
    if (linkedGlassPiece == newGlassPiece) {
        return;
    }
    if (linkedGlassPiece != null) {
        GlassPiece tmp = linkedGlassPiece;
        linkedGlassPiece = null;
        tmp.setTrackerChip (null);
    }
    if (newGlassPiece != null) {
        linkedGlassPiece = newGlassPiece;
        linkedGlassPiece.setTrackerChip (this);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5454172_34996432_1_18
5454172_8668705_5_18
Title: Prevent Jsoup from discarding extra whitespace 
----------------------------------------

public static String getText (Element cell) {
    StringBuilder textBuilder = new StringBuilder ();
    for (Node node : cell.childNodes ()) {
        if (node instanceof TextNode) {
            textBuilder.append (((TextNode) node).getWholeText ());
        } else {
            for (Node childNode : node.childNodes ()) {
                textBuilder.append (getText ((Element) childNode));
            }
            textBuilder.append (node.outerHtml ());
        }
    }
    if (cell.childNodes ().isEmpty ()) {
        textBuilder.append (cell.outerHtml ());
    }
    return textBuilder.toString ();
}
----------------------------------------

public static String getText (Element cell) {
    String text = null;
    List < Node > childNodes = cell.childNodes ();
    if (childNodes.size () > 0) {
        Node childNode = childNodes.get (0);
        if (childNode instanceof TextNode) {
            text = ((TextNode) childNode).getWholeText ();
        }
    }
    if (text == null) {
        text = cell.text ();
    }
    return text;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5454196_5455219_67_95
5454196_5455219_99_108
Title: My program is lacking a step! Please see if you can find what I am missing? 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    input = textField.getText ();
    intInput = Integer.parseInt (input);
    if (entered < array.length) {
        try {
            if ((intInput >= 10) && (intInput <= 100)) {
                array [entered] = intInput;
                textField.setText ("");
                displayArea.setText ("Entered number(s)..." + array [entered]);
                entered = entered + 1;
            } else {
                displayArea.setText ("Input numbers that range between 10 and 100");
            }
        } catch (NumberFormatException x) {
            displayArea.setText ("\"" + textField.getText () + "\" is not a legal number.");
            textField.selectAll ();
            textField.requestFocus ();
        }
    }
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    StringBuffer sb = new StringBuffer ();
    for (int i = 0;
    i < array.length; i ++) {
        sb.append (String.valueOf (array [i]));
        if (i < array.length) {
            sb.append (",");
        }
    }
    finalArea.setText ("\n" + sb.toString ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5455477_5455759_1_18
5455477_5455759_20_45
Title: Thumbnail creation in Java 
----------------------------------------

public static BufferedImage getThumb (ImageReader reader, int size) throws IOException {
    BufferedImage img;
    try {
        if (reader.getNumThumbnails (0) > 0) {
            img = reader.readThumbnail (0, 0);
        } else {
            ImageReadParam param = reader.getDefaultReadParam ();
            param.setSourceSubsampling (4, 4, 0, 0);
            img = reader.read (0);
        }
        throw new Exception ();
    } catch (Throwable t) {
        img = null;
    }
    return img != null ? resizeImage (img, size) : null;
}
----------------------------------------

public static BufferedImage getThumb (File file, double scale) throws IOException {
    BufferedImage img = null;
    try {
        Class < ? > c = ImageUtil.class.getClassLoader ().loadClass ("javax.media.jai.JAI");
        Class < ? > ic = ImageUtil.class.getClassLoader ().loadClass ("javax.media.jai.Interpolation");
        Class < ? > sc = ImageUtil.class.getClassLoader ().loadClass ("javax.media.jai.operator.ScaleDescriptor");
        Method jaiCreate = c.getMethod ("create", String.class, Object.class);
        Method getInstance = findMethod (ic, "getInstance");
        Method sdCreate = findMethod (sc, "create");
        if (c != null) {
            Object image = jaiCreate.invoke (null, "fileload", file.getAbsolutePath ());
            Object [] params = {image, (float) scale, (float) scale, 0.0f, 0.0f, getInstance.invoke (null, 2), null};
            Object sd = sdCreate.invoke (null, params);
            Method m = sd.getClass ().getMethod ("getAsBufferedImage");
            img = (BufferedImage) m.invoke (sd);
        }
    } catch (Throwable tt) {
        System.out.println ("Could not read image using JAI, maybe JAI is not installed.");
        System.out.println (tt);
    }
    return img;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5460819_23864409_7_28
5460819_5460947_3_17
Title: String Manipulation Problems in Java 
----------------------------------------

public static void main (String [] args) {
    StringBuilder sb = new StringBuilder ();
    String s = "aaabcgghelllloii";
    for (int i = 0;
    i + 1 < s.length (); i ++) {
        if ((s.charAt (i) != s.charAt (i + 1) && (i == 0))) {
            sb.append (s.charAt (i) + " " + s.charAt (i + 1));
        } else if ((s.charAt (i) != s.charAt (i + 1) && (i > 0))) {
            sb.append (s.charAt (i + 1));
        } else if ((s.charAt (i) == s.charAt (i + 1)) && (i > 0)) {
            sb.append ("*" + s.charAt (i + 1));
        } else if ((s.charAt (i) == s.charAt (i + 1)) && (i == 0)) {
            sb.append (s.charAt (i) + "*" + s.charAt (i + 1));
        }

    }
    System.out.println (sb.toString ());
}
----------------------------------------

public static void main (String [] a) {
    String s = "xxyy";
    StringBuffer sb = new StringBuffer (s);
    for (int i = 0;
    i < sb.length () - 1; i ++) {
        if (sb.charAt (i) == sb.charAt (i + 1)) {
            sb.insert (i + 1, "*");
            i ++;
        }
    }
    System.out.println (sb.toString ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5460819_5461066_1_24
5460819_5468652_1_12
Title: String Manipulation Problems in Java 
----------------------------------------

public String endX (String str) {
    StringBuilder s = new StringBuilder ();
    int x = 0;
    for (int i = 0;
    i < str.length (); ++ i) {
        if (str.charAt (i) == 'x') {
            ++ x;
        } else {
            s.append (str.charAt (i));
        }
    }
    for (int i = 0;
    i < x; ++ i) {
        s.append ('x');
    }
    return s.toString ();
}
----------------------------------------

public String endX (String str) {
    StringBuilder sb = new StringBuilder (str);
    int length = sb.length () - 1;
    for (int i = 0;
    i < length; i ++) {
        if (sb.charAt (i) == 'x') {
            sb.deleteCharAt (i --);
            sb.append ('x');
            length --;
        }
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5461543_13786989_1_15
5461543_41090408_3_10
Title: Run Java Threads sequentially 
----------------------------------------

public static void main (String [] args) throws InterruptedException {
    MyRunnable r = new MyRunnable ();
    Thread t1 = new Thread (r, "A");
    Thread t2 = new Thread (r, "B");
    Thread t3 = new Thread (r, "C");
    t1.start ();
    Thread.sleep (1000);
    t2.start ();
    Thread.sleep (1000);
    t3.start ();
}
----------------------------------------

public static void main (String [] args) throws InterruptedException {
    app obj = new app ();
    Thread t1 = new Thread (new print (obj, 0));
    Thread t2 = new Thread (new print (obj, 1));
    Thread t3 = new Thread (new print (obj, 2));
    t1.start ();
    t2.start ();
    t3.start ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5461543_18058159_24_36
5461543_35816444_13_30
Title: Run Java Threads sequentially 
----------------------------------------

public void run () {
    for (int i = 0;
    i < 10; i ++) {
        System.out.println ("In Thread One " + i);
        try {
            Thread.sleep (500);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------

public void run () {
    while (true) {
        if (names [indx].equals (Thread.currentThread ().getName ())) {
            indx --;
            break;
        } else {
            try {
                Thread.sleep (20);
            } catch (InterruptedException ie) {
            }
        }
    }
    if (indx >= 0) try {
        jobs [indx].join ();
    } catch (InterruptedException ie) {
    }

    System.out.println (Thread.currentThread ().getName ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5461543_18058159_24_36
5461543_41090408_21_79
Title: Run Java Threads sequentially 
----------------------------------------

public void run () {
    for (int i = 0;
    i < 10; i ++) {
        System.out.println ("In Thread One " + i);
        try {
            Thread.sleep (500);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------

public void run () {
    try {
        if (a == 0) {
            synchronized (obj) {
                for (int i = 0;
                i < 21; i ++) {
                    while (obj.status != 0 && obj.status != 3) {
                        obj.wait ();
                    }
                    System.out.print (0);
                    if (obj.status == 0) obj.status = 1;
                    else obj.status = 2;

                    obj.notifyAll ();
                }
            }
        } else if (a % 2 != 0) {
            synchronized (obj) {
                for (int i = 0;
                i < 11; i ++) {
                    while (obj.status != 1) {
                        obj.wait ();
                    }
                    System.out.print (a);
                    a += 2;
                    obj.status = 3;
                    obj.notifyAll ();
                }
            }
        } else {
            synchronized (obj) {
                for (int i = 0;
                i < 11; i ++) {
                    while (obj.status != 2) {
                        obj.wait ();
                    }
                    System.out.print (a);
                    a += 2;
                    obj.status = 0;
                    obj.notifyAll ();
                }
            }
        }

    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5461543_18058159_42_54
5461543_35816444_13_30
Title: Run Java Threads sequentially 
----------------------------------------

public void run () {
    for (int i = 0;
    i < 10; i ++) {
        System.out.println ("In Thread Two=" + i);
        try {
            Thread.sleep (500);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------

public void run () {
    while (true) {
        if (names [indx].equals (Thread.currentThread ().getName ())) {
            indx --;
            break;
        } else {
            try {
                Thread.sleep (20);
            } catch (InterruptedException ie) {
            }
        }
    }
    if (indx >= 0) try {
        jobs [indx].join ();
    } catch (InterruptedException ie) {
    }

    System.out.println (Thread.currentThread ().getName ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5461543_18058159_42_54
5461543_41090408_21_79
Title: Run Java Threads sequentially 
----------------------------------------

public void run () {
    for (int i = 0;
    i < 10; i ++) {
        System.out.println ("In Thread Two=" + i);
        try {
            Thread.sleep (500);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------

public void run () {
    try {
        if (a == 0) {
            synchronized (obj) {
                for (int i = 0;
                i < 21; i ++) {
                    while (obj.status != 0 && obj.status != 3) {
                        obj.wait ();
                    }
                    System.out.print (0);
                    if (obj.status == 0) obj.status = 1;
                    else obj.status = 2;

                    obj.notifyAll ();
                }
            }
        } else if (a % 2 != 0) {
            synchronized (obj) {
                for (int i = 0;
                i < 11; i ++) {
                    while (obj.status != 1) {
                        obj.wait ();
                    }
                    System.out.print (a);
                    a += 2;
                    obj.status = 3;
                    obj.notifyAll ();
                }
            }
        } else {
            synchronized (obj) {
                for (int i = 0;
                i < 11; i ++) {
                    while (obj.status != 2) {
                        obj.wait ();
                    }
                    System.out.print (a);
                    a += 2;
                    obj.status = 0;
                    obj.notifyAll ();
                }
            }
        }

    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5461543_35816444_13_30
5461543_41090408_21_79
Title: Run Java Threads sequentially 
----------------------------------------

public void run () {
    while (true) {
        if (names [indx].equals (Thread.currentThread ().getName ())) {
            indx --;
            break;
        } else {
            try {
                Thread.sleep (20);
            } catch (InterruptedException ie) {
            }
        }
    }
    if (indx >= 0) try {
        jobs [indx].join ();
    } catch (InterruptedException ie) {
    }

    System.out.println (Thread.currentThread ().getName ());
}
----------------------------------------

public void run () {
    try {
        if (a == 0) {
            synchronized (obj) {
                for (int i = 0;
                i < 21; i ++) {
                    while (obj.status != 0 && obj.status != 3) {
                        obj.wait ();
                    }
                    System.out.print (0);
                    if (obj.status == 0) obj.status = 1;
                    else obj.status = 2;

                    obj.notifyAll ();
                }
            }
        } else if (a % 2 != 0) {
            synchronized (obj) {
                for (int i = 0;
                i < 11; i ++) {
                    while (obj.status != 1) {
                        obj.wait ();
                    }
                    System.out.print (a);
                    a += 2;
                    obj.status = 3;
                    obj.notifyAll ();
                }
            }
        } else {
            synchronized (obj) {
                for (int i = 0;
                i < 11; i ++) {
                    while (obj.status != 2) {
                        obj.wait ();
                    }
                    System.out.print (a);
                    a += 2;
                    obj.status = 0;
                    obj.notifyAll ();
                }
            }
        }

    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5471700_5471720_23_31
5471700_5696028_16_29
Title: Is there a command in java to measure the execution time? 
----------------------------------------

public static void main (String s []) {
    ExecutionTimer t = new ExecutionTimer ();
    for (int i = 0;
    i < 80; i ++) {
        System.out.print (".");
    }
    t.end ();
    System.out.println ("\n" + t.duration () + " ms");
}
----------------------------------------

public static void main (final String [] args) {
    final int factorialOf5 = Timer.time ("Calculating factorial of 5", new Action < Integer > () {
        public Integer perform () {
            int result = 1;
            for (int i = 2;
            i <= 5; i ++) {
                result *= i;
            }
            return result;
        }}

    );
    System.out.println ("Result: " + factorialOf5);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5476816_5476865_8_33
5476816_5477042_12_25
Title: Help Searching a 2D Array (Java) 
----------------------------------------

public static String search (String term) {
    String result = "";
    int row = db.bookdb.length;
    outer_loop : for (int i = 0;
    i < db.bookdb.length; i ++) {
        for (int j = 0;
        j < 4; j ++) {
            if (term.equals (db.bookdb [i] [j])) {
                row = i;
                break outer_loop;
            }
        }
    }
    if (row == db.bookdb.length) {
        result += "Your search failed to return any results";
    } else {
        for (int j = 0;
        j < 4; j ++) {
            result += db.bookdb [row] [j] + "    ";
        }
    }
    return result;
}
----------------------------------------

public static String search (String term) {
    String result = "";
    int row = searchTermInArray (db.bookdb, term);
    if (row == - 1) {
        result += "Your search failed to return any results";
    } else {
        for (int j = 0;
        j < 4; j ++) {
            result += db.bookdb [row] [j] + "    ";
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5493933_5494048_1_22
5493933_5494135_1_12
Title: Using Recursion to Replace Parts of One String with Another (Java) 
----------------------------------------

public String nextGeneration (String initiator, String generator) {
    String result2 = "";
    if (initiator.length () == 0) {
        return initiator;
    }
    char f = initiator.charAt (0);
    switch (f) {
        case 'F' :
            result2 = generator + nextGeneration (initiator.substring (1, initiator.length ()), generator);
            break;
        case '+' :
            result2 = "+" + nextGeneration (initiator.substring (1, initiator.length ()), generator);
            break;
        case '-' :
            result2 = "-" + nextGeneration (initiator.substring (1, initiator.length ()), generator);
            break;
        default :
            break;
    }
    return result2;
}
----------------------------------------

public static String nextGeneration (String initiator, String generator) {
    StringBuffer result = new StringBuffer ();
    if (initiator.length () > 0) {
        char letter = initiator.charAt (0);
        if (letter == 'F') result.append (generator);
        else result.append (letter);

        result.append (nextGeneration (initiator.substring (1), generator));
    }
    return result.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_11201917_29_64
549451_12193485_47_97
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    else childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);

    mHeight = 0;
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childw = child.getMeasuredWidth ();
            mHeight = Math.max (mHeight, child.getMeasuredHeight () + PAD_V);
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += mHeight;
            }
            xpos += childw + PAD_H;
        }
    }
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + mHeight;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + mHeight < height) {
            height = ypos + mHeight;
        }
    }

    height += 5;
    setMeasuredDimension (width, height);
}
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int line_height = 0;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.EXACTLY) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.EXACTLY);
    } else {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);
    }

    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childw = child.getMeasuredWidth ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            xpos += childw + lp.horizontal_spacing;
            line_height = child.getMeasuredHeight () + lp.vertical_spacing;
        }
    }
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + line_height;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + line_height < height) {
            height = ypos + line_height;
        }
    }

    setMeasuredDimension (width, height);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_11201917_29_64
549451_21893662_45_91
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    else childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);

    mHeight = 0;
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childw = child.getMeasuredWidth ();
            mHeight = Math.max (mHeight, child.getMeasuredHeight () + PAD_V);
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += mHeight;
            }
            xpos += childw + PAD_H;
        }
    }
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + mHeight;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + mHeight < height) {
            height = ypos + mHeight;
        }
    }

    height += 5;
    setMeasuredDimension (width, height);
}
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int line_height = 0;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    } else {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);
    }
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childw = child.getMeasuredWidth ();
            line_height = Math.max (line_height, child.getMeasuredHeight () + lp.vertical_spacing);
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            xpos += childw + lp.horizontal_spacing;
        }
    }
    this.line_height = line_height;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + line_height;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + line_height < height) {
            height = ypos + line_height;
        }
    }

    setMeasuredDimension (width, height);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_11201917_29_64
549451_24040181_30_79
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    else childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);

    mHeight = 0;
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childw = child.getMeasuredWidth ();
            mHeight = Math.max (mHeight, child.getMeasuredHeight () + PAD_V);
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += mHeight;
            }
            xpos += childw + PAD_H;
        }
    }
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + mHeight;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + mHeight < height) {
            height = ypos + mHeight;
        }
    }

    height += 5;
    setMeasuredDimension (width, height);
}
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int maxHeight = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int lineHeight = 0;
    int xAxis = getPaddingLeft ();
    int yAxis = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    } else {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);
    }
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final CentricFlowLayout.LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childMeasuredWidth = child.getMeasuredWidth ();
            lineHeight = Math.max (lineHeight, child.getMeasuredHeight () + lp.verticalSpacing);
            if (xAxis + childMeasuredWidth > width) {
                xAxis = getPaddingLeft ();
                yAxis += lineHeight;
            } else if (i + 1 == count) {
                yAxis += lineHeight;
            }

            xAxis += childMeasuredWidth + lp.horizontalSpacing;
        }
    }
    this.lineHeight = lineHeight;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = yAxis + lineHeight;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (yAxis + lineHeight < height) {
            height = yAxis + lineHeight;
        }
    }

    if (maxHeight == 0) {
        maxHeight = height + getPaddingTop ();
    }
    centricHeightPadding = (maxHeight - height) / 2;
    setMeasuredDimension (width, disableCenterVertical ? height + getPaddingTop () : maxHeight);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_11201917_29_64
549451_4937713_34_70
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    else childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);

    mHeight = 0;
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childw = child.getMeasuredWidth ();
            mHeight = Math.max (mHeight, child.getMeasuredHeight () + PAD_V);
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += mHeight;
            }
            xpos += childw + PAD_H;
        }
    }
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + mHeight;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + mHeight < height) {
            height = ypos + mHeight;
        }
    }

    height += 5;
    setMeasuredDimension (width, height);
}
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    final int widthMode = MeasureSpec.getMode (widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode (heightMeasureSpec);
    final int maxInternalWidth = MeasureSpec.getSize (widthMeasureSpec) - getHorizontalPadding ();
    final int maxInternalHeight = MeasureSpec.getSize (heightMeasureSpec) - getVerticalPadding ();
    List < RowMeasurement > rows = new ArrayList < RowMeasurement > ();
    RowMeasurement currentRow = new RowMeasurement (maxInternalWidth, widthMode);
    rows.add (currentRow);
    for (View child : getLayoutChildren ()) {
        LayoutParams childLayoutParams = child.getLayoutParams ();
        int childWidthSpec = createChildMeasureSpec (childLayoutParams.width, maxInternalWidth, widthMode);
        int childHeightSpec = createChildMeasureSpec (childLayoutParams.height, maxInternalHeight, heightMode);
        child.measure (childWidthSpec, childHeightSpec);
        int childWidth = child.getMeasuredWidth ();
        int childHeight = child.getMeasuredHeight ();
        if (currentRow.wouldExceedMax (childWidth)) {
            currentRow = new RowMeasurement (maxInternalWidth, widthMode);
            rows.add (currentRow);
        }
        currentRow.addChildDimensions (childWidth, childHeight);
    }
    int longestRowWidth = 0;
    int totalRowHeight = 0;
    for (int index = 0;
    index < rows.size (); index ++) {
        RowMeasurement row = rows.get (index);
        totalRowHeight += row.getHeight ();
        if (index < rows.size () - 1) {
            totalRowHeight += verticalSpacing;
        }
        longestRowWidth = Math.max (longestRowWidth, row.getWidth ());
    }
    setMeasuredDimension (widthMode == MeasureSpec.EXACTLY ? MeasureSpec.getSize (widthMeasureSpec) : longestRowWidth + getHorizontalPadding (), heightMode == MeasureSpec.EXACTLY ? MeasureSpec.getSize (heightMeasureSpec) : totalRowHeight + getVerticalPadding ());
    currentRows = Collections.unmodifiableList (rows);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_11201917_29_64
549451_560958_32_75
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    else childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);

    mHeight = 0;
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childw = child.getMeasuredWidth ();
            mHeight = Math.max (mHeight, child.getMeasuredHeight () + PAD_V);
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += mHeight;
            }
            xpos += childw + PAD_H;
        }
    }
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + mHeight;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + mHeight < height) {
            height = ypos + mHeight;
        }
    }

    height += 5;
    setMeasuredDimension (width, height);
}
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec);
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int line_height = 0;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec (height, MeasureSpec.UNSPECIFIED));
            final int childw = child.getMeasuredWidth ();
            line_height = Math.max (line_height, child.getMeasuredHeight () + lp.height);
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            xpos += childw + lp.width;
        }
    }
    this.line_height = line_height;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + line_height;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + line_height < height) {
            height = ypos + line_height;
        }
    }

    setMeasuredDimension (width, height);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_11201917_67_84
549451_12193485_113_138
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    for (int i = 0;
    i < getChildCount (); i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += mHeight;
            }
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + PAD_H;
        }
    }
}
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int lineHeight = 0;
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += lineHeight;
            }
            lineHeight = child.getMeasuredHeight () + lp.vertical_spacing;
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + lp.horizontal_spacing;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_11201917_67_84
549451_21893662_113_160
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    for (int i = 0;
    i < getChildCount (); i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += mHeight;
            }
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + PAD_H;
        }
    }
}
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int lastHorizontalSpacing = 0;
    int rowStartIdx = 0;
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            if (xpos + childw > width) {
                final int freeSpace = width - xpos + lastHorizontalSpacing;
                xpos = getPaddingLeft () + freeSpace / 2;
                for (int j = rowStartIdx;
                j < i; ++ j) {
                    final View drawChild = getChildAt (j);
                    drawChild.layout (xpos, ypos, xpos + drawChild.getMeasuredWidth (), ypos + drawChild.getMeasuredHeight ());
                    xpos += drawChild.getMeasuredWidth () + ((LayoutParams) drawChild.getLayoutParams ()).horizontal_spacing;
                }
                lastHorizontalSpacing = 0;
                xpos = getPaddingLeft ();
                ypos += line_height;
                rowStartIdx = i;
            }
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + lp.horizontal_spacing;
            lastHorizontalSpacing = lp.horizontal_spacing;
        }
    }
    if (rowStartIdx < count) {
        final int freeSpace = width - xpos + lastHorizontalSpacing;
        xpos = getPaddingLeft () + freeSpace / 2;
        for (int j = rowStartIdx;
        j < count; ++ j) {
            final View drawChild = getChildAt (j);
            drawChild.layout (xpos, ypos, xpos + drawChild.getMeasuredWidth (), ypos + drawChild.getMeasuredHeight ());
            xpos += drawChild.getMeasuredWidth () + ((LayoutParams) drawChild.getLayoutParams ()).horizontal_spacing;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_11201917_67_84
549451_24040181_95_125
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    for (int i = 0;
    i < getChildCount (); i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += mHeight;
            }
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + PAD_H;
        }
    }
}
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int yAxis = centricHeightPadding + getPaddingTop () + getPaddingBottom ();
    View child;
    int measuredWidth;
    int lineWidth = getPaddingLeft () + getPaddingRight ();
    CentricFlowLayout.LayoutParams lp;
    int offset;
    LINE_CHILDREN.clear ();
    for (int i = 0;
    i < count; i ++) {
        child = getChildAt (i);
        lp = (LayoutParams) child.getLayoutParams ();
        if (GONE != child.getVisibility ()) {
            measuredWidth = child.getMeasuredWidth ();
            if (lineWidth + measuredWidth + lp.horizontalSpacing > width) {
                offset = (width - lineWidth) / 2;
                layoutHorizontalCentricLine (LINE_CHILDREN, offset, yAxis);
                lineWidth = getPaddingLeft () + getPaddingRight () + measuredWidth + lp.horizontalSpacing;
                yAxis += lineHeight;
                LINE_CHILDREN.clear ();
                LINE_CHILDREN.add (child);
            } else {
                lineWidth += measuredWidth + lp.horizontalSpacing;
                LINE_CHILDREN.add (child);
            }
        }
    }
    offset = (width - lineWidth) / 2;
    layoutHorizontalCentricLine (LINE_CHILDREN, offset, yAxis);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_11201917_67_84
549451_4937713_86_106
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    for (int i = 0;
    i < getChildCount (); i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += mHeight;
            }
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + PAD_H;
        }
    }
}
----------------------------------------

protected void onLayout (boolean changed, int leftPosition, int topPosition, int rightPosition, int bottomPosition) {
    final int widthOffset = getMeasuredWidth () - getPaddingRight ();
    int x = getPaddingLeft ();
    int y = getPaddingTop ();
    Iterator < RowMeasurement > rowIterator = currentRows.iterator ();
    RowMeasurement currentRow = rowIterator.next ();
    for (View child : getLayoutChildren ()) {
        final int childWidth = child.getMeasuredWidth ();
        final int childHeight = child.getMeasuredHeight ();
        if (x + childWidth > widthOffset) {
            x = getPaddingLeft ();
            y += currentRow.height + verticalSpacing;
            if (rowIterator.hasNext ()) {
                currentRow = rowIterator.next ();
            }
        }
        child.layout (x, y, x + childWidth, y + childHeight);
        x += childWidth + horizontalSpacing;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_11201917_67_84
549451_560958_88_108
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    for (int i = 0;
    i < getChildCount (); i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += mHeight;
            }
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + PAD_H;
        }
    }
}
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + lp.width;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_12193485_113_138
549451_21893662_113_160
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int lineHeight = 0;
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += lineHeight;
            }
            lineHeight = child.getMeasuredHeight () + lp.vertical_spacing;
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + lp.horizontal_spacing;
        }
    }
}
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int lastHorizontalSpacing = 0;
    int rowStartIdx = 0;
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            if (xpos + childw > width) {
                final int freeSpace = width - xpos + lastHorizontalSpacing;
                xpos = getPaddingLeft () + freeSpace / 2;
                for (int j = rowStartIdx;
                j < i; ++ j) {
                    final View drawChild = getChildAt (j);
                    drawChild.layout (xpos, ypos, xpos + drawChild.getMeasuredWidth (), ypos + drawChild.getMeasuredHeight ());
                    xpos += drawChild.getMeasuredWidth () + ((LayoutParams) drawChild.getLayoutParams ()).horizontal_spacing;
                }
                lastHorizontalSpacing = 0;
                xpos = getPaddingLeft ();
                ypos += line_height;
                rowStartIdx = i;
            }
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + lp.horizontal_spacing;
            lastHorizontalSpacing = lp.horizontal_spacing;
        }
    }
    if (rowStartIdx < count) {
        final int freeSpace = width - xpos + lastHorizontalSpacing;
        xpos = getPaddingLeft () + freeSpace / 2;
        for (int j = rowStartIdx;
        j < count; ++ j) {
            final View drawChild = getChildAt (j);
            drawChild.layout (xpos, ypos, xpos + drawChild.getMeasuredWidth (), ypos + drawChild.getMeasuredHeight ());
            xpos += drawChild.getMeasuredWidth () + ((LayoutParams) drawChild.getLayoutParams ()).horizontal_spacing;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_12193485_113_138
549451_24040181_95_125
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int lineHeight = 0;
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += lineHeight;
            }
            lineHeight = child.getMeasuredHeight () + lp.vertical_spacing;
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + lp.horizontal_spacing;
        }
    }
}
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int yAxis = centricHeightPadding + getPaddingTop () + getPaddingBottom ();
    View child;
    int measuredWidth;
    int lineWidth = getPaddingLeft () + getPaddingRight ();
    CentricFlowLayout.LayoutParams lp;
    int offset;
    LINE_CHILDREN.clear ();
    for (int i = 0;
    i < count; i ++) {
        child = getChildAt (i);
        lp = (LayoutParams) child.getLayoutParams ();
        if (GONE != child.getVisibility ()) {
            measuredWidth = child.getMeasuredWidth ();
            if (lineWidth + measuredWidth + lp.horizontalSpacing > width) {
                offset = (width - lineWidth) / 2;
                layoutHorizontalCentricLine (LINE_CHILDREN, offset, yAxis);
                lineWidth = getPaddingLeft () + getPaddingRight () + measuredWidth + lp.horizontalSpacing;
                yAxis += lineHeight;
                LINE_CHILDREN.clear ();
                LINE_CHILDREN.add (child);
            } else {
                lineWidth += measuredWidth + lp.horizontalSpacing;
                LINE_CHILDREN.add (child);
            }
        }
    }
    offset = (width - lineWidth) / 2;
    layoutHorizontalCentricLine (LINE_CHILDREN, offset, yAxis);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_12193485_113_138
549451_4937713_86_106
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int lineHeight = 0;
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += lineHeight;
            }
            lineHeight = child.getMeasuredHeight () + lp.vertical_spacing;
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + lp.horizontal_spacing;
        }
    }
}
----------------------------------------

protected void onLayout (boolean changed, int leftPosition, int topPosition, int rightPosition, int bottomPosition) {
    final int widthOffset = getMeasuredWidth () - getPaddingRight ();
    int x = getPaddingLeft ();
    int y = getPaddingTop ();
    Iterator < RowMeasurement > rowIterator = currentRows.iterator ();
    RowMeasurement currentRow = rowIterator.next ();
    for (View child : getLayoutChildren ()) {
        final int childWidth = child.getMeasuredWidth ();
        final int childHeight = child.getMeasuredHeight ();
        if (x + childWidth > widthOffset) {
            x = getPaddingLeft ();
            y += currentRow.height + verticalSpacing;
            if (rowIterator.hasNext ()) {
                currentRow = rowIterator.next ();
            }
        }
        child.layout (x, y, x + childWidth, y + childHeight);
        x += childWidth + horizontalSpacing;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_12193485_113_138
549451_560958_88_108
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int lineHeight = 0;
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += lineHeight;
            }
            lineHeight = child.getMeasuredHeight () + lp.vertical_spacing;
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + lp.horizontal_spacing;
        }
    }
}
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + lp.width;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_12193485_47_97
549451_21893662_45_91
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int line_height = 0;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.EXACTLY) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.EXACTLY);
    } else {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);
    }

    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childw = child.getMeasuredWidth ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            xpos += childw + lp.horizontal_spacing;
            line_height = child.getMeasuredHeight () + lp.vertical_spacing;
        }
    }
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + line_height;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + line_height < height) {
            height = ypos + line_height;
        }
    }

    setMeasuredDimension (width, height);
}
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int line_height = 0;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    } else {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);
    }
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childw = child.getMeasuredWidth ();
            line_height = Math.max (line_height, child.getMeasuredHeight () + lp.vertical_spacing);
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            xpos += childw + lp.horizontal_spacing;
        }
    }
    this.line_height = line_height;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + line_height;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + line_height < height) {
            height = ypos + line_height;
        }
    }

    setMeasuredDimension (width, height);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_12193485_47_97
549451_24040181_30_79
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int line_height = 0;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.EXACTLY) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.EXACTLY);
    } else {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);
    }

    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childw = child.getMeasuredWidth ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            xpos += childw + lp.horizontal_spacing;
            line_height = child.getMeasuredHeight () + lp.vertical_spacing;
        }
    }
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + line_height;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + line_height < height) {
            height = ypos + line_height;
        }
    }

    setMeasuredDimension (width, height);
}
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int maxHeight = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int lineHeight = 0;
    int xAxis = getPaddingLeft ();
    int yAxis = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    } else {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);
    }
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final CentricFlowLayout.LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childMeasuredWidth = child.getMeasuredWidth ();
            lineHeight = Math.max (lineHeight, child.getMeasuredHeight () + lp.verticalSpacing);
            if (xAxis + childMeasuredWidth > width) {
                xAxis = getPaddingLeft ();
                yAxis += lineHeight;
            } else if (i + 1 == count) {
                yAxis += lineHeight;
            }

            xAxis += childMeasuredWidth + lp.horizontalSpacing;
        }
    }
    this.lineHeight = lineHeight;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = yAxis + lineHeight;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (yAxis + lineHeight < height) {
            height = yAxis + lineHeight;
        }
    }

    if (maxHeight == 0) {
        maxHeight = height + getPaddingTop ();
    }
    centricHeightPadding = (maxHeight - height) / 2;
    setMeasuredDimension (width, disableCenterVertical ? height + getPaddingTop () : maxHeight);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_12193485_47_97
549451_4937713_34_70
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int line_height = 0;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.EXACTLY) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.EXACTLY);
    } else {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);
    }

    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childw = child.getMeasuredWidth ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            xpos += childw + lp.horizontal_spacing;
            line_height = child.getMeasuredHeight () + lp.vertical_spacing;
        }
    }
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + line_height;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + line_height < height) {
            height = ypos + line_height;
        }
    }

    setMeasuredDimension (width, height);
}
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    final int widthMode = MeasureSpec.getMode (widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode (heightMeasureSpec);
    final int maxInternalWidth = MeasureSpec.getSize (widthMeasureSpec) - getHorizontalPadding ();
    final int maxInternalHeight = MeasureSpec.getSize (heightMeasureSpec) - getVerticalPadding ();
    List < RowMeasurement > rows = new ArrayList < RowMeasurement > ();
    RowMeasurement currentRow = new RowMeasurement (maxInternalWidth, widthMode);
    rows.add (currentRow);
    for (View child : getLayoutChildren ()) {
        LayoutParams childLayoutParams = child.getLayoutParams ();
        int childWidthSpec = createChildMeasureSpec (childLayoutParams.width, maxInternalWidth, widthMode);
        int childHeightSpec = createChildMeasureSpec (childLayoutParams.height, maxInternalHeight, heightMode);
        child.measure (childWidthSpec, childHeightSpec);
        int childWidth = child.getMeasuredWidth ();
        int childHeight = child.getMeasuredHeight ();
        if (currentRow.wouldExceedMax (childWidth)) {
            currentRow = new RowMeasurement (maxInternalWidth, widthMode);
            rows.add (currentRow);
        }
        currentRow.addChildDimensions (childWidth, childHeight);
    }
    int longestRowWidth = 0;
    int totalRowHeight = 0;
    for (int index = 0;
    index < rows.size (); index ++) {
        RowMeasurement row = rows.get (index);
        totalRowHeight += row.getHeight ();
        if (index < rows.size () - 1) {
            totalRowHeight += verticalSpacing;
        }
        longestRowWidth = Math.max (longestRowWidth, row.getWidth ());
    }
    setMeasuredDimension (widthMode == MeasureSpec.EXACTLY ? MeasureSpec.getSize (widthMeasureSpec) : longestRowWidth + getHorizontalPadding (), heightMode == MeasureSpec.EXACTLY ? MeasureSpec.getSize (heightMeasureSpec) : totalRowHeight + getVerticalPadding ());
    currentRows = Collections.unmodifiableList (rows);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_12193485_47_97
549451_560958_32_75
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int line_height = 0;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.EXACTLY) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.EXACTLY);
    } else {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);
    }

    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childw = child.getMeasuredWidth ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            xpos += childw + lp.horizontal_spacing;
            line_height = child.getMeasuredHeight () + lp.vertical_spacing;
        }
    }
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + line_height;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + line_height < height) {
            height = ypos + line_height;
        }
    }

    setMeasuredDimension (width, height);
}
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec);
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int line_height = 0;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec (height, MeasureSpec.UNSPECIFIED));
            final int childw = child.getMeasuredWidth ();
            line_height = Math.max (line_height, child.getMeasuredHeight () + lp.height);
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            xpos += childw + lp.width;
        }
    }
    this.line_height = line_height;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + line_height;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + line_height < height) {
            height = ypos + line_height;
        }
    }

    setMeasuredDimension (width, height);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_21893662_113_160
549451_24040181_95_125
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int lastHorizontalSpacing = 0;
    int rowStartIdx = 0;
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            if (xpos + childw > width) {
                final int freeSpace = width - xpos + lastHorizontalSpacing;
                xpos = getPaddingLeft () + freeSpace / 2;
                for (int j = rowStartIdx;
                j < i; ++ j) {
                    final View drawChild = getChildAt (j);
                    drawChild.layout (xpos, ypos, xpos + drawChild.getMeasuredWidth (), ypos + drawChild.getMeasuredHeight ());
                    xpos += drawChild.getMeasuredWidth () + ((LayoutParams) drawChild.getLayoutParams ()).horizontal_spacing;
                }
                lastHorizontalSpacing = 0;
                xpos = getPaddingLeft ();
                ypos += line_height;
                rowStartIdx = i;
            }
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + lp.horizontal_spacing;
            lastHorizontalSpacing = lp.horizontal_spacing;
        }
    }
    if (rowStartIdx < count) {
        final int freeSpace = width - xpos + lastHorizontalSpacing;
        xpos = getPaddingLeft () + freeSpace / 2;
        for (int j = rowStartIdx;
        j < count; ++ j) {
            final View drawChild = getChildAt (j);
            drawChild.layout (xpos, ypos, xpos + drawChild.getMeasuredWidth (), ypos + drawChild.getMeasuredHeight ());
            xpos += drawChild.getMeasuredWidth () + ((LayoutParams) drawChild.getLayoutParams ()).horizontal_spacing;
        }
    }
}
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int yAxis = centricHeightPadding + getPaddingTop () + getPaddingBottom ();
    View child;
    int measuredWidth;
    int lineWidth = getPaddingLeft () + getPaddingRight ();
    CentricFlowLayout.LayoutParams lp;
    int offset;
    LINE_CHILDREN.clear ();
    for (int i = 0;
    i < count; i ++) {
        child = getChildAt (i);
        lp = (LayoutParams) child.getLayoutParams ();
        if (GONE != child.getVisibility ()) {
            measuredWidth = child.getMeasuredWidth ();
            if (lineWidth + measuredWidth + lp.horizontalSpacing > width) {
                offset = (width - lineWidth) / 2;
                layoutHorizontalCentricLine (LINE_CHILDREN, offset, yAxis);
                lineWidth = getPaddingLeft () + getPaddingRight () + measuredWidth + lp.horizontalSpacing;
                yAxis += lineHeight;
                LINE_CHILDREN.clear ();
                LINE_CHILDREN.add (child);
            } else {
                lineWidth += measuredWidth + lp.horizontalSpacing;
                LINE_CHILDREN.add (child);
            }
        }
    }
    offset = (width - lineWidth) / 2;
    layoutHorizontalCentricLine (LINE_CHILDREN, offset, yAxis);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_21893662_113_160
549451_4937713_86_106
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int lastHorizontalSpacing = 0;
    int rowStartIdx = 0;
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            if (xpos + childw > width) {
                final int freeSpace = width - xpos + lastHorizontalSpacing;
                xpos = getPaddingLeft () + freeSpace / 2;
                for (int j = rowStartIdx;
                j < i; ++ j) {
                    final View drawChild = getChildAt (j);
                    drawChild.layout (xpos, ypos, xpos + drawChild.getMeasuredWidth (), ypos + drawChild.getMeasuredHeight ());
                    xpos += drawChild.getMeasuredWidth () + ((LayoutParams) drawChild.getLayoutParams ()).horizontal_spacing;
                }
                lastHorizontalSpacing = 0;
                xpos = getPaddingLeft ();
                ypos += line_height;
                rowStartIdx = i;
            }
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + lp.horizontal_spacing;
            lastHorizontalSpacing = lp.horizontal_spacing;
        }
    }
    if (rowStartIdx < count) {
        final int freeSpace = width - xpos + lastHorizontalSpacing;
        xpos = getPaddingLeft () + freeSpace / 2;
        for (int j = rowStartIdx;
        j < count; ++ j) {
            final View drawChild = getChildAt (j);
            drawChild.layout (xpos, ypos, xpos + drawChild.getMeasuredWidth (), ypos + drawChild.getMeasuredHeight ());
            xpos += drawChild.getMeasuredWidth () + ((LayoutParams) drawChild.getLayoutParams ()).horizontal_spacing;
        }
    }
}
----------------------------------------

protected void onLayout (boolean changed, int leftPosition, int topPosition, int rightPosition, int bottomPosition) {
    final int widthOffset = getMeasuredWidth () - getPaddingRight ();
    int x = getPaddingLeft ();
    int y = getPaddingTop ();
    Iterator < RowMeasurement > rowIterator = currentRows.iterator ();
    RowMeasurement currentRow = rowIterator.next ();
    for (View child : getLayoutChildren ()) {
        final int childWidth = child.getMeasuredWidth ();
        final int childHeight = child.getMeasuredHeight ();
        if (x + childWidth > widthOffset) {
            x = getPaddingLeft ();
            y += currentRow.height + verticalSpacing;
            if (rowIterator.hasNext ()) {
                currentRow = rowIterator.next ();
            }
        }
        child.layout (x, y, x + childWidth, y + childHeight);
        x += childWidth + horizontalSpacing;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_21893662_113_160
549451_560958_88_108
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int lastHorizontalSpacing = 0;
    int rowStartIdx = 0;
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            if (xpos + childw > width) {
                final int freeSpace = width - xpos + lastHorizontalSpacing;
                xpos = getPaddingLeft () + freeSpace / 2;
                for (int j = rowStartIdx;
                j < i; ++ j) {
                    final View drawChild = getChildAt (j);
                    drawChild.layout (xpos, ypos, xpos + drawChild.getMeasuredWidth (), ypos + drawChild.getMeasuredHeight ());
                    xpos += drawChild.getMeasuredWidth () + ((LayoutParams) drawChild.getLayoutParams ()).horizontal_spacing;
                }
                lastHorizontalSpacing = 0;
                xpos = getPaddingLeft ();
                ypos += line_height;
                rowStartIdx = i;
            }
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + lp.horizontal_spacing;
            lastHorizontalSpacing = lp.horizontal_spacing;
        }
    }
    if (rowStartIdx < count) {
        final int freeSpace = width - xpos + lastHorizontalSpacing;
        xpos = getPaddingLeft () + freeSpace / 2;
        for (int j = rowStartIdx;
        j < count; ++ j) {
            final View drawChild = getChildAt (j);
            drawChild.layout (xpos, ypos, xpos + drawChild.getMeasuredWidth (), ypos + drawChild.getMeasuredHeight ());
            xpos += drawChild.getMeasuredWidth () + ((LayoutParams) drawChild.getLayoutParams ()).horizontal_spacing;
        }
    }
}
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + lp.width;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_21893662_45_91
549451_24040181_30_79
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int line_height = 0;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    } else {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);
    }
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childw = child.getMeasuredWidth ();
            line_height = Math.max (line_height, child.getMeasuredHeight () + lp.vertical_spacing);
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            xpos += childw + lp.horizontal_spacing;
        }
    }
    this.line_height = line_height;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + line_height;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + line_height < height) {
            height = ypos + line_height;
        }
    }

    setMeasuredDimension (width, height);
}
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int maxHeight = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int lineHeight = 0;
    int xAxis = getPaddingLeft ();
    int yAxis = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    } else {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);
    }
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final CentricFlowLayout.LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childMeasuredWidth = child.getMeasuredWidth ();
            lineHeight = Math.max (lineHeight, child.getMeasuredHeight () + lp.verticalSpacing);
            if (xAxis + childMeasuredWidth > width) {
                xAxis = getPaddingLeft ();
                yAxis += lineHeight;
            } else if (i + 1 == count) {
                yAxis += lineHeight;
            }

            xAxis += childMeasuredWidth + lp.horizontalSpacing;
        }
    }
    this.lineHeight = lineHeight;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = yAxis + lineHeight;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (yAxis + lineHeight < height) {
            height = yAxis + lineHeight;
        }
    }

    if (maxHeight == 0) {
        maxHeight = height + getPaddingTop ();
    }
    centricHeightPadding = (maxHeight - height) / 2;
    setMeasuredDimension (width, disableCenterVertical ? height + getPaddingTop () : maxHeight);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_21893662_45_91
549451_4937713_34_70
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int line_height = 0;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    } else {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);
    }
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childw = child.getMeasuredWidth ();
            line_height = Math.max (line_height, child.getMeasuredHeight () + lp.vertical_spacing);
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            xpos += childw + lp.horizontal_spacing;
        }
    }
    this.line_height = line_height;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + line_height;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + line_height < height) {
            height = ypos + line_height;
        }
    }

    setMeasuredDimension (width, height);
}
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    final int widthMode = MeasureSpec.getMode (widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode (heightMeasureSpec);
    final int maxInternalWidth = MeasureSpec.getSize (widthMeasureSpec) - getHorizontalPadding ();
    final int maxInternalHeight = MeasureSpec.getSize (heightMeasureSpec) - getVerticalPadding ();
    List < RowMeasurement > rows = new ArrayList < RowMeasurement > ();
    RowMeasurement currentRow = new RowMeasurement (maxInternalWidth, widthMode);
    rows.add (currentRow);
    for (View child : getLayoutChildren ()) {
        LayoutParams childLayoutParams = child.getLayoutParams ();
        int childWidthSpec = createChildMeasureSpec (childLayoutParams.width, maxInternalWidth, widthMode);
        int childHeightSpec = createChildMeasureSpec (childLayoutParams.height, maxInternalHeight, heightMode);
        child.measure (childWidthSpec, childHeightSpec);
        int childWidth = child.getMeasuredWidth ();
        int childHeight = child.getMeasuredHeight ();
        if (currentRow.wouldExceedMax (childWidth)) {
            currentRow = new RowMeasurement (maxInternalWidth, widthMode);
            rows.add (currentRow);
        }
        currentRow.addChildDimensions (childWidth, childHeight);
    }
    int longestRowWidth = 0;
    int totalRowHeight = 0;
    for (int index = 0;
    index < rows.size (); index ++) {
        RowMeasurement row = rows.get (index);
        totalRowHeight += row.getHeight ();
        if (index < rows.size () - 1) {
            totalRowHeight += verticalSpacing;
        }
        longestRowWidth = Math.max (longestRowWidth, row.getWidth ());
    }
    setMeasuredDimension (widthMode == MeasureSpec.EXACTLY ? MeasureSpec.getSize (widthMeasureSpec) : longestRowWidth + getHorizontalPadding (), heightMode == MeasureSpec.EXACTLY ? MeasureSpec.getSize (heightMeasureSpec) : totalRowHeight + getVerticalPadding ());
    currentRows = Collections.unmodifiableList (rows);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_21893662_45_91
549451_560958_32_75
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int line_height = 0;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    } else {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);
    }
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childw = child.getMeasuredWidth ();
            line_height = Math.max (line_height, child.getMeasuredHeight () + lp.vertical_spacing);
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            xpos += childw + lp.horizontal_spacing;
        }
    }
    this.line_height = line_height;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + line_height;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + line_height < height) {
            height = ypos + line_height;
        }
    }

    setMeasuredDimension (width, height);
}
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec);
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int line_height = 0;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec (height, MeasureSpec.UNSPECIFIED));
            final int childw = child.getMeasuredWidth ();
            line_height = Math.max (line_height, child.getMeasuredHeight () + lp.height);
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            xpos += childw + lp.width;
        }
    }
    this.line_height = line_height;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + line_height;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + line_height < height) {
            height = ypos + line_height;
        }
    }

    setMeasuredDimension (width, height);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_24040181_30_79
549451_4937713_34_70
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int maxHeight = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int lineHeight = 0;
    int xAxis = getPaddingLeft ();
    int yAxis = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    } else {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);
    }
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final CentricFlowLayout.LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childMeasuredWidth = child.getMeasuredWidth ();
            lineHeight = Math.max (lineHeight, child.getMeasuredHeight () + lp.verticalSpacing);
            if (xAxis + childMeasuredWidth > width) {
                xAxis = getPaddingLeft ();
                yAxis += lineHeight;
            } else if (i + 1 == count) {
                yAxis += lineHeight;
            }

            xAxis += childMeasuredWidth + lp.horizontalSpacing;
        }
    }
    this.lineHeight = lineHeight;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = yAxis + lineHeight;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (yAxis + lineHeight < height) {
            height = yAxis + lineHeight;
        }
    }

    if (maxHeight == 0) {
        maxHeight = height + getPaddingTop ();
    }
    centricHeightPadding = (maxHeight - height) / 2;
    setMeasuredDimension (width, disableCenterVertical ? height + getPaddingTop () : maxHeight);
}
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    final int widthMode = MeasureSpec.getMode (widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode (heightMeasureSpec);
    final int maxInternalWidth = MeasureSpec.getSize (widthMeasureSpec) - getHorizontalPadding ();
    final int maxInternalHeight = MeasureSpec.getSize (heightMeasureSpec) - getVerticalPadding ();
    List < RowMeasurement > rows = new ArrayList < RowMeasurement > ();
    RowMeasurement currentRow = new RowMeasurement (maxInternalWidth, widthMode);
    rows.add (currentRow);
    for (View child : getLayoutChildren ()) {
        LayoutParams childLayoutParams = child.getLayoutParams ();
        int childWidthSpec = createChildMeasureSpec (childLayoutParams.width, maxInternalWidth, widthMode);
        int childHeightSpec = createChildMeasureSpec (childLayoutParams.height, maxInternalHeight, heightMode);
        child.measure (childWidthSpec, childHeightSpec);
        int childWidth = child.getMeasuredWidth ();
        int childHeight = child.getMeasuredHeight ();
        if (currentRow.wouldExceedMax (childWidth)) {
            currentRow = new RowMeasurement (maxInternalWidth, widthMode);
            rows.add (currentRow);
        }
        currentRow.addChildDimensions (childWidth, childHeight);
    }
    int longestRowWidth = 0;
    int totalRowHeight = 0;
    for (int index = 0;
    index < rows.size (); index ++) {
        RowMeasurement row = rows.get (index);
        totalRowHeight += row.getHeight ();
        if (index < rows.size () - 1) {
            totalRowHeight += verticalSpacing;
        }
        longestRowWidth = Math.max (longestRowWidth, row.getWidth ());
    }
    setMeasuredDimension (widthMode == MeasureSpec.EXACTLY ? MeasureSpec.getSize (widthMeasureSpec) : longestRowWidth + getHorizontalPadding (), heightMode == MeasureSpec.EXACTLY ? MeasureSpec.getSize (heightMeasureSpec) : totalRowHeight + getVerticalPadding ());
    currentRows = Collections.unmodifiableList (rows);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_24040181_30_79
549451_560958_32_75
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    final int width = MeasureSpec.getSize (widthMeasureSpec) - getPaddingLeft () - getPaddingRight ();
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int maxHeight = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int lineHeight = 0;
    int xAxis = getPaddingLeft ();
    int yAxis = getPaddingTop ();
    int childHeightMeasureSpec;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (height, MeasureSpec.AT_MOST);
    } else {
        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec (0, MeasureSpec.UNSPECIFIED);
    }
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final CentricFlowLayout.LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), childHeightMeasureSpec);
            final int childMeasuredWidth = child.getMeasuredWidth ();
            lineHeight = Math.max (lineHeight, child.getMeasuredHeight () + lp.verticalSpacing);
            if (xAxis + childMeasuredWidth > width) {
                xAxis = getPaddingLeft ();
                yAxis += lineHeight;
            } else if (i + 1 == count) {
                yAxis += lineHeight;
            }

            xAxis += childMeasuredWidth + lp.horizontalSpacing;
        }
    }
    this.lineHeight = lineHeight;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = yAxis + lineHeight;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (yAxis + lineHeight < height) {
            height = yAxis + lineHeight;
        }
    }

    if (maxHeight == 0) {
        maxHeight = height + getPaddingTop ();
    }
    centricHeightPadding = (maxHeight - height) / 2;
    setMeasuredDimension (width, disableCenterVertical ? height + getPaddingTop () : maxHeight);
}
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec);
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int line_height = 0;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec (height, MeasureSpec.UNSPECIFIED));
            final int childw = child.getMeasuredWidth ();
            line_height = Math.max (line_height, child.getMeasuredHeight () + lp.height);
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            xpos += childw + lp.width;
        }
    }
    this.line_height = line_height;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + line_height;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + line_height < height) {
            height = ypos + line_height;
        }
    }

    setMeasuredDimension (width, height);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_24040181_95_125
549451_4937713_86_106
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int yAxis = centricHeightPadding + getPaddingTop () + getPaddingBottom ();
    View child;
    int measuredWidth;
    int lineWidth = getPaddingLeft () + getPaddingRight ();
    CentricFlowLayout.LayoutParams lp;
    int offset;
    LINE_CHILDREN.clear ();
    for (int i = 0;
    i < count; i ++) {
        child = getChildAt (i);
        lp = (LayoutParams) child.getLayoutParams ();
        if (GONE != child.getVisibility ()) {
            measuredWidth = child.getMeasuredWidth ();
            if (lineWidth + measuredWidth + lp.horizontalSpacing > width) {
                offset = (width - lineWidth) / 2;
                layoutHorizontalCentricLine (LINE_CHILDREN, offset, yAxis);
                lineWidth = getPaddingLeft () + getPaddingRight () + measuredWidth + lp.horizontalSpacing;
                yAxis += lineHeight;
                LINE_CHILDREN.clear ();
                LINE_CHILDREN.add (child);
            } else {
                lineWidth += measuredWidth + lp.horizontalSpacing;
                LINE_CHILDREN.add (child);
            }
        }
    }
    offset = (width - lineWidth) / 2;
    layoutHorizontalCentricLine (LINE_CHILDREN, offset, yAxis);
}
----------------------------------------

protected void onLayout (boolean changed, int leftPosition, int topPosition, int rightPosition, int bottomPosition) {
    final int widthOffset = getMeasuredWidth () - getPaddingRight ();
    int x = getPaddingLeft ();
    int y = getPaddingTop ();
    Iterator < RowMeasurement > rowIterator = currentRows.iterator ();
    RowMeasurement currentRow = rowIterator.next ();
    for (View child : getLayoutChildren ()) {
        final int childWidth = child.getMeasuredWidth ();
        final int childHeight = child.getMeasuredHeight ();
        if (x + childWidth > widthOffset) {
            x = getPaddingLeft ();
            y += currentRow.height + verticalSpacing;
            if (rowIterator.hasNext ()) {
                currentRow = rowIterator.next ();
            }
        }
        child.layout (x, y, x + childWidth, y + childHeight);
        x += childWidth + horizontalSpacing;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_24040181_95_125
549451_560958_88_108
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int yAxis = centricHeightPadding + getPaddingTop () + getPaddingBottom ();
    View child;
    int measuredWidth;
    int lineWidth = getPaddingLeft () + getPaddingRight ();
    CentricFlowLayout.LayoutParams lp;
    int offset;
    LINE_CHILDREN.clear ();
    for (int i = 0;
    i < count; i ++) {
        child = getChildAt (i);
        lp = (LayoutParams) child.getLayoutParams ();
        if (GONE != child.getVisibility ()) {
            measuredWidth = child.getMeasuredWidth ();
            if (lineWidth + measuredWidth + lp.horizontalSpacing > width) {
                offset = (width - lineWidth) / 2;
                layoutHorizontalCentricLine (LINE_CHILDREN, offset, yAxis);
                lineWidth = getPaddingLeft () + getPaddingRight () + measuredWidth + lp.horizontalSpacing;
                yAxis += lineHeight;
                LINE_CHILDREN.clear ();
                LINE_CHILDREN.add (child);
            } else {
                lineWidth += measuredWidth + lp.horizontalSpacing;
                LINE_CHILDREN.add (child);
            }
        }
    }
    offset = (width - lineWidth) / 2;
    layoutHorizontalCentricLine (LINE_CHILDREN, offset, yAxis);
}
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + lp.width;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_4937713_34_70
549451_560958_32_75
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    final int widthMode = MeasureSpec.getMode (widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode (heightMeasureSpec);
    final int maxInternalWidth = MeasureSpec.getSize (widthMeasureSpec) - getHorizontalPadding ();
    final int maxInternalHeight = MeasureSpec.getSize (heightMeasureSpec) - getVerticalPadding ();
    List < RowMeasurement > rows = new ArrayList < RowMeasurement > ();
    RowMeasurement currentRow = new RowMeasurement (maxInternalWidth, widthMode);
    rows.add (currentRow);
    for (View child : getLayoutChildren ()) {
        LayoutParams childLayoutParams = child.getLayoutParams ();
        int childWidthSpec = createChildMeasureSpec (childLayoutParams.width, maxInternalWidth, widthMode);
        int childHeightSpec = createChildMeasureSpec (childLayoutParams.height, maxInternalHeight, heightMode);
        child.measure (childWidthSpec, childHeightSpec);
        int childWidth = child.getMeasuredWidth ();
        int childHeight = child.getMeasuredHeight ();
        if (currentRow.wouldExceedMax (childWidth)) {
            currentRow = new RowMeasurement (maxInternalWidth, widthMode);
            rows.add (currentRow);
        }
        currentRow.addChildDimensions (childWidth, childHeight);
    }
    int longestRowWidth = 0;
    int totalRowHeight = 0;
    for (int index = 0;
    index < rows.size (); index ++) {
        RowMeasurement row = rows.get (index);
        totalRowHeight += row.getHeight ();
        if (index < rows.size () - 1) {
            totalRowHeight += verticalSpacing;
        }
        longestRowWidth = Math.max (longestRowWidth, row.getWidth ());
    }
    setMeasuredDimension (widthMode == MeasureSpec.EXACTLY ? MeasureSpec.getSize (widthMeasureSpec) : longestRowWidth + getHorizontalPadding (), heightMode == MeasureSpec.EXACTLY ? MeasureSpec.getSize (heightMeasureSpec) : totalRowHeight + getVerticalPadding ());
    currentRows = Collections.unmodifiableList (rows);
}
----------------------------------------

protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
    assert (MeasureSpec.getMode (widthMeasureSpec) != MeasureSpec.UNSPECIFIED);
    final int width = MeasureSpec.getSize (widthMeasureSpec);
    int height = MeasureSpec.getSize (heightMeasureSpec) - getPaddingTop () - getPaddingBottom ();
    final int count = getChildCount ();
    int line_height = 0;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            child.measure (MeasureSpec.makeMeasureSpec (width, MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec (height, MeasureSpec.UNSPECIFIED));
            final int childw = child.getMeasuredWidth ();
            line_height = Math.max (line_height, child.getMeasuredHeight () + lp.height);
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            xpos += childw + lp.width;
        }
    }
    this.line_height = line_height;
    if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.UNSPECIFIED) {
        height = ypos + line_height;
    } else if (MeasureSpec.getMode (heightMeasureSpec) == MeasureSpec.AT_MOST) {
        if (ypos + line_height < height) {
            height = ypos + line_height;
        }
    }

    setMeasuredDimension (width, height);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
549451_4937713_86_106
549451_560958_88_108
Title: Line-breaking widget layout for Android 
----------------------------------------

protected void onLayout (boolean changed, int leftPosition, int topPosition, int rightPosition, int bottomPosition) {
    final int widthOffset = getMeasuredWidth () - getPaddingRight ();
    int x = getPaddingLeft ();
    int y = getPaddingTop ();
    Iterator < RowMeasurement > rowIterator = currentRows.iterator ();
    RowMeasurement currentRow = rowIterator.next ();
    for (View child : getLayoutChildren ()) {
        final int childWidth = child.getMeasuredWidth ();
        final int childHeight = child.getMeasuredHeight ();
        if (x + childWidth > widthOffset) {
            x = getPaddingLeft ();
            y += currentRow.height + verticalSpacing;
            if (rowIterator.hasNext ()) {
                currentRow = rowIterator.next ();
            }
        }
        child.layout (x, y, x + childWidth, y + childHeight);
        x += childWidth + horizontalSpacing;
    }
}
----------------------------------------

protected void onLayout (boolean changed, int l, int t, int r, int b) {
    final int count = getChildCount ();
    final int width = r - l;
    int xpos = getPaddingLeft ();
    int ypos = getPaddingTop ();
    for (int i = 0;
    i < count; i ++) {
        final View child = getChildAt (i);
        if (child.getVisibility () != GONE) {
            final int childw = child.getMeasuredWidth ();
            final int childh = child.getMeasuredHeight ();
            final LayoutParams lp = (LayoutParams) child.getLayoutParams ();
            if (xpos + childw > width) {
                xpos = getPaddingLeft ();
                ypos += line_height;
            }
            child.layout (xpos, ypos, xpos + childw, ypos + childh);
            xpos += childw + lp.width;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5499523_16536488_18_31
5499523_20931997_2_22
Title: How to avoid Number Format Exception in java? 
----------------------------------------

public static void main (String [] args) {
    String cost = "12.12";
    if (! isEmpty (cost)) {
        try {
            BigDecimal intCost = bigDecimalFormat (cost);
            System.out.println (intCost);
            List < Book > books = bookService.findBooksCheaperThan (intCost);
        } catch (NumberFormatException e) {
            System.out.println ("This is not a number");
            System.out.println (e.getMessage ());
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    String number;
    while (true) {
        try {
            number = JOptionPane.showInputDialog (null);
            if (Main.isNumber (number)) break;

        } catch (NumberFormatException e) {
            System.out.println (e.getMessage ());
        }
    }
    System.out.println ("Your number is " + number);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5499523_19749081_1_101
5499523_20931997_24_34
Title: How to avoid Number Format Exception in java? 
----------------------------------------

public static boolean isNumber (final String str) {
    if (StringUtils.isEmpty (str)) {
        return false;
    }
    final char [] chars = str.toCharArray ();
    int sz = chars.length;
    boolean hasExp = false;
    boolean hasDecPoint = false;
    boolean allowSigns = false;
    boolean foundDigit = false;
    final int start = (chars [0] == '-') ? 1 : 0;
    if (sz > start + 1 && chars [start] == '0' && chars [start + 1] == 'x') {
        int i = start + 2;
        if (i == sz) {
            return false;
        }
        for (; i < chars.length; i ++) {
            if ((chars [i] < '0' || chars [i] > '9') && (chars [i] < 'a' || chars [i] > 'f') && (chars [i] < 'A' || chars [i] > 'F')) {
                return false;
            }
        }
        return true;
    }
    sz --;
    int i = start;
    while (i < sz || (i < sz + 1 && allowSigns && ! foundDigit)) {
        if (chars [i] >= '0' && chars [i] <= '9') {
            foundDigit = true;
            allowSigns = false;
        } else if (chars [i] == '.') {
            if (hasDecPoint || hasExp) {
                return false;
            }
            hasDecPoint = true;
        } else if (chars [i] == 'e' || chars [i] == 'E') {
            if (hasExp) {
                return false;
            }
            if (! foundDigit) {
                return false;
            }
            hasExp = true;
            allowSigns = true;
        } else if (chars [i] == '+' || chars [i] == '-') {
            if (! allowSigns) {
                return false;
            }
            allowSigns = false;
            foundDigit = false;
        } else {
            return false;
        }

        i ++;
    }
    if (i < chars.length) {
        if (chars [i] >= '0' && chars [i] <= '9') {
            return true;
        }
        if (chars [i] == 'e' || chars [i] == 'E') {
            return false;
        }
        if (chars [i] == '.') {
            if (hasDecPoint || hasExp) {
                return false;
            }
            return foundDigit;
        }
        if (! allowSigns && (chars [i] == 'd' || chars [i] == 'D' || chars [i] == 'f' || chars [i] == 'F')) {
            return foundDigit;
        }
        if (chars [i] == 'l' || chars [i] == 'L') {
            return foundDigit && ! hasExp && ! hasDecPoint;
        }
        return false;
    }
    return ! allowSigns && foundDigit;
}
----------------------------------------

public static boolean isNumber (Object o) {
    boolean isNumber = true;
    for (byte b : o.toString ().getBytes ()) {
        char c = (char) b;
        if (! Character.isDigit (c)) isNumber = false;

    }
    return isNumber;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5516383_5516468_2_22
5516383_5516955_12_23
Title: How to return object from Callable() 
----------------------------------------

public static void main (String [] args) throws ExecutionException, InterruptedException {
    Callable callable = new Callable () {
        @Override
        public int [] [] call () throws Exception {
            int [] [] array = new int [5] [];
            for (int i = 0;
            i < array.length; i ++) {
                array [i] = new int [] {5 * i, 5 * i + 1, 5 * i + 2, 5 * i + 3};
            }
            return array;
        }}

    ;
    ExecutorService service = Executors.newFixedThreadPool (2);
    Future < int [] [] > result = service.submit (callable);
    int [] [] intArray = result.get ();
    for (int i = 0;
    i < intArray.length; i ++) {
        System.out.println (Arrays.toString (intArray [i]));
    }
}
----------------------------------------

public static void main (final String [] args) throws ExecutionException, InterruptedException {
    final int [] [] xs = {{1, 2}, {3, 4}};
    final int [] [] ys = {{1, 2}, {3, 4}};
    final Callable < Integer [] [] > callable = getMultiplierCallable (xs, ys, 2);
    final ExecutorService service = Executors.newFixedThreadPool (2);
    final Future < Integer [] [] > result = service.submit (callable);
    final Integer [] [] intArray = result.get ();
    for (final Integer [] element : intArray) {
        System.out.println (Arrays.toString (element));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5516843_50486096_1_16
5516843_5516982_1_23
Title: Count the number of '8's Problem in Java 
----------------------------------------

public int count8 (int n) {
    if (n / 10 == 0 && n % 10 != 8) {
        return 0;
    }
    if (n % 10 == 8 && (n / 10) % 10 == 8) {
        return 2 + count8 (n / 10);
    }
    if (n / 10 == 0 && n % 10 == 8) {
        return 1 + count8 (n / 10);
    }
    if (n % 10 != 8) {
        return 0 + count8 (n / 10);
    } else {
        return 1 + count8 (n / 10);
    }
}
----------------------------------------

public static int count8 (int num) {
    int count = 0;
    boolean doubl = false;
    while (true) {
        int n = num % 10;
        num = num / 10;
        if (n == 8) {
            if (doubl) {
                count = count + 2;
            } else {
                count ++;
            }
            doubl = true;
        } else {
            doubl = false;
        }
        if (num == 0) break;

    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5516843_50486096_1_16
5516843_5517044_1_17
Title: Count the number of '8's Problem in Java 
----------------------------------------

public int count8 (int n) {
    if (n / 10 == 0 && n % 10 != 8) {
        return 0;
    }
    if (n % 10 == 8 && (n / 10) % 10 == 8) {
        return 2 + count8 (n / 10);
    }
    if (n / 10 == 0 && n % 10 == 8) {
        return 1 + count8 (n / 10);
    }
    if (n % 10 != 8) {
        return 0 + count8 (n / 10);
    } else {
        return 1 + count8 (n / 10);
    }
}
----------------------------------------

private int count8 (int n) {
    String nString = Integer.toString (n);
    boolean isPrevChar8 = false;
    int total = 0;
    for (int i = 0;
    i < nString.length (); i ++) {
        char nextChar = nString.charAt (i);
        if (nextChar == '8') {
            total += (isPrevChar8 ? 2 : 1);
            isPrevChar8 = true;
        } else {
            isPrevChar8 = false;
        }
    }
    return total;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5516843_50486096_1_16
5516843_5890946_1_22
Title: Count the number of '8's Problem in Java 
----------------------------------------

public int count8 (int n) {
    if (n / 10 == 0 && n % 10 != 8) {
        return 0;
    }
    if (n % 10 == 8 && (n / 10) % 10 == 8) {
        return 2 + count8 (n / 10);
    }
    if (n / 10 == 0 && n % 10 == 8) {
        return 1 + count8 (n / 10);
    }
    if (n % 10 != 8) {
        return 0 + count8 (n / 10);
    } else {
        return 1 + count8 (n / 10);
    }
}
----------------------------------------

public int count8 (int n) {
    int count = 0;
    if (n == 0) return 0;

    if (n % 100 == 88) {
        count = 3;
        return count + count8 (n / 100);
    } else if (n % 10 == 8) {
        count ++;
        return count + count8 (n / 10);
    } else return count8 (n / 10);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5516843_5516982_1_23
5516843_5517044_1_17
Title: Count the number of '8's Problem in Java 
----------------------------------------

public static int count8 (int num) {
    int count = 0;
    boolean doubl = false;
    while (true) {
        int n = num % 10;
        num = num / 10;
        if (n == 8) {
            if (doubl) {
                count = count + 2;
            } else {
                count ++;
            }
            doubl = true;
        } else {
            doubl = false;
        }
        if (num == 0) break;

    }
    return count;
}
----------------------------------------

private int count8 (int n) {
    String nString = Integer.toString (n);
    boolean isPrevChar8 = false;
    int total = 0;
    for (int i = 0;
    i < nString.length (); i ++) {
        char nextChar = nString.charAt (i);
        if (nextChar == '8') {
            total += (isPrevChar8 ? 2 : 1);
            isPrevChar8 = true;
        } else {
            isPrevChar8 = false;
        }
    }
    return total;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5516843_5516982_1_23
5516843_5890946_1_22
Title: Count the number of '8's Problem in Java 
----------------------------------------

public static int count8 (int num) {
    int count = 0;
    boolean doubl = false;
    while (true) {
        int n = num % 10;
        num = num / 10;
        if (n == 8) {
            if (doubl) {
                count = count + 2;
            } else {
                count ++;
            }
            doubl = true;
        } else {
            doubl = false;
        }
        if (num == 0) break;

    }
    return count;
}
----------------------------------------

public int count8 (int n) {
    int count = 0;
    if (n == 0) return 0;

    if (n % 100 == 88) {
        count = 3;
        return count + count8 (n / 100);
    } else if (n % 10 == 8) {
        count ++;
        return count + count8 (n / 10);
    } else return count8 (n / 10);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5516843_5517044_1_17
5516843_5890946_1_22
Title: Count the number of '8's Problem in Java 
----------------------------------------

private int count8 (int n) {
    String nString = Integer.toString (n);
    boolean isPrevChar8 = false;
    int total = 0;
    for (int i = 0;
    i < nString.length (); i ++) {
        char nextChar = nString.charAt (i);
        if (nextChar == '8') {
            total += (isPrevChar8 ? 2 : 1);
            isPrevChar8 = true;
        } else {
            isPrevChar8 = false;
        }
    }
    return total;
}
----------------------------------------

public int count8 (int n) {
    int count = 0;
    if (n == 0) return 0;

    if (n % 100 == 88) {
        count = 3;
        return count + count8 (n / 100);
    } else if (n % 10 == 8) {
        count ++;
        return count + count8 (n / 10);
    } else return count8 (n / 10);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5520640_20744367_78_94
5520640_5520786_9_42
Title: Encrypting and Decrypting Using Java: Unable to get same output 
----------------------------------------

public static void main (String [] args) {
    try {
        String secretKey = "01234567";
        String data = "test";
        String encryptedData = cipher (secretKey, data);
        System.out.println ("encryptedData: " + encryptedData);
        String decryptedData = decipher (secretKey, encryptedData);
        System.out.println ("decryptedData: " + decryptedData);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) throws Exception {
    String keyString = "averylongtext!@$@#$#@$#*&(*&}{23432432432dsfsdf";
    String input = "john doe";
    Cipher cipher = Cipher.getInstance ("AES/CBC/PKCS5Padding");
    byte [] iv = new byte [cipher.getBlockSize ()];
    new SecureRandom ().nextBytes (iv);
    IvParameterSpec ivSpec = new IvParameterSpec (iv);
    MessageDigest digest = MessageDigest.getInstance ("SHA-256");
    digest.update (keyString.getBytes ());
    byte [] key = new byte [16];
    System.arraycopy (digest.digest (), 0, key, 0, key.length);
    SecretKeySpec keySpec = new SecretKeySpec (key, "AES");
    cipher.init (Cipher.ENCRYPT_MODE, keySpec, ivSpec);
    byte [] encrypted = cipher.doFinal (input.getBytes ("UTF-8"));
    System.out.println ("encrypted: " + new String (encrypted));
    cipher.init (Cipher.DECRYPT_MODE, keySpec, ivSpec);
    byte [] decrypted = cipher.doFinal (encrypted);
    System.out.println ("decrypted: " + new String (decrypted, "UTF-8"));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5524359_5524406_1_30
5524359_5524639_7_62
Title: Can't fit buttons in code 
----------------------------------------

public static void main (String [] args) {
    boolean suc1, suc2, suc3, suc4, suc5, suc6, suc7;
    JFrame f = new JFrame ("Simulator");
    f.setSize (500, 400);
    f.setResizable (false);
    f.setLayout (null);
    f.setVisible (true);
    JButton b1 = new JButton ("Start");
    b1.addActionListener (new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent e) {
            System.out.println ("Button b1 was pressed");
        }}

    );
    JButton b2 = new JButton ("Clear");
    JButton b3 = new JButton ("Find");
    JButton b4 = new JButton ("Stop");
    b1.setBounds (20, 335, 80, 25);
    b2.setBounds (110, 335, 80, 25);
    b3.setBounds (200, 335, 80, 25);
    b4.setBounds (395, 335, 80, 25);
    f.add (b1);
    f.add (b2);
    f.add (b3);
    f.add (b4);
}
----------------------------------------

public static void main (String [] args) {
    Runnable r = new Runnable () {
        public void run () {
            JFrame f = new JFrame ("Simulator");
            f.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
            f.setResizable (false);
            JPanel gui = new JPanel (new BorderLayout (5, 5));
            gui.setBorder (new EmptyBorder (10, 30, 10, 30));
            JPanel simulation = new JPanel ();
            simulation.setPreferredSize (new Dimension (450, 300));
            simulation.setBackground (Color.WHITE);
            gui.add (simulation, BorderLayout.CENTER);
            JPanel buttonPanel = new JPanel (new BorderLayout (50, 5));
            gui.add (buttonPanel, BorderLayout.SOUTH);
            JPanel westButtons = new JPanel (new GridLayout (1, 0, 10, 10));
            JButton b1 = new JButton ("Start");
            JButton b2 = new JButton ("Clear");
            JButton b3 = new JButton ("Find");
            JButton b4 = new JButton ("Stop");
            westButtons.add (b1);
            westButtons.add (b2);
            westButtons.add (b3);
            buttonPanel.add (westButtons, BorderLayout.WEST);
            buttonPanel.add (b4, BorderLayout.EAST);
            f.setContentPane (gui);
            f.pack ();
            f.setVisible (true);
        }}

    ;
    SwingUtilities.invokeLater (r);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5525176_5525213_1_17
5525176_5525891_8_21
Title: Java. Simple TimerTask for each value of array 
----------------------------------------

public static void main (String [] args) throws InterruptedException {
    String [] arrayElements = {"value1", "value2", "value3", "value4"};
    long start = System.currentTimeMillis ();
    for (int i = 0;
    i < arrayElements.length; i ++) {
        final String value = arrayElements [i];
        new java.util.Timer ().schedule (new java.util.TimerTask () {
            public void run () {
                System.out.println (value);
            }}

        , new Date (start));
        start += 5000;
    }
}
----------------------------------------

public static void main (String [] args) {
    final Timer utilTimer = new Timer ();
    utilTimer.scheduleAtFixedRate (new TimerTask () {
        private int index = 0;
        public void run () {
            System.out.println (ARRAY_ELEMENTS [index]);
            index ++;
            if (index >= ARRAY_ELEMENTS.length) {
                utilTimer.cancel ();
            }
        }}

    , 5000L, 5000L);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5526337_5526390_1_13
5526337_5526400_1_10
Title: polymorphic binary search tree 
----------------------------------------

public String toString () {
    String result = "";
    result += (this.left.toString ());
    result += this.key;
    result += "=>";
    result += this.value;
    if (this.right != null) {
        result += " ";
        result += this.right.toString ();
    }
    return result;
}
----------------------------------------

public String toString () {
    StringBuilder result = new StringBuilder ();
    result.append (this.left.toString ());
    result.append (this.key);
    result.append ("=>");
    result.append (this.value);
    result.append (" ");
    result.append (this.right.toString ());
    return result.toString ().trim ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
555503_555513_1_15
555503_555556_12_21
Title: how to convert hex to byte for the following program? 
----------------------------------------

public static byte [] asBytes (String str) {
    if ((str.length () % 2) == 1) str = "0" + str;

    byte [] buf = new byte [str.length () / 2];
    int i = 0;
    for (char c : str.toCharArray ()) {
        byte b = Byte.parseByte (String.valueOf (c), 16);
        buf [i / 2] |= (b << (((i % 2) == 0) ? 4 : 0));
        i ++;
    }
    return buf;
}
----------------------------------------

public static byte [] asBytes (String s) {
    String s2;
    byte [] b = new byte [s.length () / 2];
    int i;
    for (i = 0; i < s.length () / 2; i ++) {
        s2 = s.substring (i * 2, i * 2 + 2);
        b [i] = (byte) (Integer.parseInt (s2, 16) & 0xff);
    }
    return b;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5556499_5556765_17_37
5556499_5557854_24_51
Title: Adding and retrieving elements from arrays of objects in java 
----------------------------------------

public void borrowMovie (String movieTitle) {
    for (Movie item : libMovies) {
        if (movieTitle.equals (item.title)) {
            borrowMovie = true;
            break;
        }
    }
    if (! borrowMovie) {
        System.out.println ("Sorry, this movie is not in our catalog.");
        return;
    }
    if (borrowMovie && ! returnMovie) System.out.println ("You have successfully borrowed " + movieTitle);
    else System.out.println ("Sorry, this movie is already borrowed.");

}
----------------------------------------

public void borrowMovie (String movieTitle) {
    Movie movie = this.movieLibrary.get (movieTitle);
    if (movie == null) {
        System.out.println ("Sorry, this movie is not in our catalog.");
    } else {
        if (movie.isBorrowed ()) {
            System.out.println ("Sorry, this movie is already borrowed.");
        } else {
            try {
                movie.borrow ();
                System.out.println ("You have successfully borrowed " + movieTitle);
            } catch (Exception e) {
                System.out.println ("An internal error has occured while attempting to borrow " + movieTitle + ", error details: " + e.getMessage ());
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5557367_5557613_3_19
5557367_5558090_13_25
Title: changing from JApplet to JFrame 
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        public void run () {
            JFrame calc = new JFrame ();
            CalculatorPanel display = new CalculatorPanel ();
            calc.add (display);
            calc.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
            calc.pack ();
            calc.setVisible (true);
        }}

    );
}
----------------------------------------

public static void main (String [] args) {
    Runnable r = new Runnable () {
        public void run () {
            JFrame f = new JFrame ("Calculator");
            f.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
            f.add (new CalculatorPanel ());
            f.pack ();
            f.setLocationByPlatform (true);
            f.setVisible (true);
        }}

    ;
    SwingUtilities.invokeLater (r);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5560679_48988500_31_47
5560679_6949825_5_16
Title: inserting nodes into a binary tree in java question 
----------------------------------------

public void insert (int element) {
    if (element <= data) {
        if (left == null) setLeft (new TreeNode (element, null, null));
        else left.insert (element);

    } else {
        if (right == null) setRight (new TreeNode (element, null, null));
        else right.insert (element);

    }
}
----------------------------------------

private Node insert (Node nodeIn, int dataIn) {
    if (nodeIn == null) {
        nodeIn = new Node (null, null, dataIn);
    } else {
        if (dataIn < nodeIn.getData ()) {
            nodeIn.setLeft (insert (nodeIn.getLeft (), dataIn));
        } else {
            nodeIn.setRight (insert (nodeIn.getRight (), dataIn));
        }
    }
    return nodeIn;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5575349_5575424_51_64
5575349_5575424_66_79
Title: How do I query a database for only one field of a resultset? (JAVA ODBC) 
----------------------------------------

private static void close (ResultSet result) {
    try {
        if (result != null) {
            result.close ();
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

private static void close (Statement statement) {
    try {
        if (statement != null) {
            statement.close ();
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5576374_5576417_6_26
5576374_5581645_10_22
Title: Why isn't my JScrollPane with a JTextArea visible when using null LayoutManager? 
----------------------------------------

public ScrollPaneTest () {
    setSize (500, 500);
    setLocation (100, 100);
    myCP = this.getContentPane ();
    myCP.setLayout (null);
    resultsTA = new JTextArea ("Blah blah");
    resultsTA.setBounds (10, 10, 150, 30);
    scrollPane = new JScrollPane (resultsTA, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
    scrollPane.setPreferredSize (new Dimension (200, 100));
    scrollPane.setBounds (0, 0, 500, 500);
    myCP.add (scrollPane);
    setVisible (true);
    addWindowListener (new WindowAdapter () {
        public void windowClosing (WindowEvent e) {
            System.exit (0);
        }}

    );
}
----------------------------------------

public ScrollPaneTest () {
    setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    setLocation (100, 100);
    myCP = this.getContentPane ();
    resultsTA = new JTextArea ("Blah blah", 28, 43);
    scrollPane = new JScrollPane (resultsTA, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
    myCP.add (scrollPane);
    setVisible (true);
    pack ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5602463_33965617_5_16
5602463_5602475_5_16
Title: Count how many times a JButton is pressed? 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    clicks ++;
    switch (clicks) {
        case 1 :
            break;
        case 2 :
            break;
    }
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    clicks ++;
    switch (clicks) {
        case '1' :
            break;
        case '2' :
            break;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5603966_17696702_24_32
5603966_5603989_1_15
Title: How to make FileFilter in java? 
----------------------------------------

public boolean accept (File dir, String name) {
    final Iterator < String > extList = exts.iterator ();
    while (extList.hasNext ()) {
        if (name.toLowerCase ().endsWith (extList.next ())) {
            return true;
        }
    }
    return false;
}
----------------------------------------

public boolean accept (File file) {
    if (file.isDirectory ()) {
        return true;
    } else {
        String path = file.getAbsolutePath ().toLowerCase ();
        for (int i = 0, n = extensions.length;
        i < n; i ++) {
            String extension = extensions [i];
            if ((path.endsWith (extension) && (path.charAt (path.length () - extension.length () - 1)) == '.')) {
                return true;
            }
        }
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5614599_15694225_21_36
5614599_21454188_25_35
Title: Simple Lock-Free Stack 
----------------------------------------

public T pop () {
    Node < T > currentHead = null;
    Node < T > futureHead = null;
    do {
        currentHead = head.get ();
        if (currentHead == null) {
            return null;
        }
        futureHead = currentHead.next;
    } while (! head.compareAndSet (currentHead, futureHead));
    return currentHead.data;
}
----------------------------------------

public E pop () {
    E payload;
    while (true) {
        Node < E > oldHeadNode = head.get ();
        if (oldHeadNode == null) {
            return null;
        }
        payload = head.get ().payload;
        if (head.compareAndSet (oldHeadNode, oldHeadNode.next.get ())) {
            break;
        }
    }
    return payload;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5614599_15694225_67_78
5614599_21454188_6_13
Title: Simple Lock-Free Stack 
----------------------------------------

public static void main (String [] args) {
    MyConcurrentStack m = new MyConcurrentStack ();
    m.push (12);
    m.push (13);
    m.push (15);
    System.out.println (m.pop ());
    System.out.println (m.pop ());
    System.out.println (m.pop ());
    System.out.println (m.pop ());
}
----------------------------------------

public static void main (String...args) {
    LFStack < String > stack = new LFStack < String > ();
    for (int i = 0;
    i < 10; i ++) {
        Thread t = new Thread (new RandomStackUse (stack));
        t.setName ("My stack thread " + i);
        t.start ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5619016_5619174_13_24
5619016_5634371_55_80
Title: Java Swing Timer; Create a loop; count to 4 Twice 
----------------------------------------

public void actionPerformed (ActionEvent evt) {
    if (i == 4) {
        if (! flag) {
            System.out.println ("Print me on 4.");
            i = 0;
            flag = true;
        } else {
            timer.stop ();
        }
    }
    i = i + 1;
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    System.out.println ("Flow Here" + "4");
    int fakeSecond = (count ++ % 4) + 1;
    if (fakeSecond == 1) {
        alternativecounter += 1;
        System.out.println ("alternativecounter" + alternativecounter);
        if (alternativecounter == 2) {
            alternativecounter = 0;
            System.out.println ("alternativecounter" + alternativecounter);
            JOptionPane.showMessageDialog (null, "Warm Welcome to you, My dear friend");
        }
    }
    System.out.println ("Flow Here" + "5");
    Calendar now = Calendar.getInstance ();
    int h = now.get (Calendar.HOUR_OF_DAY);
    int m = now.get (Calendar.MINUTE);
    int s = now.get (Calendar.SECOND);
    _textfield1.setText ("" + fakeSecond + "");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5621338_44408753_10_29
5621338_5630271_15_144
Title: How to add JTable in JPanel with null layout? 
----------------------------------------

public static void main (String [] argv) throws Exception {
    DefaultTableModel model = new DefaultTableModel (new String [] [] {{"a", "123"}, {"b", "456"}}, new String [] {"name", "value"});
    JTable t = new JTable (model);
    JPanel panel = new JPanel (null);
    JScrollPane scroll = new JScrollPane (t);
    scroll.setBounds (0, 20, 150, 100);
    panel.add (scroll);
    JFrame frame = new JFrame ();
    frame.add (panel);
    frame.setPreferredSize (new Dimension (200, 200));
    frame.pack ();
    frame.setVisible (true);
}
----------------------------------------

public static void main (String [] args) {
    Runnable r = new Runnable () {
        public void run () {
            final JFrame frame = new JFrame ("Nested Layout Example");
            frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
            final JPanel gui = new JPanel (new BorderLayout (5, 5));
            gui.setBorder (new TitledBorder ("BorderLayout(5,5)"));
            JPanel plafComponents = new JPanel (new FlowLayout (FlowLayout.RIGHT, 3, 3));
            plafComponents.setBorder (new TitledBorder ("FlowLayout(FlowLayout.RIGHT, 3,3)"));
            final UIManager.LookAndFeelInfo [] plafInfos = UIManager.getInstalledLookAndFeels ();
            String [] plafNames = new String [plafInfos.length];
            for (int ii = 0;
            ii < plafInfos.length; ii ++) {
                plafNames [ii] = plafInfos [ii].getName ();
            }
            final JComboBox plafChooser = new JComboBox (plafNames);
            plafComponents.add (plafChooser);
            final JCheckBox pack = new JCheckBox ("Pack on PLAF change", true);
            plafComponents.add (pack);
            plafChooser.addActionListener (new ActionListener () {
                public void actionPerformed (ActionEvent ae) {
                    int index = plafChooser.getSelectedIndex ();
                    try {
                        UIManager.setLookAndFeel (plafInfos [index].getClassName ());
                        SwingUtilities.updateComponentTreeUI (frame);
                        if (pack.isSelected ()) {
                            frame.pack ();
                            frame.setMinimumSize (frame.getSize ());
                        }
                    } catch (Exception e) {
                        e.printStackTrace ();
                    }
                }}

            );
            gui.add (plafComponents, BorderLayout.NORTH);
            JPanel dynamicLabels = new JPanel (new BorderLayout (4, 4));
            dynamicLabels.setBorder (new TitledBorder ("BorderLayout(4,4)"));
            gui.add (dynamicLabels, BorderLayout.WEST);
            final JPanel labels = new JPanel (new GridLayout (0, 2, 3, 3));
            labels.setBorder (new TitledBorder ("GridLayout(0,2,3,3)"));
            JButton addNew = new JButton ("Add Another Label");
            dynamicLabels.add (addNew, BorderLayout.NORTH);
            addNew.addActionListener (new ActionListener () {
                private int labelCount = 0;
                public void actionPerformed (ActionEvent ae) {
                    labels.add (new JLabel ("Label " + ++ labelCount));
                    frame.validate ();
                }}

            );
            dynamicLabels.add (new JScrollPane (labels), BorderLayout.CENTER);
            String [] header = {"Name", "Value"};
            String [] a = new String [0];
            String [] names = System.getProperties ().stringPropertyNames ().toArray (a);
            String [] [] data = new String [names.length] [2];
            for (int ii = 0;
            ii < names.length; ii ++) {
                data [ii] [0] = names [ii];
                data [ii] [1] = System.getProperty (names [ii]);
            }
            DefaultTableModel model = new DefaultTableModel (data, header);
            JTable table = new JTable (model);
            try {
                table.setAutoCreateRowSorter (true);
            } catch (Exception continuewithNoSort) {
            }
            JScrollPane tableScroll = new JScrollPane (table);
            Dimension tablePreferred = tableScroll.getPreferredSize ();
            tableScroll.setPreferredSize (new Dimension (tablePreferred.width, tablePreferred.height / 3));
            JPanel imagePanel = new JPanel (new GridBagLayout ());
            imagePanel.setBorder (new TitledBorder ("GridBagLayout()"));
            BufferedImage bi = new BufferedImage (200, 200, BufferedImage.TYPE_INT_ARGB);
            Graphics2D g = bi.createGraphics ();
            GradientPaint gp = new GradientPaint (20f, 20f, Color.red, 180f, 180f, Color.yellow);
            g.setPaint (gp);
            g.fillRect (0, 0, 200, 200);
            ImageIcon ii = new ImageIcon (bi);
            JLabel imageLabel = new JLabel (ii);
            imagePanel.add (imageLabel, null);
            JSplitPane splitPane = new JSplitPane (JSplitPane.VERTICAL_SPLIT, tableScroll, new JScrollPane (imagePanel));
            gui.add (splitPane, BorderLayout.CENTER);
            frame.setContentPane (gui);
            frame.pack ();
            frame.setLocationRelativeTo (null);
            try {
                frame.setLocationByPlatform (true);
                frame.setMinimumSize (frame.getSize ());
            } catch (Throwable ignoreAndContinue) {
            }
            frame.setVisible (true);
        }}

    ;
    SwingUtilities.invokeLater (r);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5622135_5624379_14_51
5622135_5624379_53_76
Title: Need Help Programming Battleship Location Selector/Checker 
----------------------------------------

public void place (Ship [] ships) {
    Arrays.sort (ships, new Comparator < Ship > () {
        @Override
        public int compare (Ship s1, Ship s2) {
            return Integer.valueOf (s1.size).compareTo (Integer.valueOf (s2.size));
        }}

    );
    for (int j = 0;
    j < rows; j ++) for (int k = 0;
    k < cols; k ++) board [j] [k] = '-';

    char [] [] checked = new char [rows] [cols];
    Random random = new Random ();
    for (int i = ships.length - 1;
    i >= 0; i --) {
        for (int j = 0;
        j < rows; j ++) for (int k = 0;
        k < cols; k ++) checked [j] [k] = 'U';

        boolean placed = false;
        while (! placed) {
            int r = random.nextInt (rows);
            int c = random.nextInt (cols);
            if (checked [r] [c] == 'U') {
                checked [r] [c] = 'C';
                if (board [r] [c] == '-') {
                    int direction = random.nextInt (4);
                    if (canPlace (ships [i], r, c, direction)) {
                        place (ships [i], r, c, direction);
                        placed = true;
                    }
                }
            }
        }
    }
}
----------------------------------------

private void place (Ship ship, int row, int col, int direction) {
    int size = ship.getSize ();
    switch (direction) {
        case 0 :
            for (int i = row;
            i >= row - (size - 1); i --) board [i] [col] = 'S';

            break;
        case 1 :
            for (int i = col;
            i <= col + (size - 1); i ++) board [row] [i] = 'S';

            break;
        case 2 :
            for (int i = row;
            i <= row + (size - 1); i ++) board [i] [col] = 'S';

            break;
        default :
            for (int i = col;
            i >= col - (size - 1); i --) board [row] [i] = 'S';

            break;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5624364_14920602_3_14
5624364_36465436_53_68
Title: "Exception in thread ""main"" java.lang.ArrayIndexOutOfBoundsException: 0 error in Java" 
----------------------------------------

public static void main (String [] args) {
    int argslen = args.length;
    int argsValue [] = new int [argslen];
    for (String i : args) {
        int d = 0;
        argsValue [d] = Integer.parseInt (i);
        System.out.print (argsValue [d] + "\t");
    }
}
----------------------------------------

public static void main (String [] args) {
    Point [] t = {new Point (1, 3), new Point (0, 2), new Point (0, 0), new Point (3, 5), new Point (4, 4), new Point (0, 4), new Point (4, 2), new Point (4, 0), new Point (1, 1)};
    LignePol lp = new LignePol (t);
    double m = Double.parseDouble (args [0]);
    double n = Double.parseDouble (args [1]);
    double l = Double.parseDouble (args [1]);
    lp.homothetie (l / 4.0);
    lp.translation (m, n);
    lp.tracer ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5644468_5644490_2_11
5644468_5644766_2_10
Title: append binary values of integers read from an array 
----------------------------------------

public static void main (String [] args) {
    int [] arr = new int [] {1, 5};
    StringWriter sw = new StringWriter ();
    for (int i = 0;
    i < arr.length; i ++) {
        int val = arr [i];
        String s = String.format ("%08s", Integer.toBinaryString (val));
        sw.append (s);
    }
    System.out.println ("final: " + Integer.parseInt (sw.toString (), 2));
}
----------------------------------------

public static void main (String [] args) {
    int [] arr = new int [] {1, 5};
    int sum = 0;
    for (int i = 0;
    i < arr.length; i ++) {
        int val = arr [i];
        sum = (sum << 8) + val;
    }
    System.out.println ("final: " + sum);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5667454_5668510_199_256
5667454_5668510_259_279
Title: Playing MP3 using Java Sound API 
----------------------------------------

public void open (AudioInputStream stream) throws IOException, LineUnavailableException {
    AudioInputStream is1;
    format = stream.getFormat ();
    if (format.getEncoding () != AudioFormat.Encoding.PCM_SIGNED) {
        is1 = AudioSystem.getAudioInputStream (AudioFormat.Encoding.PCM_SIGNED, stream);
    } else {
        is1 = stream;
    }
    format = is1.getFormat ();
    InputStream is2;
    if (parent != null) {
        ProgressMonitorInputStream pmis = new ProgressMonitorInputStream (parent, "Loading track..", is1);
        pmis.getProgressMonitor ().setMillisToPopup (0);
        is2 = pmis;
    } else {
        is2 = is1;
    }
    byte [] buf = new byte [(int) Math.pow (2, 16)];
    int totalRead = 0;
    int numRead = 0;
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    numRead = is2.read (buf);
    while (numRead > - 1) {
        baos.write (buf, 0, numRead);
        numRead = is2.read (buf, 0, buf.length);
        totalRead += numRead;
    }
    is2.close ();
    audioData = baos.toByteArray ();
    AudioFormat afTemp;
    if (format.getChannels () < 2) {
        afTemp = new AudioFormat (format.getEncoding (), format.getSampleRate (), format.getSampleSizeInBits (), 2, format.getSampleSizeInBits () * 2 / 8, format.getFrameRate (), format.isBigEndian ());
    } else {
        afTemp = format;
    }
    setLoopPoints (0, audioData.length);
    dataLine = AudioSystem.getSourceDataLine (afTemp);
    dataLine.open ();
    inputStream = new ByteArrayInputStream (audioData);
}
----------------------------------------

public void open (AudioFormat format, byte [] data, int offset, int bufferSize) throws LineUnavailableException {
    byte [] input = new byte [bufferSize];
    for (int ii = 0;
    ii < input.length; ii ++) {
        input [ii] = data [offset + ii];
    }
    ByteArrayInputStream inputStream = new ByteArrayInputStream (input);
    try {
        AudioInputStream ais1 = AudioSystem.getAudioInputStream (inputStream);
        AudioInputStream ais2 = AudioSystem.getAudioInputStream (format, ais1);
        open (ais2);
    } catch (UnsupportedAudioFileException uafe) {
        throw new IllegalArgumentException (uafe);
    } catch (IOException ioe) {
        throw new IllegalArgumentException (ioe);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5695874_5695896_8_22
5695874_5696157_1_25
Title: Printing counters in nested loops 
----------------------------------------

public static void main (String [] args) throws Exception {
    try {
        PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter ("/Users/evanlivingston/1.txt", true)));
        String output = "";
        for (int counter = 1;
        counter < 16; counter ++) {
            output = Integer.toString (counter) + ".";
            for (int counter2 = 1;
            counter2 < 5; counter2 ++) {
                out.print (test + Integer.toString (counter2) + "\n");
            }
        }
        out.close ();
    } catch (IOException e) {
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    PrintWriter out = null;
    try {
        out = new PrintWriter (new BufferedWriter (new FileWriter (yourFileName, true)));
        for (float i = 1.0F;
        i < 16; i += 0.1F) {
            out.println (String.format ("%.1f", i));
            if (i >= (((int) i) + 0.4)) {
                i += 0.5;
            }
        }
    } finally {
        if (out != null) {
            out.close ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5699323_5711200_21_40
5699323_5711200_2_19
Title: Using JSON with MongoDB? 
----------------------------------------

public static DBObject encode (JSONObject o) {
    BasicDBObject result = new BasicDBObject ();
    try {
        Iterator i = o.keys ();
        while (i.hasNext ()) {
            String k = (String) i.next ();
            Object v = o.get (k);
            if (v instanceof JSONArray) {
                result.put (k, encode ((JSONArray) v));
            } else if (v instanceof JSONObject) {
                result.put (k, encode ((JSONObject) v));
            } else {
                result.put (k, v);
            }

        }
        return result;
    } catch (JSONException je) {
        return null;
    }
}
----------------------------------------

public static DBObject encode (JSONArray a) {
    BasicDBList result = new BasicDBList ();
    try {
        for (int i = 0;
        i < a.length (); ++ i) {
            Object o = a.get (i);
            if (o instanceof JSONObject) {
                result.add (encode ((JSONObject) o));
            } else if (o instanceof JSONArray) {
                result.add (encode ((JSONArray) o));
            } else {
                result.add (o);
            }

        }
        return result;
    } catch (JSONException je) {
        return null;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5741038_18089051_1_10
5741038_5741080_1_13
Title: Remove duplicates from ArrayLists 
----------------------------------------

private static List < Integer > removeDuplicates (List < Integer > list) {
    ArrayList < Integer > uniqueList = new ArrayList < Integer > ();
    for (Integer i : list) {
        if (! inArray (i, uniqueList)) {
            uniqueList.add (i);
        }
    }
    return uniqueList;
}
----------------------------------------

public void removeDuplicates (List < Object > l) {
    Set < Object > s = new TreeSet < Object > (new Comparator < Object > () {
        @Override
        public int compare (Object o1, Object o2) {
            return 0;
        }}

    );
    s.addAll (l);
    List < Object > res = Arrays.asList (s.toArray ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5743267_5743384_108_120
5743267_5743832_122_157
Title: Android Emulator connecting to Local Web service 
----------------------------------------

private InputStream retrieveStream (String url) {
    DefaultHttpClient client = new DefaultHttpClient ();
    HttpGet getRequest;
    try {
        getRequest = new HttpGet (url);
        HttpResponse getResponse = client.execute (getRequest);
        HttpEntity getResponseEntity = getResponse.getEntity ();
        return getResponseEntity.getContent ();
    } catch (Exception e) {
        Log.w (getClass ().getSimpleName (), "Error for URL " + url, e);
        return null;
    }
}
----------------------------------------

private InputStream retrieveStream (String url) {
    DefaultHttpClient client = new DefaultHttpClient ();
    HttpGet getRequest;
    try {
        getRequest = new HttpGet (url);
        try {
            HttpResponse getResponse = client.execute (getRequest);
            final int statusCode = getResponse.getStatusLine ().getStatusCode ();
            if (statusCode != HttpStatus.SC_OK) {
                Log.w (getClass ().getSimpleName (), "Error " + statusCode + " for URL " + url);
                return null;
            }
            HttpEntity getResponseEntity = getResponse.getEntity ();
            try {
                return getResponseEntity.getContent ();
            } catch (IllegalStateException e) {
                getRequest.abort ();
                Log.w (getClass ().getSimpleName (), "Error for URL " + url, e);
                return null;
            } catch (IOException e) {
                getRequest.abort ();
                Log.w (getClass ().getSimpleName (), "Error for URL " + url, e);
                return null;
            }
        } catch (ClientProtocolException e) {
            getRequest.abort ();
            Log.w (getClass ().getSimpleName (), "Error for URL " + url, e);
        } catch (IOException e) {
            getRequest.abort ();
            Log.w (getClass ().getSimpleName (), "Error for URL " + url, e);
        }
    } catch (IllegalArgumentException e) {
        Log.w (getClass ().getSimpleName (), "Error for URL " + url, e);
    }
    return null;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5743267_5743384_30_41
5743267_5743832_35_46
Title: Android Emulator connecting to Local Web service 
----------------------------------------

public void onCreate (Bundle savedInstanceState) {
    super.onCreate (savedInstanceState);
    setContentView (R.layout.main);
    Button button = (Button) findViewById (R.id.button1);
    button.setOnClickListener (new View.OnClickListener () {
        public void onClick (View v) {
            _initTask = new InitTask ();
            _initTask.execute (getApplicationContext ());
        }}

    );
}
----------------------------------------

public void onCreate (Bundle savedInstanceState) {
    super.onCreate (savedInstanceState);
    setContentView (R.layout.main);
    Button button = (Button) findViewById (R.id.button1);
    button.setOnClickListener (new View.OnClickListener () {
        public void onClick (View v) {
            _initTask = new InitTask ();
            _initTask.execute (getApplicationContext ());
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5743267_5743384_52_72
5743267_5743832_57_86
Title: Android Emulator connecting to Local Web service 
----------------------------------------

protected SearchResponse doInBackground (Context...params) {
    InputStream source = retrieveStream (url);
    SearchResponse response = null;
    if (source != null) {
        Gson gson = new Gson ();
        Reader reader = new InputStreamReader (source);
        try {
            response = gson.fromJson (reader, SearchResponse.class);
            publishProgress (response.query);
            reader.close ();
        } catch (Exception e) {
            Log.w (getClass ().getSimpleName (), "Error: " + e.getMessage () + " for URL " + url);
        }
    }
    if (! this.isCancelled ()) {
        return response;
    } else {
        return null;
    }
}
----------------------------------------

protected SearchResponse doInBackground (Context...params) {
    InputStream source = retrieveStream (url);
    SearchResponse response = null;
    if (source != null) {
        Gson gson = new Gson ();
        Reader reader = new InputStreamReader (source);
        try {
            response = gson.fromJson (reader, SearchResponse.class);
            publishProgress (response.query);
        } catch (JsonSyntaxException e) {
            Log.w (getClass ().getSimpleName (), "Error: " + e.getMessage () + " for URL " + url);
            return null;
        } catch (JsonIOException e) {
            Log.w (getClass ().getSimpleName (), "Error: " + e.getMessage () + " for URL " + url);
            return null;
        } finally {
            try {
                reader.close ();
            } catch (IOException e) {
                Log.w (getClass ().getSimpleName (), "Error: " + e.getMessage () + " for URL " + url);
            }
        }
    }
    if (! this.isCancelled ()) {
        return response;
    } else {
        return null;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5743267_5743384_82_100
5743267_5743832_96_114
Title: Android Emulator connecting to Local Web service 
----------------------------------------

protected void onPostExecute (SearchResponse response) {
    super.onPostExecute (response);
    StringBuilder builder = new StringBuilder ();
    if (response != null) {
        String delim = "* ";
        List < Result > results = response.results;
        for (Result result : results) {
            builder.append (delim).append (result.fromUser);
            delim = "\n* ";
        }
    }
    if (builder.length () > 0) {
        Toast.makeText (getApplicationContext (), builder.toString (), Toast.LENGTH_SHORT).show ();
    } else {
        Toast.makeText (getApplicationContext (), "The response was empty.", Toast.LENGTH_SHORT).show ();
    }
}
----------------------------------------

protected void onPostExecute (SearchResponse response) {
    super.onPostExecute (response);
    StringBuilder builder = new StringBuilder ();
    if (response != null) {
        String delim = "* ";
        List < Result > results = response.results;
        for (Result result : results) {
            builder.append (delim).append (result.fromUser);
            delim = "\n* ";
        }
    }
    if (builder.length () > 0) {
        Toast.makeText (getApplicationContext (), builder.toString (), Toast.LENGTH_SHORT).show ();
    } else {
        Toast.makeText (getApplicationContext (), "The response was empty.", Toast.LENGTH_SHORT).show ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5758956_5759149_12_30
5758956_5760305_7_24
Title: input Pattern matching java 
----------------------------------------

static int validate (String pattern) {
    String input = "";
    boolean validInput = false;
    do {
        try {
            BufferedReader br = new BufferedReader (new InputStreamReader (System.in));
            input = br.readLine ();
            if (input.matches (pattern)) validInput = true;

        } catch (Exception e) {
            System.out.println ("" + e);
        }
    } while (! validInput);
    return Integer.parseInt (input);
}
----------------------------------------

static String validate (String options) {
    boolean validInput = false;
    String input = "";
    do {
        System.out.println ("Enter one of the following: " + options);
        BufferedReader br = new BufferedReader (new InputStreamReader (System.in));
        try {
            input = br.readLine ();
            if (input.length () == 1 && options.indexOf (input) >= 0) {
                validInput = true;
            }
        } catch (IOException ex) {
        }
    } while (! validInput);
    return input;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5760738_12485490_5_49
5760738_47853571_4_22
Title: "Given a target sum find if there is a pair of element in the given array which sums up to it" 
----------------------------------------

public static void main (String arg []) throws IOException {
    HashMap h1 = new HashMap ();
    h1.put ("1st", new Integer (10));
    h1.put ("2nd", new Integer (24));
    h1.put ("3rd", new Integer (12));
    h1.put ("4th", new Integer (9));
    h1.put ("5th", new Integer (43));
    h1.put ("6th", new Integer (13));
    h1.put ("7th", new Integer (5));
    h1.put ("8th", new Integer (32));
    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));
    System.out.println ("Enter no.");
    int no = Integer.parseInt (br.readLine ());
    Iterator i = h1.entrySet ().iterator ();
    boolean flag = false;
    while (i.hasNext ()) {
        Map.Entry e1 = (Map.Entry) i.next ();
        Integer n1 = (Integer) e1.getValue ();
        Iterator j = h1.entrySet ().iterator ();
        while (j.hasNext ()) {
            Map.Entry e2 = (Map.Entry) j.next ();
            Integer n2 = (Integer) e2.getValue ();
            if (no == (n1 + n2)) {
                System.out.println ("Pair of elements:" + n1 + " " + n2);
                flag = true;
            }
        }
    }
    if (flag == false) System.out.println ("No pairs");

}
----------------------------------------

public static void main (String [] args) {
    Map < Integer, Integer > hm = new HashMap < Integer, Integer > ();
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter the sum key: ");
    int sum = sc.nextInt ();
    for (int i = 0;
    i < 10; i ++) {
        int x = sc.nextInt ();
        if (! hm.containsKey (sum - x)) {
            hm.put (x, 1);
        } else {
            System.out.println ("Array contains two elements with sum equals to: " + sum);
            break;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5760738_12485490_5_49
5760738_6131081_63_78
Title: "Given a target sum find if there is a pair of element in the given array which sums up to it" 
----------------------------------------

public static void main (String arg []) throws IOException {
    HashMap h1 = new HashMap ();
    h1.put ("1st", new Integer (10));
    h1.put ("2nd", new Integer (24));
    h1.put ("3rd", new Integer (12));
    h1.put ("4th", new Integer (9));
    h1.put ("5th", new Integer (43));
    h1.put ("6th", new Integer (13));
    h1.put ("7th", new Integer (5));
    h1.put ("8th", new Integer (32));
    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));
    System.out.println ("Enter no.");
    int no = Integer.parseInt (br.readLine ());
    Iterator i = h1.entrySet ().iterator ();
    boolean flag = false;
    while (i.hasNext ()) {
        Map.Entry e1 = (Map.Entry) i.next ();
        Integer n1 = (Integer) e1.getValue ();
        Iterator j = h1.entrySet ().iterator ();
        while (j.hasNext ()) {
            Map.Entry e2 = (Map.Entry) j.next ();
            Integer n2 = (Integer) e2.getValue ();
            if (no == (n1 + n2)) {
                System.out.println ("Pair of elements:" + n1 + " " + n2);
                flag = true;
            }
        }
    }
    if (flag == false) System.out.println ("No pairs");

}
----------------------------------------

public static void main (String [] args) {
    int [] input1 = {2, 3, 8, 12, 1, 4, 7, 3, 8, 22};
    int [] input2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int [] input3 = {2, - 3, 8, 12, 1, 4, 7, 3, 8, 22};
    int target1 = 19;
    int target2 = 16;
    FindNums.findSumsForTarget (input1, target1);
    FindNums.findSumsForTarget (input1, - 1);
    FindNums.findSumsForTarget (input2, target2);
    FindNums.findSumsForTarget (input3, target1);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5760738_47853571_4_22
5760738_6131081_63_78
Title: "Given a target sum find if there is a pair of element in the given array which sums up to it" 
----------------------------------------

public static void main (String [] args) {
    Map < Integer, Integer > hm = new HashMap < Integer, Integer > ();
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter the sum key: ");
    int sum = sc.nextInt ();
    for (int i = 0;
    i < 10; i ++) {
        int x = sc.nextInt ();
        if (! hm.containsKey (sum - x)) {
            hm.put (x, 1);
        } else {
            System.out.println ("Array contains two elements with sum equals to: " + sum);
            break;
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int [] input1 = {2, 3, 8, 12, 1, 4, 7, 3, 8, 22};
    int [] input2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int [] input3 = {2, - 3, 8, 12, 1, 4, 7, 3, 8, 22};
    int target1 = 19;
    int target2 = 16;
    FindNums.findSumsForTarget (input1, target1);
    FindNums.findSumsForTarget (input1, - 1);
    FindNums.findSumsForTarget (input2, target2);
    FindNums.findSumsForTarget (input3, target1);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5769965_5770064_25_69
5769965_8269133_19_46
Title: Java File Encryption missing bytes 
----------------------------------------

public static void main (String [] args) {
    if (args.length < 2 || args.length > 4 || ! args [0].matches ("-genkey|-encrypt|-decrypt")) {
        usage ();
        return;
    }
    try {
        if ("-genkey".equals (args [0])) {
            KeyGenerator keygen = KeyGenerator.getInstance ("DES");
            SecureRandom random = new SecureRandom ();
            keygen.init (random);
            SecretKey key = keygen.generateKey ();
            ObjectOutputStream out = new ObjectOutputStream (new FileOutputStream (args [1]));
            out.writeObject (key);
            out.close ();
        } else {
            int mode;
            if ("-encrypt".equals (args [0])) {
                mode = Cipher.ENCRYPT_MODE;
            } else {
                mode = Cipher.DECRYPT_MODE;
            }
            ObjectInputStream keyIn = new ObjectInputStream (new FileInputStream (args [3]));
            Key key = (Key) keyIn.readObject ();
            keyIn.close ();
            InputStream in = new FileInputStream (args [1]);
            OutputStream out = new FileOutputStream (args [2]);
            Cipher cipher = Cipher.getInstance ("DES");
            cipher.init (mode, key);
            crypt (in, out, cipher);
            in.close ();
            out.close ();
        }
    } catch (IOException exception) {
        exception.printStackTrace ();
    } catch (GeneralSecurityException exception) {
        exception.printStackTrace ();
    } catch (ClassNotFoundException exception) {
        exception.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) throws Exception {
    String keyString = "ssssssssssssssss";
    byte [] key = keyString.getBytes ();
    System.out.println (asHex (key).toUpperCase ());
    String clearText = "sdhhgfffhamayaqqqaaaa";
    byte [] clear = clearText.getBytes ();
    System.out.println (asHex (clear).toUpperCase ());
    SecretKeySpec skeySpec = new SecretKeySpec (key, "AES");
    Cipher cipher = Cipher.getInstance ("AES/ECB/NoPadding");
    cipher.init (Cipher.ENCRYPT_MODE, skeySpec);
    byte [] encrypted = cipher.doFinal (clear);
    System.out.println (asHex (encrypted).toUpperCase ());
    cipher.init (Cipher.DECRYPT_MODE, skeySpec);
    byte [] original = cipher.doFinal (encrypted);
    System.out.println (original);
    String originalString = new String (original);
    System.out.println ("Original string: " + originalString + " " + asHex (original));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5771827_22752388_259_279
5771827_47067805_352_377
Title: Implementing an AVL tree in JAVA 
----------------------------------------

public static void main (String [] args) {
    AVLTree avl = new AVLTree ();
    avl.insert (1);
    avl.traverseInOrder ();
    avl.insert (2);
    avl.traverseInOrder ();
    avl.insert (3);
    avl.traverseInOrder ();
    avl.insert (4);
    avl.traverseInOrder ();
    avl.delete (1);
    avl.traverseInOrder ();
    avl.insert (5);
    avl.traverseInOrder ();
    avl.insert (6);
    avl.traverseInOrder ();
    avl.delete (3);
    avl.traverseInOrder ();
    avl.delete (5);
    avl.traverseInOrder ();
}
----------------------------------------

public static void main (String [] args) {
    AVLTreeRecursive < Integer > tree = new AVLTreeRecursive < > ();
    tree.insert (7);
    tree.insert (16);
    tree.insert (- 2);
    tree.insert (10);
    tree.insert (12);
    for (Integer value : tree) System.out.print (value + " ");

    System.out.println ();
    tree.remove (12);
    tree.remove (- 5);
    tree.remove (10);
    for (Integer value : tree) System.out.print (value + " ");

    System.out.println ();
    System.out.println (tree.contains (10));
    System.out.println (tree.contains (16));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5771827_22752388_47_84
5771827_47067805_80_88
Title: Implementing an AVL tree in JAVA 
----------------------------------------

private void insert (Node node, int value) {
    if (root == null) {
        root = new Node (value, null);
        return;
    }
    if (value < node.value) {
        if (node.left != null) {
            insert (node.left, value);
        } else {
            node.left = new Node (value, node);
        }
        if (height (node.left) - height (node.right) == 2) {
            if (value < node.left.value) {
                rotateRight (node);
            } else {
                rotateLeftThenRight (node);
            }
        }
    } else if (value > node.value) {
        if (node.right != null) {
            insert (node.right, value);
        } else {
            node.right = new Node (value, node);
        }
        if (height (node.right) - height (node.left) == 2) {
            if (value > node.right.value) rotateLeft (node);
            else {
                rotateRightThenLeft (node);
            }
        }
    }

    reHeight (node);
}
----------------------------------------

public boolean insert (T value) {
    if (value == null) return false;

    if (! contains (root, value)) {
        root = insert (root, value);
        nodeCount ++;
        return true;
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5771827_22752388_47_84
5771827_47067805_91_114
Title: Implementing an AVL tree in JAVA 
----------------------------------------

private void insert (Node node, int value) {
    if (root == null) {
        root = new Node (value, null);
        return;
    }
    if (value < node.value) {
        if (node.left != null) {
            insert (node.left, value);
        } else {
            node.left = new Node (value, node);
        }
        if (height (node.left) - height (node.right) == 2) {
            if (value < node.left.value) {
                rotateRight (node);
            } else {
                rotateLeftThenRight (node);
            }
        }
    } else if (value > node.value) {
        if (node.right != null) {
            insert (node.right, value);
        } else {
            node.right = new Node (value, node);
        }
        if (height (node.right) - height (node.left) == 2) {
            if (value > node.right.value) rotateLeft (node);
            else {
                rotateRightThenLeft (node);
            }
        }
    }

    reHeight (node);
}
----------------------------------------

private Node insert (Node node, T value) {
    if (node == null) return new Node (value);

    int cmp = value.compareTo (node.value);
    if (cmp < 0) {
        node.left = insert (node.left, value);
    } else {
        node.right = insert (node.right, value);
    }
    update (node);
    return balance (node);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5771827_47067805_201_212
5771827_47067805_215_283
Title: Implementing an AVL tree in JAVA 
----------------------------------------

public boolean remove (T elem) {
    if (elem == null) return false;

    if (contains (root, elem)) {
        root = remove (root, elem);
        nodeCount --;
        return true;
    }
    return false;
}
----------------------------------------

private Node remove (Node node, T elem) {
    if (node == null) return null;

    int cmp = elem.compareTo (node.value);
    if (cmp < 0) {
        node.left = remove (node.left, elem);
    } else if (cmp > 0) {
        node.right = remove (node.right, elem);
    } else {
        if (node.left == null) {
            return node.right;
        } else if (node.right == null) {
            return node.left;
        } else {
            if (node.left.height > node.right.height) {
                T successorValue = findMax (node.left);
                node.value = successorValue;
                node.left = remove (node.left, successorValue);
            } else {
                T successorValue = findMin (node.right);
                node.value = successorValue;
                node.right = remove (node.right, successorValue);
            }
        }

    }

    update (node);
    return balance (node);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5771827_47067805_80_88
5771827_47067805_91_114
Title: Implementing an AVL tree in JAVA 
----------------------------------------

public boolean insert (T value) {
    if (value == null) return false;

    if (! contains (root, value)) {
        root = insert (root, value);
        nodeCount ++;
        return true;
    }
    return false;
}
----------------------------------------

private Node insert (Node node, T value) {
    if (node == null) return new Node (value);

    int cmp = value.compareTo (node.value);
    if (cmp < 0) {
        node.left = insert (node.left, value);
    } else {
        node.right = insert (node.right, value);
    }
    update (node);
    return balance (node);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5773279_5773355_153_165
5773279_5773355_170_191
Title: Checking whether two vertices are connected 
----------------------------------------

public String [] getNeighbors (String vertex) {
    int source = getIndex (vertex);
    if (source == - 1) {
        System.out.print ("getNeighbors failed: Vertex ");
        System.out.print (vertex);
        System.out.println (" does not exist.");
        return null;
    }
    return Edges [source].copyIntoArray ();
}
----------------------------------------

public int [] getNeighbors (int index) {
    if ((index < 0) || (index >= numVertices)) {
        System.out.print ("getNeighbors failed: Index");
        System.out.print (index);
        System.out.println (" is out of bounds.");
        return null;
    }
    String [] nbrNames = getNeighbors (names [index]);
    int [] nbrIndices = new int [nbrNames.length];
    for (int i = 0;
    i < nbrIndices.length; i ++) nbrIndices [i] = getIndex (nbrNames [i]);

    return nbrIndices;
}
----------------------------------------
